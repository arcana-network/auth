;(function (f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f()
  } else if (typeof define === 'function' && define.amd) {
    define([], f)
  } else {
    var g
    if (typeof window !== 'undefined') {
      g = window
    } else if (typeof global !== 'undefined') {
      g = global
    } else if (typeof self !== 'undefined') {
      g = self
    } else {
      g = this
    }
    g.multiversxSdkCore = f()
  }
})(function () {
  var define, module, exports
  return (function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = 'function' == typeof require && require
            if (!f && c) return c(i, !0)
            if (u) return u(i, !0)
            var a = new Error("Cannot find module '" + i + "'")
            throw ((a.code = 'MODULE_NOT_FOUND'), a)
          }
          var p = (n[i] = { exports: {} })
          e[i][0].call(
            p.exports,
            function (r) {
              var n = e[i][1][r]
              return o(n || r)
            },
            p,
            p.exports,
            r,
            e,
            n,
            t
          )
        }
        return n[i].exports
      }
      for (
        var u = 'function' == typeof require && require, i = 0;
        i < t.length;
        i++
      )
        o(t[i])
      return o
    }
    return r
  })()(
    {
      1: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.TokenTransferProperties =
                exports.TransactionMetadataTransfer =
                exports.TransactionMetadata =
                exports.TransactionToDecode =
                exports.TransactionDecoder =
                  void 0
              const bech32_1 = require('bech32')
              class TransactionDecoder {
                getTransactionMetadata(transaction) {
                  const metadata =
                    this.getNormalTransactionMetadata(transaction)
                  const esdtMetadata = this.getEsdtTransactionMetadata(metadata)
                  if (esdtMetadata) {
                    return esdtMetadata
                  }
                  const nftMetadata = this.getNftTransferMetadata(metadata)
                  if (nftMetadata) {
                    return nftMetadata
                  }
                  const multiMetadata = this.getMultiTransferMetadata(metadata)
                  if (multiMetadata) {
                    return multiMetadata
                  }
                  return metadata
                }
                getNormalTransactionMetadata(transaction) {
                  const metadata = new TransactionMetadata()
                  metadata.sender = transaction.sender
                  metadata.receiver = transaction.receiver
                  metadata.value = BigInt(transaction.value)
                  if (transaction.data) {
                    const decodedData = this.base64Decode(transaction.data)
                    const dataComponents = decodedData.split('@')
                    const args = dataComponents.slice(1)
                    if (args.every((x) => this.isSmartContractArgument(x))) {
                      metadata.functionName = dataComponents[0]
                      metadata.functionArgs = args
                    }
                    if (
                      metadata.functionName === 'relayedTx' &&
                      metadata.functionArgs &&
                      metadata.functionArgs.length === 1
                    ) {
                      try {
                        const relayedTransaction = JSON.parse(
                          this.hexToString(metadata.functionArgs[0])
                        )
                        relayedTransaction.value =
                          relayedTransaction.value.toString()
                        relayedTransaction.sender = this.bech32Encode(
                          this.base64ToHex(relayedTransaction.sender)
                        )
                        relayedTransaction.receiver = this.bech32Encode(
                          this.base64ToHex(relayedTransaction.receiver)
                        )
                        return this.getNormalTransactionMetadata(
                          relayedTransaction
                        )
                      } catch (error) {
                        // nothing special
                      }
                    }
                    if (
                      metadata.functionName === 'relayedTxV2' &&
                      metadata.functionArgs &&
                      metadata.functionArgs.length === 4
                    ) {
                      try {
                        const relayedTransaction = new TransactionToDecode()
                        relayedTransaction.sender = transaction.receiver
                        relayedTransaction.receiver = this.bech32Encode(
                          metadata.functionArgs[0]
                        )
                        relayedTransaction.data = this.base64Encode(
                          this.hexToString(metadata.functionArgs[2])
                        )
                        relayedTransaction.value = '0'
                        return this.getNormalTransactionMetadata(
                          relayedTransaction
                        )
                      } catch (error) {
                        // nothing special
                      }
                    }
                  }
                  return metadata
                }
                getMultiTransferMetadata(metadata) {
                  if (metadata.sender !== metadata.receiver) {
                    return undefined
                  }
                  if (metadata.functionName !== 'MultiESDTNFTTransfer') {
                    return undefined
                  }
                  const args = metadata.functionArgs
                  if (!args) {
                    return undefined
                  }
                  if (args.length < 3) {
                    return undefined
                  }
                  if (!this.isAddressValid(args[0])) {
                    return undefined
                  }
                  const receiver = this.bech32Encode(args[0])
                  const transferCount = this.hexToNumber(args[1])
                  const result = new TransactionMetadata()
                  if (!result.transfers) {
                    result.transfers = []
                  }
                  let index = 2
                  for (let i = 0; i < transferCount; i++) {
                    const identifier = this.hexToString(args[index++])
                    const nonce = args[index++]
                    const value = this.hexToBigInt(args[index++])
                    if (nonce) {
                      result.transfers.push({
                        value,
                        properties: {
                          collection: identifier,
                          identifier: `${identifier}-${nonce}`,
                        },
                      })
                    } else {
                      result.transfers.push({
                        value,
                        properties: {
                          token: identifier,
                        },
                      })
                    }
                  }
                  result.sender = metadata.sender
                  result.receiver = receiver
                  if (args.length > index) {
                    result.functionName = this.hexToString(args[index++])
                    result.functionArgs = args.slice(index++)
                  }
                  return result
                }
                getNftTransferMetadata(metadata) {
                  if (metadata.sender !== metadata.receiver) {
                    return undefined
                  }
                  if (metadata.functionName !== 'ESDTNFTTransfer') {
                    return undefined
                  }
                  const args = metadata.functionArgs
                  if (!args) {
                    return undefined
                  }
                  if (args.length < 4) {
                    return undefined
                  }
                  if (!this.isAddressValid(args[3])) {
                    return undefined
                  }
                  const collectionIdentifier = this.hexToString(args[0])
                  const nonce = args[1]
                  const value = this.hexToBigInt(args[2])
                  const receiver = this.bech32Encode(args[3])
                  const result = new TransactionMetadata()
                  result.sender = metadata.sender
                  result.receiver = receiver
                  result.value = value
                  if (args.length > 4) {
                    result.functionName = this.hexToString(args[4])
                    result.functionArgs = args.slice(5)
                  }
                  result.transfers = [
                    {
                      value,
                      properties: {
                        collection: collectionIdentifier,
                        identifier: `${collectionIdentifier}-${nonce}`,
                      },
                    },
                  ]
                  return result
                }
                base64Encode(str) {
                  return Buffer.from(str).toString('base64')
                }
                base64Decode(str) {
                  return Buffer.from(str, 'base64').toString('binary')
                }
                hexToNumber(hex) {
                  return parseInt(hex, 16)
                }
                getEsdtTransactionMetadata(metadata) {
                  if (metadata.functionName !== 'ESDTTransfer') {
                    return undefined
                  }
                  const args = metadata.functionArgs
                  if (!args) {
                    return undefined
                  }
                  if (args.length < 2) {
                    return undefined
                  }
                  const tokenIdentifier = this.hexToString(args[0])
                  const value = this.hexToBigInt(args[1])
                  const result = new TransactionMetadata()
                  result.sender = metadata.sender
                  result.receiver = metadata.receiver
                  if (args.length > 2) {
                    result.functionName = this.hexToString(args[2])
                    result.functionArgs = args.slice(3)
                  }
                  result.transfers = [
                    {
                      value,
                      properties: {
                        identifier: tokenIdentifier,
                      },
                    },
                  ]
                  result.value = value
                  return result
                }
                bech32Encode(address) {
                  const pubKey = Buffer.from(address, 'hex')
                  const words = bech32_1.bech32.toWords(pubKey)
                  return bech32_1.bech32.encode('erd', words)
                }
                isAddressValid(address) {
                  return Buffer.from(address, 'hex').length == 32
                }
                isSmartContractArgument(arg) {
                  if (!this.isHex(arg)) {
                    return false
                  }
                  if (arg.length % 2 !== 0) {
                    return false
                  }
                  return true
                }
                isHex(value) {
                  return new RegExp(/[^a-f0-9]/gi).test(value) === false
                }
                base64ToHex(str) {
                  return Buffer.from(str, 'base64').toString('hex')
                }
                hexToString(hex) {
                  return Buffer.from(hex, 'hex').toString('ascii')
                }
                hexToBigInt(hex) {
                  if (!hex) {
                    return BigInt(0)
                  }
                  return BigInt('0x' + hex)
                }
              }
              exports.TransactionDecoder = TransactionDecoder
              class TransactionToDecode {
                constructor() {
                  this.sender = ''
                  this.receiver = ''
                  this.data = ''
                  this.value = '0'
                }
              }
              exports.TransactionToDecode = TransactionToDecode
              class TransactionMetadata {
                constructor() {
                  this.sender = ''
                  this.receiver = ''
                  this.value = BigInt(0)
                }
              }
              exports.TransactionMetadata = TransactionMetadata
              class TransactionMetadataTransfer {
                constructor() {
                  this.value = BigInt(0)
                }
              }
              exports.TransactionMetadataTransfer = TransactionMetadataTransfer
              class TokenTransferProperties {}
              exports.TokenTransferProperties = TokenTransferProperties
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { bech32: 2, buffer: 18 },
      ],
      2: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.bech32m = exports.bech32 = void 0
          const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'
          const ALPHABET_MAP = {}
          for (let z = 0; z < ALPHABET.length; z++) {
            const x = ALPHABET.charAt(z)
            ALPHABET_MAP[x] = z
          }
          function polymodStep(pre) {
            const b = pre >> 25
            return (
              ((pre & 0x1ffffff) << 5) ^
              (-((b >> 0) & 1) & 0x3b6a57b2) ^
              (-((b >> 1) & 1) & 0x26508e6d) ^
              (-((b >> 2) & 1) & 0x1ea119fa) ^
              (-((b >> 3) & 1) & 0x3d4233dd) ^
              (-((b >> 4) & 1) & 0x2a1462b3)
            )
          }
          function prefixChk(prefix) {
            let chk = 1
            for (let i = 0; i < prefix.length; ++i) {
              const c = prefix.charCodeAt(i)
              if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'
              chk = polymodStep(chk) ^ (c >> 5)
            }
            chk = polymodStep(chk)
            for (let i = 0; i < prefix.length; ++i) {
              const v = prefix.charCodeAt(i)
              chk = polymodStep(chk) ^ (v & 0x1f)
            }
            return chk
          }
          function convert(data, inBits, outBits, pad) {
            let value = 0
            let bits = 0
            const maxV = (1 << outBits) - 1
            const result = []
            for (let i = 0; i < data.length; ++i) {
              value = (value << inBits) | data[i]
              bits += inBits
              while (bits >= outBits) {
                bits -= outBits
                result.push((value >> bits) & maxV)
              }
            }
            if (pad) {
              if (bits > 0) {
                result.push((value << (outBits - bits)) & maxV)
              }
            } else {
              if (bits >= inBits) return 'Excess padding'
              if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'
            }
            return result
          }
          function toWords(bytes) {
            return convert(bytes, 8, 5, true)
          }
          function fromWordsUnsafe(words) {
            const res = convert(words, 5, 8, false)
            if (Array.isArray(res)) return res
          }
          function fromWords(words) {
            const res = convert(words, 5, 8, false)
            if (Array.isArray(res)) return res
            throw new Error(res)
          }
          function getLibraryFromEncoding(encoding) {
            let ENCODING_CONST
            if (encoding === 'bech32') {
              ENCODING_CONST = 1
            } else {
              ENCODING_CONST = 0x2bc830a3
            }
            function encode(prefix, words, LIMIT) {
              LIMIT = LIMIT || 90
              if (prefix.length + 7 + words.length > LIMIT)
                throw new TypeError('Exceeds length limit')
              prefix = prefix.toLowerCase()
              // determine chk mod
              let chk = prefixChk(prefix)
              if (typeof chk === 'string') throw new Error(chk)
              let result = prefix + '1'
              for (let i = 0; i < words.length; ++i) {
                const x = words[i]
                if (x >> 5 !== 0) throw new Error('Non 5-bit word')
                chk = polymodStep(chk) ^ x
                result += ALPHABET.charAt(x)
              }
              for (let i = 0; i < 6; ++i) {
                chk = polymodStep(chk)
              }
              chk ^= ENCODING_CONST
              for (let i = 0; i < 6; ++i) {
                const v = (chk >> ((5 - i) * 5)) & 0x1f
                result += ALPHABET.charAt(v)
              }
              return result
            }
            function __decode(str, LIMIT) {
              LIMIT = LIMIT || 90
              if (str.length < 8) return str + ' too short'
              if (str.length > LIMIT) return 'Exceeds length limit'
              // don't allow mixed case
              const lowered = str.toLowerCase()
              const uppered = str.toUpperCase()
              if (str !== lowered && str !== uppered)
                return 'Mixed-case string ' + str
              str = lowered
              const split = str.lastIndexOf('1')
              if (split === -1) return 'No separator character for ' + str
              if (split === 0) return 'Missing prefix for ' + str
              const prefix = str.slice(0, split)
              const wordChars = str.slice(split + 1)
              if (wordChars.length < 6) return 'Data too short'
              let chk = prefixChk(prefix)
              if (typeof chk === 'string') return chk
              const words = []
              for (let i = 0; i < wordChars.length; ++i) {
                const c = wordChars.charAt(i)
                const v = ALPHABET_MAP[c]
                if (v === undefined) return 'Unknown character ' + c
                chk = polymodStep(chk) ^ v
                // not in the checksum?
                if (i + 6 >= wordChars.length) continue
                words.push(v)
              }
              if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str
              return { prefix, words }
            }
            function decodeUnsafe(str, LIMIT) {
              const res = __decode(str, LIMIT)
              if (typeof res === 'object') return res
            }
            function decode(str, LIMIT) {
              const res = __decode(str, LIMIT)
              if (typeof res === 'object') return res
              throw new Error(res)
            }
            return {
              decodeUnsafe,
              decode,
              encode,
              toWords,
              fromWordsUnsafe,
              fromWords,
            }
          }
          exports.bech32 = getLibraryFromEncoding('bech32')
          exports.bech32m = getLibraryFromEncoding('bech32m')
        },
        {},
      ],
      3: [
        function (require, module, exports) {
          'use strict'
          module.exports = asPromise

          /**
           * Callback as used by {@link util.asPromise}.
           * @typedef asPromiseCallback
           * @type {function}
           * @param {Error|null} error Error, if any
           * @param {...*} params Additional arguments
           * @returns {undefined}
           */

          /**
           * Returns a promise from a node-style callback function.
           * @memberof util
           * @param {asPromiseCallback} fn Function to call
           * @param {*} ctx Function context
           * @param {...*} params Function arguments
           * @returns {Promise<*>} Promisified function
           */
          function asPromise(fn, ctx /*, varargs */) {
            var params = new Array(arguments.length - 1),
              offset = 0,
              index = 2,
              pending = true
            while (index < arguments.length)
              params[offset++] = arguments[index++]
            return new Promise(function executor(resolve, reject) {
              params[offset] = function callback(err /*, varargs */) {
                if (pending) {
                  pending = false
                  if (err) reject(err)
                  else {
                    var params = new Array(arguments.length - 1),
                      offset = 0
                    while (offset < params.length)
                      params[offset++] = arguments[offset]
                    resolve.apply(null, params)
                  }
                }
              }
              try {
                fn.apply(ctx || null, params)
              } catch (err) {
                if (pending) {
                  pending = false
                  reject(err)
                }
              }
            })
          }
        },
        {},
      ],
      4: [
        function (require, module, exports) {
          'use strict'

          /**
           * A minimal base64 implementation for number arrays.
           * @memberof util
           * @namespace
           */
          var base64 = exports

          /**
           * Calculates the byte length of a base64 encoded string.
           * @param {string} string Base64 encoded string
           * @returns {number} Byte length
           */
          base64.length = function length(string) {
            var p = string.length
            if (!p) return 0
            var n = 0
            while (--p % 4 > 1 && string.charAt(p) === '=') ++n
            return Math.ceil(string.length * 3) / 4 - n
          }

          // Base64 encoding table
          var b64 = new Array(64)

          // Base64 decoding table
          var s64 = new Array(123)

          // 65..90, 97..122, 48..57, 43, 47
          for (var i = 0; i < 64; )
            s64[
              (b64[i] =
                i < 26
                  ? i + 65
                  : i < 52
                  ? i + 71
                  : i < 62
                  ? i - 4
                  : (i - 59) | 43)
            ] = i++

          /**
           * Encodes a buffer to a base64 encoded string.
           * @param {Uint8Array} buffer Source buffer
           * @param {number} start Source start
           * @param {number} end Source end
           * @returns {string} Base64 encoded string
           */
          base64.encode = function encode(buffer, start, end) {
            var parts = null,
              chunk = []
            var i = 0, // output index
              j = 0, // goto index
              t // temporary
            while (start < end) {
              var b = buffer[start++]
              switch (j) {
                case 0:
                  chunk[i++] = b64[b >> 2]
                  t = (b & 3) << 4
                  j = 1
                  break
                case 1:
                  chunk[i++] = b64[t | (b >> 4)]
                  t = (b & 15) << 2
                  j = 2
                  break
                case 2:
                  chunk[i++] = b64[t | (b >> 6)]
                  chunk[i++] = b64[b & 63]
                  j = 0
                  break
              }
              if (i > 8191) {
                ;(parts || (parts = [])).push(
                  String.fromCharCode.apply(String, chunk)
                )
                i = 0
              }
            }
            if (j) {
              chunk[i++] = b64[t]
              chunk[i++] = 61
              if (j === 1) chunk[i++] = 61
            }
            if (parts) {
              if (i)
                parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))
              return parts.join('')
            }
            return String.fromCharCode.apply(String, chunk.slice(0, i))
          }

          var invalidEncoding = 'invalid encoding'

          /**
           * Decodes a base64 encoded string to a buffer.
           * @param {string} string Source string
           * @param {Uint8Array} buffer Destination buffer
           * @param {number} offset Destination offset
           * @returns {number} Number of bytes written
           * @throws {Error} If encoding is invalid
           */
          base64.decode = function decode(string, buffer, offset) {
            var start = offset
            var j = 0, // goto index
              t // temporary
            for (var i = 0; i < string.length; ) {
              var c = string.charCodeAt(i++)
              if (c === 61 && j > 1) break
              if ((c = s64[c]) === undefined) throw Error(invalidEncoding)
              switch (j) {
                case 0:
                  t = c
                  j = 1
                  break
                case 1:
                  buffer[offset++] = (t << 2) | ((c & 48) >> 4)
                  t = c
                  j = 2
                  break
                case 2:
                  buffer[offset++] = ((t & 15) << 4) | ((c & 60) >> 2)
                  t = c
                  j = 3
                  break
                case 3:
                  buffer[offset++] = ((t & 3) << 6) | c
                  j = 0
                  break
              }
            }
            if (j === 1) throw Error(invalidEncoding)
            return offset - start
          }

          /**
           * Tests if the specified string appears to be base64 encoded.
           * @param {string} string String to test
           * @returns {boolean} `true` if probably base64 encoded, otherwise false
           */
          base64.test = function test(string) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(
              string
            )
          }
        },
        {},
      ],
      5: [
        function (require, module, exports) {
          'use strict'
          module.exports = EventEmitter

          /**
           * Constructs a new event emitter instance.
           * @classdesc A minimal event emitter.
           * @memberof util
           * @constructor
           */
          function EventEmitter() {
            /**
             * Registered listeners.
             * @type {Object.<string,*>}
             * @private
             */
            this._listeners = {}
          }

          /**
           * Registers an event listener.
           * @param {string} evt Event name
           * @param {function} fn Listener
           * @param {*} [ctx] Listener context
           * @returns {util.EventEmitter} `this`
           */
          EventEmitter.prototype.on = function on(evt, fn, ctx) {
            ;(this._listeners[evt] || (this._listeners[evt] = [])).push({
              fn: fn,
              ctx: ctx || this,
            })
            return this
          }

          /**
           * Removes an event listener or any matching listeners if arguments are omitted.
           * @param {string} [evt] Event name. Removes all listeners if omitted.
           * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
           * @returns {util.EventEmitter} `this`
           */
          EventEmitter.prototype.off = function off(evt, fn) {
            if (evt === undefined) this._listeners = {}
            else {
              if (fn === undefined) this._listeners[evt] = []
              else {
                var listeners = this._listeners[evt]
                for (var i = 0; i < listeners.length; )
                  if (listeners[i].fn === fn) listeners.splice(i, 1)
                  else ++i
              }
            }
            return this
          }

          /**
           * Emits an event by calling its listeners with the specified arguments.
           * @param {string} evt Event name
           * @param {...*} args Arguments
           * @returns {util.EventEmitter} `this`
           */
          EventEmitter.prototype.emit = function emit(evt) {
            var listeners = this._listeners[evt]
            if (listeners) {
              var args = [],
                i = 1
              for (; i < arguments.length; ) args.push(arguments[i++])
              for (i = 0; i < listeners.length; )
                listeners[i].fn.apply(listeners[i++].ctx, args)
            }
            return this
          }
        },
        {},
      ],
      6: [
        function (require, module, exports) {
          'use strict'

          module.exports = factory(factory)

          /**
           * Reads / writes floats / doubles from / to buffers.
           * @name util.float
           * @namespace
           */

          /**
           * Writes a 32 bit float to a buffer using little endian byte order.
           * @name util.float.writeFloatLE
           * @function
           * @param {number} val Value to write
           * @param {Uint8Array} buf Target buffer
           * @param {number} pos Target buffer offset
           * @returns {undefined}
           */

          /**
           * Writes a 32 bit float to a buffer using big endian byte order.
           * @name util.float.writeFloatBE
           * @function
           * @param {number} val Value to write
           * @param {Uint8Array} buf Target buffer
           * @param {number} pos Target buffer offset
           * @returns {undefined}
           */

          /**
           * Reads a 32 bit float from a buffer using little endian byte order.
           * @name util.float.readFloatLE
           * @function
           * @param {Uint8Array} buf Source buffer
           * @param {number} pos Source buffer offset
           * @returns {number} Value read
           */

          /**
           * Reads a 32 bit float from a buffer using big endian byte order.
           * @name util.float.readFloatBE
           * @function
           * @param {Uint8Array} buf Source buffer
           * @param {number} pos Source buffer offset
           * @returns {number} Value read
           */

          /**
           * Writes a 64 bit double to a buffer using little endian byte order.
           * @name util.float.writeDoubleLE
           * @function
           * @param {number} val Value to write
           * @param {Uint8Array} buf Target buffer
           * @param {number} pos Target buffer offset
           * @returns {undefined}
           */

          /**
           * Writes a 64 bit double to a buffer using big endian byte order.
           * @name util.float.writeDoubleBE
           * @function
           * @param {number} val Value to write
           * @param {Uint8Array} buf Target buffer
           * @param {number} pos Target buffer offset
           * @returns {undefined}
           */

          /**
           * Reads a 64 bit double from a buffer using little endian byte order.
           * @name util.float.readDoubleLE
           * @function
           * @param {Uint8Array} buf Source buffer
           * @param {number} pos Source buffer offset
           * @returns {number} Value read
           */

          /**
           * Reads a 64 bit double from a buffer using big endian byte order.
           * @name util.float.readDoubleBE
           * @function
           * @param {Uint8Array} buf Source buffer
           * @param {number} pos Source buffer offset
           * @returns {number} Value read
           */

          // Factory function for the purpose of node-based testing in modified global environments
          function factory(exports) {
            // float: typed array
            if (typeof Float32Array !== 'undefined')
              (function () {
                var f32 = new Float32Array([-0]),
                  f8b = new Uint8Array(f32.buffer),
                  le = f8b[3] === 128

                function writeFloat_f32_cpy(val, buf, pos) {
                  f32[0] = val
                  buf[pos] = f8b[0]
                  buf[pos + 1] = f8b[1]
                  buf[pos + 2] = f8b[2]
                  buf[pos + 3] = f8b[3]
                }

                function writeFloat_f32_rev(val, buf, pos) {
                  f32[0] = val
                  buf[pos] = f8b[3]
                  buf[pos + 1] = f8b[2]
                  buf[pos + 2] = f8b[1]
                  buf[pos + 3] = f8b[0]
                }

                /* istanbul ignore next */
                exports.writeFloatLE = le
                  ? writeFloat_f32_cpy
                  : writeFloat_f32_rev
                /* istanbul ignore next */
                exports.writeFloatBE = le
                  ? writeFloat_f32_rev
                  : writeFloat_f32_cpy

                function readFloat_f32_cpy(buf, pos) {
                  f8b[0] = buf[pos]
                  f8b[1] = buf[pos + 1]
                  f8b[2] = buf[pos + 2]
                  f8b[3] = buf[pos + 3]
                  return f32[0]
                }

                function readFloat_f32_rev(buf, pos) {
                  f8b[3] = buf[pos]
                  f8b[2] = buf[pos + 1]
                  f8b[1] = buf[pos + 2]
                  f8b[0] = buf[pos + 3]
                  return f32[0]
                }

                /* istanbul ignore next */
                exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev
                /* istanbul ignore next */
                exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy

                // float: ieee754
              })()
            else
              (function () {
                function writeFloat_ieee754(writeUint, val, buf, pos) {
                  var sign = val < 0 ? 1 : 0
                  if (sign) val = -val
                  if (val === 0)
                    writeUint(
                      1 / val > 0
                        ? /* positive */ 0
                        : /* negative 0 */ 2147483648,
                      buf,
                      pos
                    )
                  else if (isNaN(val)) writeUint(2143289344, buf, pos)
                  else if (val > 3.4028234663852886e38)
                    // +-Infinity
                    writeUint(((sign << 31) | 2139095040) >>> 0, buf, pos)
                  else if (val < 1.1754943508222875e-38)
                    // denormal
                    writeUint(
                      ((sign << 31) |
                        Math.round(val / 1.401298464324817e-45)) >>>
                        0,
                      buf,
                      pos
                    )
                  else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2),
                      mantissa =
                        Math.round(val * Math.pow(2, -exponent) * 8388608) &
                        8388607
                    writeUint(
                      ((sign << 31) | ((exponent + 127) << 23) | mantissa) >>>
                        0,
                      buf,
                      pos
                    )
                  }
                }

                exports.writeFloatLE = writeFloat_ieee754.bind(
                  null,
                  writeUintLE
                )
                exports.writeFloatBE = writeFloat_ieee754.bind(
                  null,
                  writeUintBE
                )

                function readFloat_ieee754(readUint, buf, pos) {
                  var uint = readUint(buf, pos),
                    sign = (uint >> 31) * 2 + 1,
                    exponent = (uint >>> 23) & 255,
                    mantissa = uint & 8388607
                  return exponent === 255
                    ? mantissa
                      ? NaN
                      : sign * Infinity
                    : exponent === 0 // denormal
                    ? sign * 1.401298464324817e-45 * mantissa
                    : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608)
                }

                exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE)
                exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE)
              })()

            // double: typed array
            if (typeof Float64Array !== 'undefined')
              (function () {
                var f64 = new Float64Array([-0]),
                  f8b = new Uint8Array(f64.buffer),
                  le = f8b[7] === 128

                function writeDouble_f64_cpy(val, buf, pos) {
                  f64[0] = val
                  buf[pos] = f8b[0]
                  buf[pos + 1] = f8b[1]
                  buf[pos + 2] = f8b[2]
                  buf[pos + 3] = f8b[3]
                  buf[pos + 4] = f8b[4]
                  buf[pos + 5] = f8b[5]
                  buf[pos + 6] = f8b[6]
                  buf[pos + 7] = f8b[7]
                }

                function writeDouble_f64_rev(val, buf, pos) {
                  f64[0] = val
                  buf[pos] = f8b[7]
                  buf[pos + 1] = f8b[6]
                  buf[pos + 2] = f8b[5]
                  buf[pos + 3] = f8b[4]
                  buf[pos + 4] = f8b[3]
                  buf[pos + 5] = f8b[2]
                  buf[pos + 6] = f8b[1]
                  buf[pos + 7] = f8b[0]
                }

                /* istanbul ignore next */
                exports.writeDoubleLE = le
                  ? writeDouble_f64_cpy
                  : writeDouble_f64_rev
                /* istanbul ignore next */
                exports.writeDoubleBE = le
                  ? writeDouble_f64_rev
                  : writeDouble_f64_cpy

                function readDouble_f64_cpy(buf, pos) {
                  f8b[0] = buf[pos]
                  f8b[1] = buf[pos + 1]
                  f8b[2] = buf[pos + 2]
                  f8b[3] = buf[pos + 3]
                  f8b[4] = buf[pos + 4]
                  f8b[5] = buf[pos + 5]
                  f8b[6] = buf[pos + 6]
                  f8b[7] = buf[pos + 7]
                  return f64[0]
                }

                function readDouble_f64_rev(buf, pos) {
                  f8b[7] = buf[pos]
                  f8b[6] = buf[pos + 1]
                  f8b[5] = buf[pos + 2]
                  f8b[4] = buf[pos + 3]
                  f8b[3] = buf[pos + 4]
                  f8b[2] = buf[pos + 5]
                  f8b[1] = buf[pos + 6]
                  f8b[0] = buf[pos + 7]
                  return f64[0]
                }

                /* istanbul ignore next */
                exports.readDoubleLE = le
                  ? readDouble_f64_cpy
                  : readDouble_f64_rev
                /* istanbul ignore next */
                exports.readDoubleBE = le
                  ? readDouble_f64_rev
                  : readDouble_f64_cpy

                // double: ieee754
              })()
            else
              (function () {
                function writeDouble_ieee754(
                  writeUint,
                  off0,
                  off1,
                  val,
                  buf,
                  pos
                ) {
                  var sign = val < 0 ? 1 : 0
                  if (sign) val = -val
                  if (val === 0) {
                    writeUint(0, buf, pos + off0)
                    writeUint(
                      1 / val > 0
                        ? /* positive */ 0
                        : /* negative 0 */ 2147483648,
                      buf,
                      pos + off1
                    )
                  } else if (isNaN(val)) {
                    writeUint(0, buf, pos + off0)
                    writeUint(2146959360, buf, pos + off1)
                  } else if (val > 1.7976931348623157e308) {
                    // +-Infinity
                    writeUint(0, buf, pos + off0)
                    writeUint(
                      ((sign << 31) | 2146435072) >>> 0,
                      buf,
                      pos + off1
                    )
                  } else {
                    var mantissa
                    if (val < 2.2250738585072014e-308) {
                      // denormal
                      mantissa = val / 5e-324
                      writeUint(mantissa >>> 0, buf, pos + off0)
                      writeUint(
                        ((sign << 31) | (mantissa / 4294967296)) >>> 0,
                        buf,
                        pos + off1
                      )
                    } else {
                      var exponent = Math.floor(Math.log(val) / Math.LN2)
                      if (exponent === 1024) exponent = 1023
                      mantissa = val * Math.pow(2, -exponent)
                      writeUint(
                        (mantissa * 4503599627370496) >>> 0,
                        buf,
                        pos + off0
                      )
                      writeUint(
                        ((sign << 31) |
                          ((exponent + 1023) << 20) |
                          ((mantissa * 1048576) & 1048575)) >>>
                          0,
                        buf,
                        pos + off1
                      )
                    }
                  }
                }

                exports.writeDoubleLE = writeDouble_ieee754.bind(
                  null,
                  writeUintLE,
                  0,
                  4
                )
                exports.writeDoubleBE = writeDouble_ieee754.bind(
                  null,
                  writeUintBE,
                  4,
                  0
                )

                function readDouble_ieee754(readUint, off0, off1, buf, pos) {
                  var lo = readUint(buf, pos + off0),
                    hi = readUint(buf, pos + off1)
                  var sign = (hi >> 31) * 2 + 1,
                    exponent = (hi >>> 20) & 2047,
                    mantissa = 4294967296 * (hi & 1048575) + lo
                  return exponent === 2047
                    ? mantissa
                      ? NaN
                      : sign * Infinity
                    : exponent === 0 // denormal
                    ? sign * 5e-324 * mantissa
                    : sign *
                      Math.pow(2, exponent - 1075) *
                      (mantissa + 4503599627370496)
                }

                exports.readDoubleLE = readDouble_ieee754.bind(
                  null,
                  readUintLE,
                  0,
                  4
                )
                exports.readDoubleBE = readDouble_ieee754.bind(
                  null,
                  readUintBE,
                  4,
                  0
                )
              })()

            return exports
          }

          // uint helpers

          function writeUintLE(val, buf, pos) {
            buf[pos] = val & 255
            buf[pos + 1] = (val >>> 8) & 255
            buf[pos + 2] = (val >>> 16) & 255
            buf[pos + 3] = val >>> 24
          }

          function writeUintBE(val, buf, pos) {
            buf[pos] = val >>> 24
            buf[pos + 1] = (val >>> 16) & 255
            buf[pos + 2] = (val >>> 8) & 255
            buf[pos + 3] = val & 255
          }

          function readUintLE(buf, pos) {
            return (
              (buf[pos] |
                (buf[pos + 1] << 8) |
                (buf[pos + 2] << 16) |
                (buf[pos + 3] << 24)) >>>
              0
            )
          }

          function readUintBE(buf, pos) {
            return (
              ((buf[pos] << 24) |
                (buf[pos + 1] << 16) |
                (buf[pos + 2] << 8) |
                buf[pos + 3]) >>>
              0
            )
          }
        },
        {},
      ],
      7: [
        function (require, module, exports) {
          'use strict'
          module.exports = inquire

          /**
           * Requires a module only if available.
           * @memberof util
           * @param {string} moduleName Module to require
           * @returns {?Object} Required module if available and not empty, otherwise `null`
           */
          function inquire(moduleName) {
            try {
              var mod = eval('quire'.replace(/^/, 're'))(moduleName) // eslint-disable-line no-eval
              if (mod && (mod.length || Object.keys(mod).length)) return mod
            } catch (e) {} // eslint-disable-line no-empty
            return null
          }
        },
        {},
      ],
      8: [
        function (require, module, exports) {
          'use strict'
          module.exports = pool

          /**
           * An allocator as used by {@link util.pool}.
           * @typedef PoolAllocator
           * @type {function}
           * @param {number} size Buffer size
           * @returns {Uint8Array} Buffer
           */

          /**
           * A slicer as used by {@link util.pool}.
           * @typedef PoolSlicer
           * @type {function}
           * @param {number} start Start offset
           * @param {number} end End offset
           * @returns {Uint8Array} Buffer slice
           * @this {Uint8Array}
           */

          /**
           * A general purpose buffer pool.
           * @memberof util
           * @function
           * @param {PoolAllocator} alloc Allocator
           * @param {PoolSlicer} slice Slicer
           * @param {number} [size=8192] Slab size
           * @returns {PoolAllocator} Pooled allocator
           */
          function pool(alloc, slice, size) {
            var SIZE = size || 8192
            var MAX = SIZE >>> 1
            var slab = null
            var offset = SIZE
            return function pool_alloc(size) {
              if (size < 1 || size > MAX) return alloc(size)
              if (offset + size > SIZE) {
                slab = alloc(SIZE)
                offset = 0
              }
              var buf = slice.call(slab, offset, (offset += size))
              if (offset & 7)
                // align to 32 bit
                offset = (offset | 7) + 1
              return buf
            }
          }
        },
        {},
      ],
      9: [
        function (require, module, exports) {
          'use strict'

          /**
           * A minimal UTF8 implementation for number arrays.
           * @memberof util
           * @namespace
           */
          var utf8 = exports

          /**
           * Calculates the UTF8 byte length of a string.
           * @param {string} string String
           * @returns {number} Byte length
           */
          utf8.length = function utf8_length(string) {
            var len = 0,
              c = 0
            for (var i = 0; i < string.length; ++i) {
              c = string.charCodeAt(i)
              if (c < 128) len += 1
              else if (c < 2048) len += 2
              else if (
                (c & 0xfc00) === 0xd800 &&
                (string.charCodeAt(i + 1) & 0xfc00) === 0xdc00
              ) {
                ++i
                len += 4
              } else len += 3
            }
            return len
          }

          /**
           * Reads UTF8 bytes as a string.
           * @param {Uint8Array} buffer Source buffer
           * @param {number} start Source start
           * @param {number} end Source end
           * @returns {string} String read
           */
          utf8.read = function utf8_read(buffer, start, end) {
            var len = end - start
            if (len < 1) return ''
            var parts = null,
              chunk = [],
              i = 0, // char offset
              t // temporary
            while (start < end) {
              t = buffer[start++]
              if (t < 128) chunk[i++] = t
              else if (t > 191 && t < 224)
                chunk[i++] = ((t & 31) << 6) | (buffer[start++] & 63)
              else if (t > 239 && t < 365) {
                t =
                  (((t & 7) << 18) |
                    ((buffer[start++] & 63) << 12) |
                    ((buffer[start++] & 63) << 6) |
                    (buffer[start++] & 63)) -
                  0x10000
                chunk[i++] = 0xd800 + (t >> 10)
                chunk[i++] = 0xdc00 + (t & 1023)
              } else
                chunk[i++] =
                  ((t & 15) << 12) |
                  ((buffer[start++] & 63) << 6) |
                  (buffer[start++] & 63)
              if (i > 8191) {
                ;(parts || (parts = [])).push(
                  String.fromCharCode.apply(String, chunk)
                )
                i = 0
              }
            }
            if (parts) {
              if (i)
                parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))
              return parts.join('')
            }
            return String.fromCharCode.apply(String, chunk.slice(0, i))
          }

          /**
           * Writes a string as UTF8 bytes.
           * @param {string} string Source string
           * @param {Uint8Array} buffer Destination buffer
           * @param {number} offset Destination offset
           * @returns {number} Bytes written
           */
          utf8.write = function utf8_write(string, buffer, offset) {
            var start = offset,
              c1, // character 1
              c2 // character 2
            for (var i = 0; i < string.length; ++i) {
              c1 = string.charCodeAt(i)
              if (c1 < 128) {
                buffer[offset++] = c1
              } else if (c1 < 2048) {
                buffer[offset++] = (c1 >> 6) | 192
                buffer[offset++] = (c1 & 63) | 128
              } else if (
                (c1 & 0xfc00) === 0xd800 &&
                ((c2 = string.charCodeAt(i + 1)) & 0xfc00) === 0xdc00
              ) {
                c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)
                ++i
                buffer[offset++] = (c1 >> 18) | 240
                buffer[offset++] = ((c1 >> 12) & 63) | 128
                buffer[offset++] = ((c1 >> 6) & 63) | 128
                buffer[offset++] = (c1 & 63) | 128
              } else {
                buffer[offset++] = (c1 >> 12) | 224
                buffer[offset++] = ((c1 >> 6) & 63) | 128
                buffer[offset++] = (c1 & 63) | 128
              }
            }
            return offset - start
          }
        },
        {},
      ],
      10: [
        function (require, module, exports) {
          'use strict'

          var punycode = require('punycode')

          function BackslashError(offset, err) {
            this.__proto__ = new Error(err)
            this.__proto__.name = 'BackslashError'
            this.offset = offset
          }

          function isOctalDigit(c) {
            return c >= '0' && c <= '7'
          }

          function isHexDigit(c) {
            return (
              (c >= '0' && c <= '9') ||
              (c >= 'a' && c <= 'f') ||
              (c >= 'A' && c <= 'F')
            )
          }

          function parseHex(u) {
            u = parseInt(u, 16)
            // http://stackoverflow.com/a/9109467/510036
            return punycode.ucs2.encode([u])
          }

          function process(arr, pos, stopChar) {
            var escaped = false
            var ret = []

            function assertHexDigit(pos) {
              var c = arr[pos]
              if (!isHexDigit(c)) {
                throw new BackslashError(pos, 'Unexpected token ILLEGAL')
              }
              return c
            }

            while (pos < arr.length) {
              var c = arr[pos]
              pos++
              if (escaped) {
                escaped = false
                switch (c) {
                  case 'n':
                    ret.push('\n')
                    continue
                  case 'r':
                    ret.push('\r')
                    continue
                  case 'f':
                    ret.push('\f')
                    continue
                  case 'b':
                    ret.push('\b')
                    continue
                  case 't':
                    ret.push('\t')
                    continue
                  case 'v':
                    ret.push('\v')
                    continue
                  case '\\':
                    ret.push('\\')
                    continue
                }
                if (c === 'x') {
                  ret.push(
                    parseHex(assertHexDigit(pos) + assertHexDigit(pos + 1))
                  )
                  pos += 2
                  continue
                }
                if (c === 'u') {
                  ret.push(
                    parseHex(
                      assertHexDigit(pos) +
                        assertHexDigit(pos + 1) +
                        assertHexDigit(pos + 2) +
                        assertHexDigit(pos + 3)
                    )
                  )
                  pos += 4
                  continue
                }
                if (isOctalDigit(c)) {
                  var o
                  if (isOctalDigit((o = arr[pos]))) {
                    pos++
                    c += o
                    if (isOctalDigit((o = arr[pos])) && c[0] <= '3') {
                      pos++
                      c += o
                    }
                  }
                  ret.push(punycode.ucs2.encode([parseInt(c, 8)]))
                  continue
                }
                ret.push(c)
              } else if (c === '\\') {
                escaped = true
              } else if (c === stopChar) {
                pos--
                break
              } else {
                ret.push(c)
              }
            }
            return arguments.length === 3
              ? { end: pos, value: ret.join('') }
              : ret.join('')
          }

          module.exports = function backslash(str) {
            return process(str, 0)
          }

          module.exports.parseUntil = function parseUntil(str, pos, stopChar) {
            return process(str, pos, stopChar)
          }
        },
        { punycode: 57 },
      ],
      11: [
        function (require, module, exports) {
          'use strict'

          exports.byteLength = byteLength
          exports.toByteArray = toByteArray
          exports.fromByteArray = fromByteArray

          var lookup = []
          var revLookup = []
          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

          var code =
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i]
            revLookup[code.charCodeAt(i)] = i
          }

          // Support decoding URL-safe base64 strings, as Node.js does.
          // See: https://en.wikipedia.org/wiki/Base64#URL_applications
          revLookup['-'.charCodeAt(0)] = 62
          revLookup['_'.charCodeAt(0)] = 63

          function getLens(b64) {
            var len = b64.length

            if (len % 4 > 0) {
              throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // Trim off extra bytes after placeholder bytes are found
            // See: https://github.com/beatgammit/base64-js/issues/42
            var validLen = b64.indexOf('=')
            if (validLen === -1) validLen = len

            var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4)

            return [validLen, placeHoldersLen]
          }

          // base64 is 4/3 + up to two characters of the original data
          function byteLength(b64) {
            var lens = getLens(b64)
            var validLen = lens[0]
            var placeHoldersLen = lens[1]
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
          }

          function _byteLength(b64, validLen, placeHoldersLen) {
            return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen
          }

          function toByteArray(b64) {
            var tmp
            var lens = getLens(b64)
            var validLen = lens[0]
            var placeHoldersLen = lens[1]

            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

            var curByte = 0

            // if there are placeholders, only get up to the last complete 4 chars
            var len = placeHoldersLen > 0 ? validLen - 4 : validLen

            var i
            for (i = 0; i < len; i += 4) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 18) |
                (revLookup[b64.charCodeAt(i + 1)] << 12) |
                (revLookup[b64.charCodeAt(i + 2)] << 6) |
                revLookup[b64.charCodeAt(i + 3)]
              arr[curByte++] = (tmp >> 16) & 0xff
              arr[curByte++] = (tmp >> 8) & 0xff
              arr[curByte++] = tmp & 0xff
            }

            if (placeHoldersLen === 2) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 2) |
                (revLookup[b64.charCodeAt(i + 1)] >> 4)
              arr[curByte++] = tmp & 0xff
            }

            if (placeHoldersLen === 1) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 10) |
                (revLookup[b64.charCodeAt(i + 1)] << 4) |
                (revLookup[b64.charCodeAt(i + 2)] >> 2)
              arr[curByte++] = (tmp >> 8) & 0xff
              arr[curByte++] = tmp & 0xff
            }

            return arr
          }

          function tripletToBase64(num) {
            return (
              lookup[(num >> 18) & 0x3f] +
              lookup[(num >> 12) & 0x3f] +
              lookup[(num >> 6) & 0x3f] +
              lookup[num & 0x3f]
            )
          }

          function encodeChunk(uint8, start, end) {
            var tmp
            var output = []
            for (var i = start; i < end; i += 3) {
              tmp =
                ((uint8[i] << 16) & 0xff0000) +
                ((uint8[i + 1] << 8) & 0xff00) +
                (uint8[i + 2] & 0xff)
              output.push(tripletToBase64(tmp))
            }
            return output.join('')
          }

          function fromByteArray(uint8) {
            var tmp
            var len = uint8.length
            var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
            var parts = []
            var maxChunkLength = 16383 // must be multiple of 3

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (
              var i = 0, len2 = len - extraBytes;
              i < len2;
              i += maxChunkLength
            ) {
              parts.push(
                encodeChunk(
                  uint8,
                  i,
                  i + maxChunkLength > len2 ? len2 : i + maxChunkLength
                )
              )
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            if (extraBytes === 1) {
              tmp = uint8[len - 1]
              parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + '==')
            } else if (extraBytes === 2) {
              tmp = (uint8[len - 2] << 8) + uint8[len - 1]
              parts.push(
                lookup[tmp >> 10] +
                  lookup[(tmp >> 4) & 0x3f] +
                  lookup[(tmp << 2) & 0x3f] +
                  '='
              )
            }

            return parts.join('')
          }
        },
        {},
      ],
      12: [
        function (require, module, exports) {
          'use strict'
          var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'

          // pre-compute lookup table
          var ALPHABET_MAP = {}
          for (var z = 0; z < ALPHABET.length; z++) {
            var x = ALPHABET.charAt(z)

            if (ALPHABET_MAP[x] !== undefined)
              throw new TypeError(x + ' is ambiguous')
            ALPHABET_MAP[x] = z
          }

          function polymodStep(pre) {
            var b = pre >> 25
            return (
              ((pre & 0x1ffffff) << 5) ^
              (-((b >> 0) & 1) & 0x3b6a57b2) ^
              (-((b >> 1) & 1) & 0x26508e6d) ^
              (-((b >> 2) & 1) & 0x1ea119fa) ^
              (-((b >> 3) & 1) & 0x3d4233dd) ^
              (-((b >> 4) & 1) & 0x2a1462b3)
            )
          }

          function prefixChk(prefix) {
            var chk = 1
            for (var i = 0; i < prefix.length; ++i) {
              var c = prefix.charCodeAt(i)
              if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'

              chk = polymodStep(chk) ^ (c >> 5)
            }
            chk = polymodStep(chk)

            for (i = 0; i < prefix.length; ++i) {
              var v = prefix.charCodeAt(i)
              chk = polymodStep(chk) ^ (v & 0x1f)
            }
            return chk
          }

          function encode(prefix, words, LIMIT) {
            LIMIT = LIMIT || 90
            if (prefix.length + 7 + words.length > LIMIT)
              throw new TypeError('Exceeds length limit')

            prefix = prefix.toLowerCase()

            // determine chk mod
            var chk = prefixChk(prefix)
            if (typeof chk === 'string') throw new Error(chk)

            var result = prefix + '1'
            for (var i = 0; i < words.length; ++i) {
              var x = words[i]
              if (x >> 5 !== 0) throw new Error('Non 5-bit word')

              chk = polymodStep(chk) ^ x
              result += ALPHABET.charAt(x)
            }

            for (i = 0; i < 6; ++i) {
              chk = polymodStep(chk)
            }
            chk ^= 1

            for (i = 0; i < 6; ++i) {
              var v = (chk >> ((5 - i) * 5)) & 0x1f
              result += ALPHABET.charAt(v)
            }

            return result
          }

          function __decode(str, LIMIT) {
            LIMIT = LIMIT || 90
            if (str.length < 8) return str + ' too short'
            if (str.length > LIMIT) return 'Exceeds length limit'

            // don't allow mixed case
            var lowered = str.toLowerCase()
            var uppered = str.toUpperCase()
            if (str !== lowered && str !== uppered)
              return 'Mixed-case string ' + str
            str = lowered

            var split = str.lastIndexOf('1')
            if (split === -1) return 'No separator character for ' + str
            if (split === 0) return 'Missing prefix for ' + str

            var prefix = str.slice(0, split)
            var wordChars = str.slice(split + 1)
            if (wordChars.length < 6) return 'Data too short'

            var chk = prefixChk(prefix)
            if (typeof chk === 'string') return chk

            var words = []
            for (var i = 0; i < wordChars.length; ++i) {
              var c = wordChars.charAt(i)
              var v = ALPHABET_MAP[c]
              if (v === undefined) return 'Unknown character ' + c
              chk = polymodStep(chk) ^ v

              // not in the checksum?
              if (i + 6 >= wordChars.length) continue
              words.push(v)
            }

            if (chk !== 1) return 'Invalid checksum for ' + str
            return { prefix: prefix, words: words }
          }

          function decodeUnsafe() {
            var res = __decode.apply(null, arguments)
            if (typeof res === 'object') return res
          }

          function decode(str) {
            var res = __decode.apply(null, arguments)
            if (typeof res === 'object') return res

            throw new Error(res)
          }

          function convert(data, inBits, outBits, pad) {
            var value = 0
            var bits = 0
            var maxV = (1 << outBits) - 1

            var result = []
            for (var i = 0; i < data.length; ++i) {
              value = (value << inBits) | data[i]
              bits += inBits

              while (bits >= outBits) {
                bits -= outBits
                result.push((value >> bits) & maxV)
              }
            }

            if (pad) {
              if (bits > 0) {
                result.push((value << (outBits - bits)) & maxV)
              }
            } else {
              if (bits >= inBits) return 'Excess padding'
              if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'
            }

            return result
          }

          function toWordsUnsafe(bytes) {
            var res = convert(bytes, 8, 5, true)
            if (Array.isArray(res)) return res
          }

          function toWords(bytes) {
            var res = convert(bytes, 8, 5, true)
            if (Array.isArray(res)) return res

            throw new Error(res)
          }

          function fromWordsUnsafe(words) {
            var res = convert(words, 5, 8, false)
            if (Array.isArray(res)) return res
          }

          function fromWords(words) {
            var res = convert(words, 5, 8, false)
            if (Array.isArray(res)) return res

            throw new Error(res)
          }

          module.exports = {
            decodeUnsafe: decodeUnsafe,
            decode: decode,
            encode: encode,
            toWordsUnsafe: toWordsUnsafe,
            toWords: toWords,
            fromWordsUnsafe: fromWordsUnsafe,
            fromWords: fromWords,
          }
        },
        {},
      ],
      13: [
        function (require, module, exports) {
          ;(function (globalObject) {
            'use strict'

            /*
             *      bignumber.js v9.0.1
             *      A JavaScript library for arbitrary-precision arithmetic.
             *      https://github.com/MikeMcl/bignumber.js
             *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
             *      MIT Licensed.
             *
             *      BigNumber.prototype methods     |  BigNumber methods
             *                                      |
             *      absoluteValue            abs    |  clone
             *      comparedTo                      |  config               set
             *      decimalPlaces            dp     |      DECIMAL_PLACES
             *      dividedBy                div    |      ROUNDING_MODE
             *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
             *      exponentiatedBy          pow    |      RANGE
             *      integerValue                    |      CRYPTO
             *      isEqualTo                eq     |      MODULO_MODE
             *      isFinite                        |      POW_PRECISION
             *      isGreaterThan            gt     |      FORMAT
             *      isGreaterThanOrEqualTo   gte    |      ALPHABET
             *      isInteger                       |  isBigNumber
             *      isLessThan               lt     |  maximum              max
             *      isLessThanOrEqualTo      lte    |  minimum              min
             *      isNaN                           |  random
             *      isNegative                      |  sum
             *      isPositive                      |
             *      isZero                          |
             *      minus                           |
             *      modulo                   mod    |
             *      multipliedBy             times  |
             *      negated                         |
             *      plus                            |
             *      precision                sd     |
             *      shiftedBy                       |
             *      squareRoot               sqrt   |
             *      toExponential                   |
             *      toFixed                         |
             *      toFormat                        |
             *      toFraction                      |
             *      toJSON                          |
             *      toNumber                        |
             *      toPrecision                     |
             *      toString                        |
             *      valueOf                         |
             *
             */

            var BigNumber,
              isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
              mathceil = Math.ceil,
              mathfloor = Math.floor,
              bignumberError = '[BigNumber Error] ',
              tooManyDigits =
                bignumberError +
                'Number primitive has more than 15 significant digits: ',
              BASE = 1e14,
              LOG_BASE = 14,
              MAX_SAFE_INTEGER = 0x1fffffffffffff, // 2^53 - 1
              // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
              POWS_TEN = [
                1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12,
                1e13,
              ],
              SQRT_BASE = 1e7,
              // EDITABLE
              // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
              // the arguments to toExponential, toFixed, toFormat, and toPrecision.
              MAX = 1e9 // 0 to MAX_INT32

            /*
             * Create and return a BigNumber constructor.
             */
            function clone(configObject) {
              var div,
                convertBase,
                parseNumeric,
                P = (BigNumber.prototype = {
                  constructor: BigNumber,
                  toString: null,
                  valueOf: null,
                }),
                ONE = new BigNumber(1),
                //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------

                // The default values below must be integers within the inclusive ranges stated.
                // The values can also be changed at run-time using BigNumber.set.

                // The maximum number of decimal places for operations involving division.
                DECIMAL_PLACES = 20, // 0 to MAX
                // The rounding mode used when rounding to the above decimal places, and when using
                // toExponential, toFixed, toFormat and toPrecision, and round (default value).
                // UP         0 Away from zero.
                // DOWN       1 Towards zero.
                // CEIL       2 Towards +Infinity.
                // FLOOR      3 Towards -Infinity.
                // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
                // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
                // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
                // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
                // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
                ROUNDING_MODE = 4, // 0 to 8
                // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

                // The exponent value at and beneath which toString returns exponential notation.
                // Number type: -7
                TO_EXP_NEG = -7, // 0 to -MAX
                // The exponent value at and above which toString returns exponential notation.
                // Number type: 21
                TO_EXP_POS = 21, // 0 to MAX
                // RANGE : [MIN_EXP, MAX_EXP]

                // The minimum exponent value, beneath which underflow to zero occurs.
                // Number type: -324  (5e-324)
                MIN_EXP = -1e7, // -1 to -MAX
                // The maximum exponent value, above which overflow to Infinity occurs.
                // Number type:  308  (1.7976931348623157e+308)
                // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
                MAX_EXP = 1e7, // 1 to MAX
                // Whether to use cryptographically-secure random number generation, if available.
                CRYPTO = false, // true or false
                // The modulo mode used when calculating the modulus: a mod n.
                // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
                // The remainder (r) is calculated as: r = a - n * q.
                //
                // UP        0 The remainder is positive if the dividend is negative, else is negative.
                // DOWN      1 The remainder has the same sign as the dividend.
                //             This modulo mode is commonly known as 'truncated division' and is
                //             equivalent to (a % n) in JavaScript.
                // FLOOR     3 The remainder has the same sign as the divisor (Python %).
                // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
                // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
                //             The remainder is always positive.
                //
                // The truncated division, floored division, Euclidian division and IEEE 754 remainder
                // modes are commonly used for the modulus operation.
                // Although the other rounding modes can also be used, they may not give useful results.
                MODULO_MODE = 1, // 0 to 9
                // The maximum number of significant digits of the result of the exponentiatedBy operation.
                // If POW_PRECISION is 0, there will be unlimited significant digits.
                POW_PRECISION = 0, // 0 to MAX
                // The format specification used by the BigNumber.prototype.toFormat method.
                FORMAT = {
                  prefix: '',
                  groupSize: 3,
                  secondaryGroupSize: 0,
                  groupSeparator: ',',
                  decimalSeparator: '.',
                  fractionGroupSize: 0,
                  fractionGroupSeparator: '\xA0', // non-breaking space
                  suffix: '',
                },
                // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
                // '-', '.', whitespace, or repeated character.
                // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
                ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz'

              //------------------------------------------------------------------------------------------

              // CONSTRUCTOR

              /*
               * The BigNumber constructor and exported function.
               * Create and return a new instance of a BigNumber object.
               *
               * v {number|string|BigNumber} A numeric value.
               * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
               */
              function BigNumber(v, b) {
                var alphabet,
                  c,
                  caseChanged,
                  e,
                  i,
                  isNum,
                  len,
                  str,
                  x = this

                // Enable constructor call without `new`.
                if (!(x instanceof BigNumber)) return new BigNumber(v, b)

                if (b == null) {
                  if (v && v._isBigNumber === true) {
                    x.s = v.s

                    if (!v.c || v.e > MAX_EXP) {
                      x.c = x.e = null
                    } else if (v.e < MIN_EXP) {
                      x.c = [(x.e = 0)]
                    } else {
                      x.e = v.e
                      x.c = v.c.slice()
                    }

                    return
                  }

                  if ((isNum = typeof v == 'number') && v * 0 == 0) {
                    // Use `1 / n` to handle minus zero also.
                    x.s = 1 / v < 0 ? ((v = -v), -1) : 1

                    // Fast path for integers, where n < 2147483648 (2**31).
                    if (v === ~~v) {
                      for (e = 0, i = v; i >= 10; i /= 10, e++);

                      if (e > MAX_EXP) {
                        x.c = x.e = null
                      } else {
                        x.e = e
                        x.c = [v]
                      }

                      return
                    }

                    str = String(v)
                  } else {
                    if (!isNumeric.test((str = String(v))))
                      return parseNumeric(x, str, isNum)

                    x.s =
                      str.charCodeAt(0) == 45 ? ((str = str.slice(1)), -1) : 1
                  }

                  // Decimal point?
                  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '')

                  // Exponential form?
                  if ((i = str.search(/e/i)) > 0) {
                    // Determine exponent.
                    if (e < 0) e = i
                    e += +str.slice(i + 1)
                    str = str.substring(0, i)
                  } else if (e < 0) {
                    // Integer.
                    e = str.length
                  }
                } else {
                  // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                  intCheck(b, 2, ALPHABET.length, 'Base')

                  // Allow exponential notation to be used with base 10 argument, while
                  // also rounding to DECIMAL_PLACES as with other bases.
                  if (b == 10) {
                    x = new BigNumber(v)
                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE)
                  }

                  str = String(v)

                  if ((isNum = typeof v == 'number')) {
                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                    if (v * 0 != 0) return parseNumeric(x, str, isNum, b)

                    x.s = 1 / v < 0 ? ((str = str.slice(1)), -1) : 1

                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                    if (
                      BigNumber.DEBUG &&
                      str.replace(/^0\.0*|\./, '').length > 15
                    ) {
                      throw Error(tooManyDigits + v)
                    }
                  } else {
                    x.s =
                      str.charCodeAt(0) === 45 ? ((str = str.slice(1)), -1) : 1
                  }

                  alphabet = ALPHABET.slice(0, b)
                  e = i = 0

                  // Check that str is a valid base b number.
                  // Don't use RegExp, so alphabet can contain special characters.
                  for (len = str.length; i < len; i++) {
                    if (alphabet.indexOf((c = str.charAt(i))) < 0) {
                      if (c == '.') {
                        // If '.' is not the first character and it has not be found before.
                        if (i > e) {
                          e = len
                          continue
                        }
                      } else if (!caseChanged) {
                        // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                        if (
                          (str == str.toUpperCase() &&
                            (str = str.toLowerCase())) ||
                          (str == str.toLowerCase() &&
                            (str = str.toUpperCase()))
                        ) {
                          caseChanged = true
                          i = -1
                          e = 0
                          continue
                        }
                      }

                      return parseNumeric(x, String(v), isNum, b)
                    }
                  }

                  // Prevent later check for length on converted number.
                  isNum = false
                  str = convertBase(str, b, 10, x.s)

                  // Decimal point?
                  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '')
                  else e = str.length
                }

                // Determine leading zeros.
                for (i = 0; str.charCodeAt(i) === 48; i++);

                // Determine trailing zeros.
                for (len = str.length; str.charCodeAt(--len) === 48; );

                if ((str = str.slice(i, ++len))) {
                  len -= i

                  // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                  if (
                    isNum &&
                    BigNumber.DEBUG &&
                    len > 15 &&
                    (v > MAX_SAFE_INTEGER || v !== mathfloor(v))
                  ) {
                    throw Error(tooManyDigits + x.s * v)
                  }

                  // Overflow?
                  if ((e = e - i - 1) > MAX_EXP) {
                    // Infinity.
                    x.c = x.e = null

                    // Underflow?
                  } else if (e < MIN_EXP) {
                    // Zero.
                    x.c = [(x.e = 0)]
                  } else {
                    x.e = e
                    x.c = []

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = (e + 1) % LOG_BASE
                    if (e < 0) i += LOG_BASE // i < 1

                    if (i < len) {
                      if (i) x.c.push(+str.slice(0, i))

                      for (len -= LOG_BASE; i < len; ) {
                        x.c.push(+str.slice(i, (i += LOG_BASE)))
                      }

                      i = LOG_BASE - (str = str.slice(i)).length
                    } else {
                      i -= len
                    }

                    for (; i--; str += '0');
                    x.c.push(+str)
                  }
                } else {
                  // Zero.
                  x.c = [(x.e = 0)]
                }
              }

              // CONSTRUCTOR PROPERTIES

              BigNumber.clone = clone

              BigNumber.ROUND_UP = 0
              BigNumber.ROUND_DOWN = 1
              BigNumber.ROUND_CEIL = 2
              BigNumber.ROUND_FLOOR = 3
              BigNumber.ROUND_HALF_UP = 4
              BigNumber.ROUND_HALF_DOWN = 5
              BigNumber.ROUND_HALF_EVEN = 6
              BigNumber.ROUND_HALF_CEIL = 7
              BigNumber.ROUND_HALF_FLOOR = 8
              BigNumber.EUCLID = 9

              /*
               * Configure infrequently-changing library-wide settings.
               *
               * Accept an object with the following optional properties (if the value of a property is
               * a number, it must be an integer within the inclusive range stated):
               *
               *   DECIMAL_PLACES   {number}           0 to MAX
               *   ROUNDING_MODE    {number}           0 to 8
               *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
               *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
               *   CRYPTO           {boolean}          true or false
               *   MODULO_MODE      {number}           0 to 9
               *   POW_PRECISION       {number}           0 to MAX
               *   ALPHABET         {string}           A string of two or more unique characters which does
               *                                       not contain '.'.
               *   FORMAT           {object}           An object with some of the following properties:
               *     prefix                 {string}
               *     groupSize              {number}
               *     secondaryGroupSize     {number}
               *     groupSeparator         {string}
               *     decimalSeparator       {string}
               *     fractionGroupSize      {number}
               *     fractionGroupSeparator {string}
               *     suffix                 {string}
               *
               * (The values assigned to the above FORMAT object properties are not checked for validity.)
               *
               * E.g.
               * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
               *
               * Ignore properties/parameters set to null or undefined, except for ALPHABET.
               *
               * Return an object with the properties current values.
               */
              BigNumber.config = BigNumber.set = function (obj) {
                var p, v

                if (obj != null) {
                  if (typeof obj == 'object') {
                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty((p = 'DECIMAL_PLACES'))) {
                      v = obj[p]
                      intCheck(v, 0, MAX, p)
                      DECIMAL_PLACES = v
                    }

                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty((p = 'ROUNDING_MODE'))) {
                      v = obj[p]
                      intCheck(v, 0, 8, p)
                      ROUNDING_MODE = v
                    }

                    // EXPONENTIAL_AT {number|number[]}
                    // Integer, -MAX to MAX inclusive or
                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty((p = 'EXPONENTIAL_AT'))) {
                      v = obj[p]
                      if (v && v.pop) {
                        intCheck(v[0], -MAX, 0, p)
                        intCheck(v[1], 0, MAX, p)
                        TO_EXP_NEG = v[0]
                        TO_EXP_POS = v[1]
                      } else {
                        intCheck(v, -MAX, MAX, p)
                        TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v)
                      }
                    }

                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                    if (obj.hasOwnProperty((p = 'RANGE'))) {
                      v = obj[p]
                      if (v && v.pop) {
                        intCheck(v[0], -MAX, -1, p)
                        intCheck(v[1], 1, MAX, p)
                        MIN_EXP = v[0]
                        MAX_EXP = v[1]
                      } else {
                        intCheck(v, -MAX, MAX, p)
                        if (v) {
                          MIN_EXP = -(MAX_EXP = v < 0 ? -v : v)
                        } else {
                          throw Error(
                            bignumberError + p + ' cannot be zero: ' + v
                          )
                        }
                      }
                    }

                    // CRYPTO {boolean} true or false.
                    // '[BigNumber Error] CRYPTO not true or false: {v}'
                    // '[BigNumber Error] crypto unavailable'
                    if (obj.hasOwnProperty((p = 'CRYPTO'))) {
                      v = obj[p]
                      if (v === !!v) {
                        if (v) {
                          if (
                            typeof crypto != 'undefined' &&
                            crypto &&
                            (crypto.getRandomValues || crypto.randomBytes)
                          ) {
                            CRYPTO = v
                          } else {
                            CRYPTO = !v
                            throw Error(bignumberError + 'crypto unavailable')
                          }
                        } else {
                          CRYPTO = v
                        }
                      } else {
                        throw Error(
                          bignumberError + p + ' not true or false: ' + v
                        )
                      }
                    }

                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty((p = 'MODULO_MODE'))) {
                      v = obj[p]
                      intCheck(v, 0, 9, p)
                      MODULO_MODE = v
                    }

                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty((p = 'POW_PRECISION'))) {
                      v = obj[p]
                      intCheck(v, 0, MAX, p)
                      POW_PRECISION = v
                    }

                    // FORMAT {object}
                    // '[BigNumber Error] FORMAT not an object: {v}'
                    if (obj.hasOwnProperty((p = 'FORMAT'))) {
                      v = obj[p]
                      if (typeof v == 'object') FORMAT = v
                      else
                        throw Error(bignumberError + p + ' not an object: ' + v)
                    }

                    // ALPHABET {string}
                    // '[BigNumber Error] ALPHABET invalid: {v}'
                    if (obj.hasOwnProperty((p = 'ALPHABET'))) {
                      v = obj[p]

                      // Disallow if less than two characters,
                      // or if it contains '+', '-', '.', whitespace, or a repeated character.
                      if (
                        typeof v == 'string' &&
                        !/^.?$|[+\-.\s]|(.).*\1/.test(v)
                      ) {
                        ALPHABET = v
                      } else {
                        throw Error(bignumberError + p + ' invalid: ' + v)
                      }
                    }
                  } else {
                    // '[BigNumber Error] Object expected: {v}'
                    throw Error(bignumberError + 'Object expected: ' + obj)
                  }
                }

                return {
                  DECIMAL_PLACES: DECIMAL_PLACES,
                  ROUNDING_MODE: ROUNDING_MODE,
                  EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
                  RANGE: [MIN_EXP, MAX_EXP],
                  CRYPTO: CRYPTO,
                  MODULO_MODE: MODULO_MODE,
                  POW_PRECISION: POW_PRECISION,
                  FORMAT: FORMAT,
                  ALPHABET: ALPHABET,
                }
              }

              /*
               * Return true if v is a BigNumber instance, otherwise return false.
               *
               * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
               *
               * v {any}
               *
               * '[BigNumber Error] Invalid BigNumber: {v}'
               */
              BigNumber.isBigNumber = function (v) {
                if (!v || v._isBigNumber !== true) return false
                if (!BigNumber.DEBUG) return true

                var i,
                  n,
                  c = v.c,
                  e = v.e,
                  s = v.s

                out: if ({}.toString.call(c) == '[object Array]') {
                  if (
                    (s === 1 || s === -1) &&
                    e >= -MAX &&
                    e <= MAX &&
                    e === mathfloor(e)
                  ) {
                    // If the first element is zero, the BigNumber value must be zero.
                    if (c[0] === 0) {
                      if (e === 0 && c.length === 1) return true
                      break out
                    }

                    // Calculate number of digits that c[0] should have, based on the exponent.
                    i = (e + 1) % LOG_BASE
                    if (i < 1) i += LOG_BASE

                    // Calculate number of digits of c[0].
                    //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                    if (String(c[0]).length == i) {
                      for (i = 0; i < c.length; i++) {
                        n = c[i]
                        if (n < 0 || n >= BASE || n !== mathfloor(n)) break out
                      }

                      // Last element cannot be zero, unless it is the only element.
                      if (n !== 0) return true
                    }
                  }

                  // Infinity/NaN
                } else if (
                  c === null &&
                  e === null &&
                  (s === null || s === 1 || s === -1)
                ) {
                  return true
                }

                throw Error(bignumberError + 'Invalid BigNumber: ' + v)
              }

              /*
               * Return a new BigNumber whose value is the maximum of the arguments.
               *
               * arguments {number|string|BigNumber}
               */
              BigNumber.maximum = BigNumber.max = function () {
                return maxOrMin(arguments, P.lt)
              }

              /*
               * Return a new BigNumber whose value is the minimum of the arguments.
               *
               * arguments {number|string|BigNumber}
               */
              BigNumber.minimum = BigNumber.min = function () {
                return maxOrMin(arguments, P.gt)
              }

              /*
               * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
               * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
               * zeros are produced).
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
               * '[BigNumber Error] crypto unavailable'
               */
              BigNumber.random = (function () {
                var pow2_53 = 0x20000000000000

                // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
                // Check if Math.random() produces more than 32 bits of randomness.
                // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
                // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
                var random53bitInt =
                  (Math.random() * pow2_53) & 0x1fffff
                    ? function () {
                        return mathfloor(Math.random() * pow2_53)
                      }
                    : function () {
                        return (
                          ((Math.random() * 0x40000000) | 0) * 0x800000 +
                          ((Math.random() * 0x800000) | 0)
                        )
                      }

                return function (dp) {
                  var a,
                    b,
                    e,
                    k,
                    v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE)

                  if (dp == null) dp = DECIMAL_PLACES
                  else intCheck(dp, 0, MAX)

                  k = mathceil(dp / LOG_BASE)

                  if (CRYPTO) {
                    // Browsers supporting crypto.getRandomValues.
                    if (crypto.getRandomValues) {
                      a = crypto.getRandomValues(new Uint32Array((k *= 2)))

                      for (; i < k; ) {
                        // 53 bits:
                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                        //                                     11111 11111111 11111111
                        // 0x20000 is 2^21.
                        v = a[i] * 0x20000 + (a[i + 1] >>> 11)

                        // Rejection sampling:
                        // 0 <= v < 9007199254740992
                        // Probability that v >= 9e15, is
                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                        if (v >= 9e15) {
                          b = crypto.getRandomValues(new Uint32Array(2))
                          a[i] = b[0]
                          a[i + 1] = b[1]
                        } else {
                          // 0 <= v <= 8999999999999999
                          // 0 <= (v % 1e14) <= 99999999999999
                          c.push(v % 1e14)
                          i += 2
                        }
                      }
                      i = k / 2

                      // Node.js supporting crypto.randomBytes.
                    } else if (crypto.randomBytes) {
                      // buffer
                      a = crypto.randomBytes((k *= 7))

                      for (; i < k; ) {
                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                        // 0x100000000 is 2^32, 0x1000000 is 2^24
                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                        // 0 <= v < 9007199254740992
                        v =
                          (a[i] & 31) * 0x1000000000000 +
                          a[i + 1] * 0x10000000000 +
                          a[i + 2] * 0x100000000 +
                          a[i + 3] * 0x1000000 +
                          (a[i + 4] << 16) +
                          (a[i + 5] << 8) +
                          a[i + 6]

                        if (v >= 9e15) {
                          crypto.randomBytes(7).copy(a, i)
                        } else {
                          // 0 <= (v % 1e14) <= 99999999999999
                          c.push(v % 1e14)
                          i += 7
                        }
                      }
                      i = k / 7
                    } else {
                      CRYPTO = false
                      throw Error(bignumberError + 'crypto unavailable')
                    }
                  }

                  // Use Math.random.
                  if (!CRYPTO) {
                    for (; i < k; ) {
                      v = random53bitInt()
                      if (v < 9e15) c[i++] = v % 1e14
                    }
                  }

                  k = c[--i]
                  dp %= LOG_BASE

                  // Convert trailing digits to zeros according to dp.
                  if (k && dp) {
                    v = POWS_TEN[LOG_BASE - dp]
                    c[i] = mathfloor(k / v) * v
                  }

                  // Remove trailing elements which are zero.
                  for (; c[i] === 0; c.pop(), i--);

                  // Zero?
                  if (i < 0) {
                    c = [(e = 0)]
                  } else {
                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if (i < LOG_BASE) e -= LOG_BASE - i
                  }

                  rand.e = e
                  rand.c = c
                  return rand
                }
              })()

              /*
               * Return a BigNumber whose value is the sum of the arguments.
               *
               * arguments {number|string|BigNumber}
               */
              BigNumber.sum = function () {
                var i = 1,
                  args = arguments,
                  sum = new BigNumber(args[0])
                for (; i < args.length; ) sum = sum.plus(args[i++])
                return sum
              }

              // PRIVATE FUNCTIONS

              // Called by BigNumber and BigNumber.prototype.toString.
              convertBase = (function () {
                var decimal = '0123456789'

                /*
                 * Convert string of baseIn to an array of numbers of baseOut.
                 * Eg. toBaseOut('255', 10, 16) returns [15, 15].
                 * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
                 */
                function toBaseOut(str, baseIn, baseOut, alphabet) {
                  var j,
                    arr = [0],
                    arrL,
                    i = 0,
                    len = str.length

                  for (; i < len; ) {
                    for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

                    arr[0] += alphabet.indexOf(str.charAt(i++))

                    for (j = 0; j < arr.length; j++) {
                      if (arr[j] > baseOut - 1) {
                        if (arr[j + 1] == null) arr[j + 1] = 0
                        arr[j + 1] += (arr[j] / baseOut) | 0
                        arr[j] %= baseOut
                      }
                    }
                  }

                  return arr.reverse()
                }

                // Convert a numeric string of baseIn to a numeric string of baseOut.
                // If the caller is toString, we are converting from base 10 to baseOut.
                // If the caller is BigNumber, we are converting from baseIn to base 10.
                return function (str, baseIn, baseOut, sign, callerIsToString) {
                  var alphabet,
                    d,
                    e,
                    k,
                    r,
                    x,
                    xc,
                    y,
                    i = str.indexOf('.'),
                    dp = DECIMAL_PLACES,
                    rm = ROUNDING_MODE

                  // Non-integer.
                  if (i >= 0) {
                    k = POW_PRECISION

                    // Unlimited precision.
                    POW_PRECISION = 0
                    str = str.replace('.', '')
                    y = new BigNumber(baseIn)
                    x = y.pow(str.length - i)
                    POW_PRECISION = k

                    // Convert str as if an integer, then restore the fraction part by dividing the
                    // result by its base raised to a power.

                    y.c = toBaseOut(
                      toFixedPoint(coeffToString(x.c), x.e, '0'),
                      10,
                      baseOut,
                      decimal
                    )
                    y.e = y.c.length
                  }

                  // Convert the number as integer.

                  xc = toBaseOut(
                    str,
                    baseIn,
                    baseOut,
                    callerIsToString
                      ? ((alphabet = ALPHABET), decimal)
                      : ((alphabet = decimal), ALPHABET)
                  )

                  // xc now represents str as an integer and converted to baseOut. e is the exponent.
                  e = k = xc.length

                  // Remove trailing zeros.
                  for (; xc[--k] == 0; xc.pop());

                  // Zero?
                  if (!xc[0]) return alphabet.charAt(0)

                  // Does str represent an integer? If so, no need for the division.
                  if (i < 0) {
                    --e
                  } else {
                    x.c = xc
                    x.e = e

                    // The sign is needed for correct rounding.
                    x.s = sign
                    x = div(x, y, dp, rm, baseOut)
                    xc = x.c
                    r = x.r
                    e = x.e
                  }

                  // xc now represents str converted to baseOut.

                  // THe index of the rounding digit.
                  d = e + dp + 1

                  // The rounding digit: the digit to the right of the digit that may be rounded up.
                  i = xc[d]

                  // Look at the rounding digits and mode to determine whether to round up.

                  k = baseOut / 2
                  r = r || d < 0 || xc[d + 1] != null

                  r =
                    rm < 4
                      ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                      : i > k ||
                        (i == k &&
                          (rm == 4 ||
                            r ||
                            (rm == 6 && xc[d - 1] & 1) ||
                            rm == (x.s < 0 ? 8 : 7)))

                  // If the index of the rounding digit is not greater than zero, or xc represents
                  // zero, then the result of the base conversion is zero or, if rounding up, a value
                  // such as 0.00001.
                  if (d < 1 || !xc[0]) {
                    // 1^-dp or 0
                    str = r
                      ? toFixedPoint(
                          alphabet.charAt(1),
                          -dp,
                          alphabet.charAt(0)
                        )
                      : alphabet.charAt(0)
                  } else {
                    // Truncate xc to the required number of decimal places.
                    xc.length = d

                    // Round up?
                    if (r) {
                      // Rounding up may mean the previous digit has to be rounded up and so on.
                      for (--baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0

                        if (!d) {
                          ++e
                          xc = [1].concat(xc)
                        }
                      }
                    }

                    // Determine trailing zeros.
                    for (k = xc.length; !xc[--k]; );

                    // E.g. [4, 11, 15] becomes 4bf.
                    for (
                      i = 0, str = '';
                      i <= k;
                      str += alphabet.charAt(xc[i++])
                    );

                    // Add leading zeros, decimal point and trailing zeros as required.
                    str = toFixedPoint(str, e, alphabet.charAt(0))
                  }

                  // The caller will add the sign.
                  return str
                }
              })()

              // Perform division in the specified base. Called by div and convertBase.
              div = (function () {
                // Assume non-zero x and k.
                function multiply(x, k, base) {
                  var m,
                    temp,
                    xlo,
                    xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = (k / SQRT_BASE) | 0

                  for (x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE
                    xhi = (x[i] / SQRT_BASE) | 0
                    m = khi * xlo + xhi * klo
                    temp = klo * xlo + (m % SQRT_BASE) * SQRT_BASE + carry
                    carry =
                      ((temp / base) | 0) + ((m / SQRT_BASE) | 0) + khi * xhi
                    x[i] = temp % base
                  }

                  if (carry) x = [carry].concat(x)

                  return x
                }

                function compare(a, b, aL, bL) {
                  var i, cmp

                  if (aL != bL) {
                    cmp = aL > bL ? 1 : -1
                  } else {
                    for (i = cmp = 0; i < aL; i++) {
                      if (a[i] != b[i]) {
                        cmp = a[i] > b[i] ? 1 : -1
                        break
                      }
                    }
                  }

                  return cmp
                }

                function subtract(a, b, aL, base) {
                  var i = 0

                  // Subtract b from a.
                  for (; aL--; ) {
                    a[aL] -= i
                    i = a[aL] < b[aL] ? 1 : 0
                    a[aL] = i * base + a[aL] - b[aL]
                  }

                  // Remove leading zeros.
                  for (; !a[0] && a.length > 1; a.splice(0, 1));
                }

                // x: dividend, y: divisor.
                return function (x, y, dp, rm, base) {
                  var cmp,
                    e,
                    i,
                    more,
                    n,
                    prod,
                    prodL,
                    q,
                    qc,
                    rem,
                    remL,
                    rem0,
                    xi,
                    xL,
                    yc0,
                    yL,
                    yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c

                  // Either NaN, Infinity or 0?
                  if (!xc || !xc[0] || !yc || !yc[0]) {
                    return new BigNumber(
                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc)
                        ? NaN
                        : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                        (xc && xc[0] == 0) || !yc
                        ? s * 0
                        : s / 0
                    )
                  }

                  q = new BigNumber(s)
                  qc = q.c = []
                  e = x.e - y.e
                  s = dp + e + 1

                  if (!base) {
                    base = BASE
                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE)
                    s = (s / LOG_BASE) | 0
                  }

                  // Result exponent may be one less then the current value of e.
                  // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                  for (i = 0; yc[i] == (xc[i] || 0); i++);

                  if (yc[i] > (xc[i] || 0)) e--

                  if (s < 0) {
                    qc.push(1)
                    more = true
                  } else {
                    xL = xc.length
                    yL = yc.length
                    i = 0
                    s += 2

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor(base / (yc[0] + 1))

                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                    if (n > 1) {
                      yc = multiply(yc, n, base)
                      xc = multiply(xc, n, base)
                      yL = yc.length
                      xL = xc.length
                    }

                    xi = yL
                    rem = xc.slice(0, yL)
                    remL = rem.length

                    // Add zeros to make remainder as long as divisor.
                    for (; remL < yL; rem[remL++] = 0);
                    yz = yc.slice()
                    yz = [0].concat(yz)
                    yc0 = yc[0]
                    if (yc[1] >= base / 2) yc0++
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

                    do {
                      n = 0

                      // Compare divisor and remainder.
                      cmp = compare(yc, rem, yL, remL)

                      // If divisor < remainder.
                      if (cmp < 0) {
                        // Calculate trial digit, n.

                        rem0 = rem[0]
                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0)

                        // n is how many times the divisor goes into the current remainder.
                        n = mathfloor(rem0 / yc0)

                        //  Algorithm:
                        //  product = divisor multiplied by trial digit (n).
                        //  Compare product and remainder.
                        //  If product is greater than remainder:
                        //    Subtract divisor from product, decrement trial digit.
                        //  Subtract product from remainder.
                        //  If product was less than remainder at the last compare:
                        //    Compare new remainder and divisor.
                        //    If remainder is greater than divisor:
                        //      Subtract divisor from remainder, increment trial digit.

                        if (n > 1) {
                          // n may be > base only when base is 3.
                          if (n >= base) n = base - 1

                          // product = divisor * trial digit.
                          prod = multiply(yc, n, base)
                          prodL = prod.length
                          remL = rem.length

                          // Compare product and remainder.
                          // If product > remainder then trial digit n too high.
                          // n is 1 too high about 5% of the time, and is not known to have
                          // ever been more than 1 too high.
                          while (compare(prod, rem, prodL, remL) == 1) {
                            n--

                            // Subtract divisor from product.
                            subtract(prod, yL < prodL ? yz : yc, prodL, base)
                            prodL = prod.length
                            cmp = 1
                          }
                        } else {
                          // n is 0 or 1, cmp is -1.
                          // If n is 0, there is no need to compare yc and rem again below,
                          // so change cmp to 1 to avoid it.
                          // If n is 1, leave cmp as -1, so yc and rem are compared again.
                          if (n == 0) {
                            // divisor < remainder, so n must be at least 1.
                            cmp = n = 1
                          }

                          // product = divisor
                          prod = yc.slice()
                          prodL = prod.length
                        }

                        if (prodL < remL) prod = [0].concat(prod)

                        // Subtract product from remainder.
                        subtract(rem, prod, remL, base)
                        remL = rem.length

                        // If product was < remainder.
                        if (cmp == -1) {
                          // Compare divisor and new remainder.
                          // If divisor < new remainder, subtract divisor from remainder.
                          // Trial digit n too low.
                          // n is 1 too low about 5% of the time, and very rarely 2 too low.
                          while (compare(yc, rem, yL, remL) < 1) {
                            n++

                            // Subtract divisor from remainder.
                            subtract(rem, yL < remL ? yz : yc, remL, base)
                            remL = rem.length
                          }
                        }
                      } else if (cmp === 0) {
                        n++
                        rem = [0]
                      } // else cmp === 1 and n will be 0

                      // Add the next digit, n, to the result array.
                      qc[i++] = n

                      // Update the remainder.
                      if (rem[0]) {
                        rem[remL++] = xc[xi] || 0
                      } else {
                        rem = [xc[xi]]
                        remL = 1
                      }
                    } while ((xi++ < xL || rem[0] != null) && s--)

                    more = rem[0] != null

                    // Leading zero?
                    if (!qc[0]) qc.splice(0, 1)
                  }

                  if (base == BASE) {
                    // To calculate q.e, first get the number of digits of qc[0].
                    for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more)

                    // Caller is convertBase.
                  } else {
                    q.e = e
                    q.r = +more
                  }

                  return q
                }
              })()

              /*
               * Return a string representing the value of BigNumber n in fixed-point or exponential
               * notation rounded to the specified decimal places or significant digits.
               *
               * n: a BigNumber.
               * i: the index of the last digit required (i.e. the digit that may be rounded up).
               * rm: the rounding mode.
               * id: 1 (toExponential) or 2 (toPrecision).
               */
              function format(n, i, rm, id) {
                var c0, e, ne, len, str

                if (rm == null) rm = ROUNDING_MODE
                else intCheck(rm, 0, 8)

                if (!n.c) return n.toString()

                c0 = n.c[0]
                ne = n.e

                if (i == null) {
                  str = coeffToString(n.c)
                  str =
                    id == 1 ||
                    (id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS))
                      ? toExponential(str, ne)
                      : toFixedPoint(str, ne, '0')
                } else {
                  n = round(new BigNumber(n), i, rm)

                  // n.e may have changed if the value was rounded up.
                  e = n.e

                  str = coeffToString(n.c)
                  len = str.length

                  // toPrecision returns exponential notation if the number of significant digits
                  // specified is less than the number of digits necessary to represent the integer
                  // part of the value in fixed-point notation.

                  // Exponential notation.
                  if (id == 1 || (id == 2 && (i <= e || e <= TO_EXP_NEG))) {
                    // Append zeros?
                    for (; len < i; str += '0', len++);
                    str = toExponential(str, e)

                    // Fixed-point notation.
                  } else {
                    i -= ne
                    str = toFixedPoint(str, e, '0')

                    // Append zeros?
                    if (e + 1 > len) {
                      if (--i > 0) for (str += '.'; i--; str += '0');
                    } else {
                      i += e - len
                      if (i > 0) {
                        if (e + 1 == len) str += '.'
                        for (; i--; str += '0');
                      }
                    }
                  }
                }

                return n.s < 0 && c0 ? '-' + str : str
              }

              // Handle BigNumber.max and BigNumber.min.
              function maxOrMin(args, method) {
                var n,
                  i = 1,
                  m = new BigNumber(args[0])

                for (; i < args.length; i++) {
                  n = new BigNumber(args[i])

                  // If any number is NaN, return NaN.
                  if (!n.s) {
                    m = n
                    break
                  } else if (method.call(m, n)) {
                    m = n
                  }
                }

                return m
              }

              /*
               * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
               * Called by minus, plus and times.
               */
              function normalise(n, c, e) {
                var i = 1,
                  j = c.length

                // Remove trailing zeros.
                for (; !c[--j]; c.pop());

                // Calculate the base 10 exponent. First get the number of digits of c[0].
                for (j = c[0]; j >= 10; j /= 10, i++);

                // Overflow?
                if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
                  // Infinity.
                  n.c = n.e = null

                  // Underflow?
                } else if (e < MIN_EXP) {
                  // Zero.
                  n.c = [(n.e = 0)]
                } else {
                  n.e = e
                  n.c = c
                }

                return n
              }

              // Handle values that fail the validity test in BigNumber.
              parseNumeric = (function () {
                var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                  dotAfter = /^([^.]+)\.$/,
                  dotBefore = /^\.([^.]+)$/,
                  isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                  whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g

                return function (x, str, isNum, b) {
                  var base,
                    s = isNum ? str : str.replace(whitespaceOrPlus, '')

                  // No exception on ±Infinity or NaN.
                  if (isInfinityOrNaN.test(s)) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1
                  } else {
                    if (!isNum) {
                      // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                      s = s.replace(basePrefix, function (m, p1, p2) {
                        base =
                          (p2 = p2.toLowerCase()) == 'x'
                            ? 16
                            : p2 == 'b'
                            ? 2
                            : 8
                        return !b || b == base ? p1 : m
                      })

                      if (b) {
                        base = b

                        // E.g. '1.' to '1', '.1' to '0.1'
                        s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1')
                      }

                      if (str != s) return new BigNumber(s, base)
                    }

                    // '[BigNumber Error] Not a number: {n}'
                    // '[BigNumber Error] Not a base {b} number: {n}'
                    if (BigNumber.DEBUG) {
                      throw Error(
                        bignumberError +
                          'Not a' +
                          (b ? ' base ' + b : '') +
                          ' number: ' +
                          str
                      )
                    }

                    // NaN
                    x.s = null
                  }

                  x.c = x.e = null
                }
              })()

              /*
               * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
               * If r is truthy, it is known that there are more digits after the rounding digit.
               */
              function round(x, sd, rm, r) {
                var d,
                  i,
                  j,
                  k,
                  n,
                  ni,
                  rd,
                  xc = x.c,
                  pows10 = POWS_TEN

                // if x is not Infinity or NaN...
                if (xc) {
                  // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                  // n is a base 1e14 number, the value of the element of array x.c containing rd.
                  // ni is the index of n within x.c.
                  // d is the number of digits of n.
                  // i is the index of rd within n including leading zeros.
                  // j is the actual index of rd within n (if < 0, rd is a leading zero).
                  out: {
                    // Get the number of digits of the first element of xc.
                    for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                    i = sd - d

                    // If the rounding digit is in the first element of xc...
                    if (i < 0) {
                      i += LOG_BASE
                      j = sd
                      n = xc[(ni = 0)]

                      // Get the rounding digit at index j of n.
                      rd = (n / pows10[d - j - 1]) % 10 | 0
                    } else {
                      ni = mathceil((i + 1) / LOG_BASE)

                      if (ni >= xc.length) {
                        if (r) {
                          // Needed by sqrt.
                          for (; xc.length <= ni; xc.push(0));
                          n = rd = 0
                          d = 1
                          i %= LOG_BASE
                          j = i - LOG_BASE + 1
                        } else {
                          break out
                        }
                      } else {
                        n = k = xc[ni]

                        // Get the number of digits of n.
                        for (d = 1; k >= 10; k /= 10, d++);

                        // Get the index of rd within n.
                        i %= LOG_BASE

                        // Get the index of rd within n, adjusted for leading zeros.
                        // The number of leading zeros of n is given by LOG_BASE - d.
                        j = i - LOG_BASE + d

                        // Get the rounding digit at index j of n.
                        rd = j < 0 ? 0 : (n / pows10[d - j - 1]) % 10 | 0
                      }
                    }

                    r =
                      r ||
                      sd < 0 ||
                      // Are there any non-zero digits after the rounding digit?
                      // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                      // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null ||
                      (j < 0 ? n : n % pows10[d - j - 1])

                    r =
                      rm < 4
                        ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                        : rd > 5 ||
                          (rd == 5 &&
                            (rm == 4 ||
                              r ||
                              (rm == 6 &&
                                // Check whether the digit to the left of the rounding digit is odd.
                                (i > 0
                                  ? j > 0
                                    ? n / pows10[d - j]
                                    : 0
                                  : xc[ni - 1]) %
                                  10 &
                                  1) ||
                              rm == (x.s < 0 ? 8 : 7)))

                    if (sd < 1 || !xc[0]) {
                      xc.length = 0

                      if (r) {
                        // Convert sd to decimal places.
                        sd -= x.e + 1

                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                        xc[0] = pows10[(LOG_BASE - (sd % LOG_BASE)) % LOG_BASE]
                        x.e = -sd || 0
                      } else {
                        // Zero.
                        xc[0] = x.e = 0
                      }

                      return x
                    }

                    // Remove excess digits.
                    if (i == 0) {
                      xc.length = ni
                      k = 1
                      ni--
                    } else {
                      xc.length = ni + 1
                      k = pows10[LOG_BASE - i]

                      // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                      // j > 0 means i > number of leading zeros of n.
                      xc[ni] =
                        j > 0
                          ? mathfloor((n / pows10[d - j]) % pows10[j]) * k
                          : 0
                    }

                    // Round up?
                    if (r) {
                      for (;;) {
                        // If the digit to be rounded up is in the first element of xc...
                        if (ni == 0) {
                          // i will be the length of xc[0] before k is added.
                          for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                          j = xc[0] += k
                          for (k = 1; j >= 10; j /= 10, k++);

                          // if i != k the length has increased.
                          if (i != k) {
                            x.e++
                            if (xc[0] == BASE) xc[0] = 1
                          }

                          break
                        } else {
                          xc[ni] += k
                          if (xc[ni] != BASE) break
                          xc[ni--] = 0
                          k = 1
                        }
                      }
                    }

                    // Remove trailing zeros.
                    for (i = xc.length; xc[--i] === 0; xc.pop());
                  }

                  // Overflow? Infinity.
                  if (x.e > MAX_EXP) {
                    x.c = x.e = null

                    // Underflow? Zero.
                  } else if (x.e < MIN_EXP) {
                    x.c = [(x.e = 0)]
                  }
                }

                return x
              }

              function valueOf(n) {
                var str,
                  e = n.e

                if (e === null) return n.toString()

                str = coeffToString(n.c)

                str =
                  e <= TO_EXP_NEG || e >= TO_EXP_POS
                    ? toExponential(str, e)
                    : toFixedPoint(str, e, '0')

                return n.s < 0 ? '-' + str : str
              }

              // PROTOTYPE/INSTANCE METHODS

              /*
               * Return a new BigNumber whose value is the absolute value of this BigNumber.
               */
              P.absoluteValue = P.abs = function () {
                var x = new BigNumber(this)
                if (x.s < 0) x.s = 1
                return x
              }

              /*
               * Return
               *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
               *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
               *   0 if they have the same value,
               *   or null if the value of either is NaN.
               */
              P.comparedTo = function (y, b) {
                return compare(this, new BigNumber(y, b))
              }

              /*
               * If dp is undefined or null or true or false, return the number of decimal places of the
               * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
               *
               * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
               * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
               * ROUNDING_MODE if rm is omitted.
               *
               * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
               */
              P.decimalPlaces = P.dp = function (dp, rm) {
                var c,
                  n,
                  v,
                  x = this

                if (dp != null) {
                  intCheck(dp, 0, MAX)
                  if (rm == null) rm = ROUNDING_MODE
                  else intCheck(rm, 0, 8)

                  return round(new BigNumber(x), dp + x.e + 1, rm)
                }

                if (!(c = x.c)) return null
                n =
                  ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE

                // Subtract the number of trailing zeros of the last number.
                if ((v = c[v])) for (; v % 10 == 0; v /= 10, n--);
                if (n < 0) n = 0

                return n
              }

              /*
               *  n / 0 = I
               *  n / N = N
               *  n / I = 0
               *  0 / n = 0
               *  0 / 0 = N
               *  0 / N = N
               *  0 / I = 0
               *  N / n = N
               *  N / 0 = N
               *  N / N = N
               *  N / I = N
               *  I / n = I
               *  I / 0 = I
               *  I / N = N
               *  I / I = N
               *
               * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
               * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
               */
              P.dividedBy = P.div = function (y, b) {
                return div(
                  this,
                  new BigNumber(y, b),
                  DECIMAL_PLACES,
                  ROUNDING_MODE
                )
              }

              /*
               * Return a new BigNumber whose value is the integer part of dividing the value of this
               * BigNumber by the value of BigNumber(y, b).
               */
              P.dividedToIntegerBy = P.idiv = function (y, b) {
                return div(this, new BigNumber(y, b), 0, 1)
              }

              /*
               * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
               *
               * If m is present, return the result modulo m.
               * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
               * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
               *
               * The modular power operation works efficiently when x, n, and m are integers, otherwise it
               * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
               *
               * n {number|string|BigNumber} The exponent. An integer.
               * [m] {number|string|BigNumber} The modulus.
               *
               * '[BigNumber Error] Exponent not an integer: {n}'
               */
              P.exponentiatedBy = P.pow = function (n, m) {
                var half,
                  isModExp,
                  i,
                  k,
                  more,
                  nIsBig,
                  nIsNeg,
                  nIsOdd,
                  y,
                  x = this

                n = new BigNumber(n)

                // Allow NaN and ±Infinity, but not other non-integers.
                if (n.c && !n.isInteger()) {
                  throw Error(
                    bignumberError + 'Exponent not an integer: ' + valueOf(n)
                  )
                }

                if (m != null) m = new BigNumber(m)

                // Exponent of MAX_SAFE_INTEGER is 15.
                nIsBig = n.e > 14

                // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
                if (
                  !x.c ||
                  !x.c[0] ||
                  (x.c[0] == 1 && !x.e && x.c.length == 1) ||
                  !n.c ||
                  !n.c[0]
                ) {
                  // The sign of the result of pow when x is negative depends on the evenness of n.
                  // If +n overflows to ±Infinity, the evenness of n would be not be known.
                  y = new BigNumber(
                    Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n))
                  )
                  return m ? y.mod(m) : y
                }

                nIsNeg = n.s < 0

                if (m) {
                  // x % m returns NaN if abs(m) is zero, or m is NaN.
                  if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN)

                  isModExp = !nIsNeg && x.isInteger() && m.isInteger()

                  if (isModExp) x = x.mod(m)

                  // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
                  // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
                } else if (
                  n.e > 9 &&
                  (x.e > 0 ||
                    x.e < -1 ||
                    (x.e == 0
                      ? // [1, 240000000]
                        x.c[0] > 1 || (nIsBig && x.c[1] >= 24e7)
                      : // [80000000000000]  [99999750000000]
                        x.c[0] < 8e13 || (nIsBig && x.c[0] <= 9999975e7)))
                ) {
                  // If x is negative and n is odd, k = -0, else k = 0.
                  k = x.s < 0 && isOdd(n) ? -0 : 0

                  // If x >= 1, k = ±Infinity.
                  if (x.e > -1) k = 1 / k

                  // If n is negative return ±0, else return ±Infinity.
                  return new BigNumber(nIsNeg ? 1 / k : k)
                } else if (POW_PRECISION) {
                  // Truncating each coefficient array to a length of k after each multiplication
                  // equates to truncating significant digits to POW_PRECISION + [28, 41],
                  // i.e. there will be a minimum of 28 guard digits retained.
                  k = mathceil(POW_PRECISION / LOG_BASE + 2)
                }

                if (nIsBig) {
                  half = new BigNumber(0.5)
                  if (nIsNeg) n.s = 1
                  nIsOdd = isOdd(n)
                } else {
                  i = Math.abs(+valueOf(n))
                  nIsOdd = i % 2
                }

                y = new BigNumber(ONE)

                // Performs 54 loop iterations for n of 9007199254740991.
                for (;;) {
                  if (nIsOdd) {
                    y = y.times(x)
                    if (!y.c) break

                    if (k) {
                      if (y.c.length > k) y.c.length = k
                    } else if (isModExp) {
                      y = y.mod(m) //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                    }
                  }

                  if (i) {
                    i = mathfloor(i / 2)
                    if (i === 0) break
                    nIsOdd = i % 2
                  } else {
                    n = n.times(half)
                    round(n, n.e + 1, 1)

                    if (n.e > 14) {
                      nIsOdd = isOdd(n)
                    } else {
                      i = +valueOf(n)
                      if (i === 0) break
                      nIsOdd = i % 2
                    }
                  }

                  x = x.times(x)

                  if (k) {
                    if (x.c && x.c.length > k) x.c.length = k
                  } else if (isModExp) {
                    x = x.mod(m) //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
                  }
                }

                if (isModExp) return y
                if (nIsNeg) y = ONE.div(y)

                return m
                  ? y.mod(m)
                  : k
                  ? round(y, POW_PRECISION, ROUNDING_MODE, more)
                  : y
              }

              /*
               * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
               * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
               *
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
               */
              P.integerValue = function (rm) {
                var n = new BigNumber(this)
                if (rm == null) rm = ROUNDING_MODE
                else intCheck(rm, 0, 8)
                return round(n, n.e + 1, rm)
              }

              /*
               * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
               * otherwise return false.
               */
              P.isEqualTo = P.eq = function (y, b) {
                return compare(this, new BigNumber(y, b)) === 0
              }

              /*
               * Return true if the value of this BigNumber is a finite number, otherwise return false.
               */
              P.isFinite = function () {
                return !!this.c
              }

              /*
               * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
               * otherwise return false.
               */
              P.isGreaterThan = P.gt = function (y, b) {
                return compare(this, new BigNumber(y, b)) > 0
              }

              /*
               * Return true if the value of this BigNumber is greater than or equal to the value of
               * BigNumber(y, b), otherwise return false.
               */
              P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
                return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0
              }

              /*
               * Return true if the value of this BigNumber is an integer, otherwise return false.
               */
              P.isInteger = function () {
                return (
                  !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2
                )
              }

              /*
               * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
               * otherwise return false.
               */
              P.isLessThan = P.lt = function (y, b) {
                return compare(this, new BigNumber(y, b)) < 0
              }

              /*
               * Return true if the value of this BigNumber is less than or equal to the value of
               * BigNumber(y, b), otherwise return false.
               */
              P.isLessThanOrEqualTo = P.lte = function (y, b) {
                return (
                  (b = compare(this, new BigNumber(y, b))) === -1 || b === 0
                )
              }

              /*
               * Return true if the value of this BigNumber is NaN, otherwise return false.
               */
              P.isNaN = function () {
                return !this.s
              }

              /*
               * Return true if the value of this BigNumber is negative, otherwise return false.
               */
              P.isNegative = function () {
                return this.s < 0
              }

              /*
               * Return true if the value of this BigNumber is positive, otherwise return false.
               */
              P.isPositive = function () {
                return this.s > 0
              }

              /*
               * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
               */
              P.isZero = function () {
                return !!this.c && this.c[0] == 0
              }

              /*
               *  n - 0 = n
               *  n - N = N
               *  n - I = -I
               *  0 - n = -n
               *  0 - 0 = 0
               *  0 - N = N
               *  0 - I = -I
               *  N - n = N
               *  N - 0 = N
               *  N - N = N
               *  N - I = N
               *  I - n = I
               *  I - 0 = I
               *  I - N = N
               *  I - I = N
               *
               * Return a new BigNumber whose value is the value of this BigNumber minus the value of
               * BigNumber(y, b).
               */
              P.minus = function (y, b) {
                var i,
                  j,
                  t,
                  xLTy,
                  x = this,
                  a = x.s

                y = new BigNumber(y, b)
                b = y.s

                // Either NaN?
                if (!a || !b) return new BigNumber(NaN)

                // Signs differ?
                if (a != b) {
                  y.s = -b
                  return x.plus(y)
                }

                var xe = x.e / LOG_BASE,
                  ye = y.e / LOG_BASE,
                  xc = x.c,
                  yc = y.c

                if (!xe || !ye) {
                  // Either Infinity?
                  if (!xc || !yc)
                    return xc ? ((y.s = -b), y) : new BigNumber(yc ? x : NaN)

                  // Either zero?
                  if (!xc[0] || !yc[0]) {
                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0]
                      ? ((y.s = -b), y)
                      : new BigNumber(
                          xc[0]
                            ? x
                            : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                            ROUNDING_MODE == 3
                            ? -0
                            : 0
                        )
                  }
                }

                xe = bitFloor(xe)
                ye = bitFloor(ye)
                xc = xc.slice()

                // Determine which is the bigger number.
                if ((a = xe - ye)) {
                  if ((xLTy = a < 0)) {
                    a = -a
                    t = xc
                  } else {
                    ye = xe
                    t = yc
                  }

                  t.reverse()

                  // Prepend zeros to equalise exponents.
                  for (b = a; b--; t.push(0));
                  t.reverse()
                } else {
                  // Exponents equal. Check digit by digit.
                  j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b

                  for (a = b = 0; b < j; b++) {
                    if (xc[b] != yc[b]) {
                      xLTy = xc[b] < yc[b]
                      break
                    }
                  }
                }

                // x < y? Point xc to the array of the bigger number.
                if (xLTy) (t = xc), (xc = yc), (yc = t), (y.s = -y.s)

                b = (j = yc.length) - (i = xc.length)

                // Append zeros to xc if shorter.
                // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
                if (b > 0) for (; b--; xc[i++] = 0);
                b = BASE - 1

                // Subtract yc from xc.
                for (; j > a; ) {
                  if (xc[--j] < yc[j]) {
                    for (i = j; i && !xc[--i]; xc[i] = b);
                    --xc[i]
                    xc[j] += BASE
                  }

                  xc[j] -= yc[j]
                }

                // Remove leading zeros and adjust exponent accordingly.
                for (; xc[0] == 0; xc.splice(0, 1), --ye);

                // Zero?
                if (!xc[0]) {
                  // Following IEEE 754 (2008) 6.3,
                  // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                  y.s = ROUNDING_MODE == 3 ? -1 : 1
                  y.c = [(y.e = 0)]
                  return y
                }

                // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
                // for finite x and y.
                return normalise(y, xc, ye)
              }

              /*
               *   n % 0 =  N
               *   n % N =  N
               *   n % I =  n
               *   0 % n =  0
               *  -0 % n = -0
               *   0 % 0 =  N
               *   0 % N =  N
               *   0 % I =  0
               *   N % n =  N
               *   N % 0 =  N
               *   N % N =  N
               *   N % I =  N
               *   I % n =  N
               *   I % 0 =  N
               *   I % N =  N
               *   I % I =  N
               *
               * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
               * BigNumber(y, b). The result depends on the value of MODULO_MODE.
               */
              P.modulo = P.mod = function (y, b) {
                var q,
                  s,
                  x = this

                y = new BigNumber(y, b)

                // Return NaN if x is Infinity or NaN, or y is NaN or zero.
                if (!x.c || !y.s || (y.c && !y.c[0])) {
                  return new BigNumber(NaN)

                  // Return x if y is Infinity or x is zero.
                } else if (!y.c || (x.c && !x.c[0])) {
                  return new BigNumber(x)
                }

                if (MODULO_MODE == 9) {
                  // Euclidian division: q = sign(y) * floor(x / abs(y))
                  // r = x - qy    where  0 <= r < abs(y)
                  s = y.s
                  y.s = 1
                  q = div(x, y, 0, 3)
                  y.s = s
                  q.s *= s
                } else {
                  q = div(x, y, 0, MODULO_MODE)
                }

                y = x.minus(q.times(y))

                // To match JavaScript %, ensure sign of zero is sign of dividend.
                if (!y.c[0] && MODULO_MODE == 1) y.s = x.s

                return y
              }

              /*
               *  n * 0 = 0
               *  n * N = N
               *  n * I = I
               *  0 * n = 0
               *  0 * 0 = 0
               *  0 * N = N
               *  0 * I = N
               *  N * n = N
               *  N * 0 = N
               *  N * N = N
               *  N * I = N
               *  I * n = I
               *  I * 0 = N
               *  I * N = N
               *  I * I = I
               *
               * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
               * of BigNumber(y, b).
               */
              P.multipliedBy = P.times = function (y, b) {
                var c,
                  e,
                  i,
                  j,
                  k,
                  m,
                  xcL,
                  xlo,
                  xhi,
                  ycL,
                  ylo,
                  yhi,
                  zc,
                  base,
                  sqrtBase,
                  x = this,
                  xc = x.c,
                  yc = (y = new BigNumber(y, b)).c

                // Either NaN, ±Infinity or ±0?
                if (!xc || !yc || !xc[0] || !yc[0]) {
                  // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                  if (
                    !x.s ||
                    !y.s ||
                    (xc && !xc[0] && !yc) ||
                    (yc && !yc[0] && !xc)
                  ) {
                    y.c = y.e = y.s = null
                  } else {
                    y.s *= x.s

                    // Return ±Infinity if either is ±Infinity.
                    if (!xc || !yc) {
                      y.c = y.e = null

                      // Return ±0 if either is ±0.
                    } else {
                      y.c = [0]
                      y.e = 0
                    }
                  }

                  return y
                }

                e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE)
                y.s *= x.s
                xcL = xc.length
                ycL = yc.length

                // Ensure xc points to longer array and xcL to its length.
                if (xcL < ycL)
                  (zc = xc),
                    (xc = yc),
                    (yc = zc),
                    (i = xcL),
                    (xcL = ycL),
                    (ycL = i)

                // Initialise the result array with zeros.
                for (i = xcL + ycL, zc = []; i--; zc.push(0));

                base = BASE
                sqrtBase = SQRT_BASE

                for (i = ycL; --i >= 0; ) {
                  c = 0
                  ylo = yc[i] % sqrtBase
                  yhi = (yc[i] / sqrtBase) | 0

                  for (k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase
                    xhi = (xc[k] / sqrtBase) | 0
                    m = yhi * xlo + xhi * ylo
                    xlo = ylo * xlo + (m % sqrtBase) * sqrtBase + zc[j] + c
                    c = ((xlo / base) | 0) + ((m / sqrtBase) | 0) + yhi * xhi
                    zc[j--] = xlo % base
                  }

                  zc[j] = c
                }

                if (c) {
                  ++e
                } else {
                  zc.splice(0, 1)
                }

                return normalise(y, zc, e)
              }

              /*
               * Return a new BigNumber whose value is the value of this BigNumber negated,
               * i.e. multiplied by -1.
               */
              P.negated = function () {
                var x = new BigNumber(this)
                x.s = -x.s || null
                return x
              }

              /*
               *  n + 0 = n
               *  n + N = N
               *  n + I = I
               *  0 + n = n
               *  0 + 0 = 0
               *  0 + N = N
               *  0 + I = I
               *  N + n = N
               *  N + 0 = N
               *  N + N = N
               *  N + I = N
               *  I + n = I
               *  I + 0 = I
               *  I + N = N
               *  I + I = I
               *
               * Return a new BigNumber whose value is the value of this BigNumber plus the value of
               * BigNumber(y, b).
               */
              P.plus = function (y, b) {
                var t,
                  x = this,
                  a = x.s

                y = new BigNumber(y, b)
                b = y.s

                // Either NaN?
                if (!a || !b) return new BigNumber(NaN)

                // Signs differ?
                if (a != b) {
                  y.s = -b
                  return x.minus(y)
                }

                var xe = x.e / LOG_BASE,
                  ye = y.e / LOG_BASE,
                  xc = x.c,
                  yc = y.c

                if (!xe || !ye) {
                  // Return ±Infinity if either ±Infinity.
                  if (!xc || !yc) return new BigNumber(a / 0)

                  // Either zero?
                  // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                  if (!xc[0] || !yc[0])
                    return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0)
                }

                xe = bitFloor(xe)
                ye = bitFloor(ye)
                xc = xc.slice()

                // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
                if ((a = xe - ye)) {
                  if (a > 0) {
                    ye = xe
                    t = yc
                  } else {
                    a = -a
                    t = xc
                  }

                  t.reverse()
                  for (; a--; t.push(0));
                  t.reverse()
                }

                a = xc.length
                b = yc.length

                // Point xc to the longer array, and b to the shorter length.
                if (a - b < 0) (t = yc), (yc = xc), (xc = t), (b = a)

                // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
                for (a = 0; b; ) {
                  a = ((xc[--b] = xc[b] + yc[b] + a) / BASE) | 0
                  xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE
                }

                if (a) {
                  xc = [a].concat(xc)
                  ++ye
                }

                // No need to check for zero, as +x + +y != 0 && -x + -y != 0
                // ye = MAX_EXP + 1 possible
                return normalise(y, xc, ye)
              }

              /*
               * If sd is undefined or null or true or false, return the number of significant digits of
               * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
               * If sd is true include integer-part trailing zeros in the count.
               *
               * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
               * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
               * ROUNDING_MODE if rm is omitted.
               *
               * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
               *                     boolean: whether to count integer-part trailing zeros: true or false.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
               */
              P.precision = P.sd = function (sd, rm) {
                var c,
                  n,
                  v,
                  x = this

                if (sd != null && sd !== !!sd) {
                  intCheck(sd, 1, MAX)
                  if (rm == null) rm = ROUNDING_MODE
                  else intCheck(rm, 0, 8)

                  return round(new BigNumber(x), sd, rm)
                }

                if (!(c = x.c)) return null
                v = c.length - 1
                n = v * LOG_BASE + 1

                if ((v = c[v])) {
                  // Subtract the number of trailing zeros of the last element.
                  for (; v % 10 == 0; v /= 10, n--);

                  // Add the number of digits of the first element.
                  for (v = c[0]; v >= 10; v /= 10, n++);
                }

                if (sd && x.e + 1 > n) n = x.e + 1

                return n
              }

              /*
               * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
               * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
               *
               * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
               */
              P.shiftedBy = function (k) {
                intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
                return this.times('1e' + k)
              }

              /*
               *  sqrt(-n) =  N
               *  sqrt(N) =  N
               *  sqrt(-I) =  N
               *  sqrt(I) =  I
               *  sqrt(0) =  0
               *  sqrt(-0) = -0
               *
               * Return a new BigNumber whose value is the square root of the value of this BigNumber,
               * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
               */
              P.squareRoot = P.sqrt = function () {
                var m,
                  n,
                  r,
                  rep,
                  t,
                  x = this,
                  c = x.c,
                  s = x.s,
                  e = x.e,
                  dp = DECIMAL_PLACES + 4,
                  half = new BigNumber('0.5')

                // Negative/NaN/Infinity/zero?
                if (s !== 1 || !c || !c[0]) {
                  return new BigNumber(
                    !s || (s < 0 && (!c || c[0])) ? NaN : c ? x : 1 / 0
                  )
                }

                // Initial estimate.
                s = Math.sqrt(+valueOf(x))

                // Math.sqrt underflow/overflow?
                // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
                if (s == 0 || s == 1 / 0) {
                  n = coeffToString(c)
                  if ((n.length + e) % 2 == 0) n += '0'
                  s = Math.sqrt(+n)
                  e = bitFloor((e + 1) / 2) - (e < 0 || e % 2)

                  if (s == 1 / 0) {
                    n = '5e' + e
                  } else {
                    n = s.toExponential()
                    n = n.slice(0, n.indexOf('e') + 1) + e
                  }

                  r = new BigNumber(n)
                } else {
                  r = new BigNumber(s + '')
                }

                // Check for zero.
                // r could be zero if MIN_EXP is changed after the this value was created.
                // This would cause a division by zero (x/t) and hence Infinity below, which would cause
                // coeffToString to throw.
                if (r.c[0]) {
                  e = r.e
                  s = e + dp
                  if (s < 3) s = 0

                  // Newton-Raphson iteration.
                  for (;;) {
                    t = r
                    r = half.times(t.plus(div(x, t, dp, 1)))

                    if (
                      coeffToString(t.c).slice(0, s) ===
                      (n = coeffToString(r.c)).slice(0, s)
                    ) {
                      // The exponent of r may here be one less than the final result exponent,
                      // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                      // are indexed correctly.
                      if (r.e < e) --s
                      n = n.slice(s - 3, s + 1)

                      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                      // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                      // iteration.
                      if (n == '9999' || (!rep && n == '4999')) {
                        // On the first iteration only, check to see if rounding up gives the
                        // exact result as the nines may infinitely repeat.
                        if (!rep) {
                          round(t, t.e + DECIMAL_PLACES + 2, 0)

                          if (t.times(t).eq(x)) {
                            r = t
                            break
                          }
                        }

                        dp += 4
                        s += 4
                        rep = 1
                      } else {
                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                        // result. If not, then there are further digits and m will be truthy.
                        if (!+n || (!+n.slice(1) && n.charAt(0) == '5')) {
                          // Truncate to the first rounding digit.
                          round(r, r.e + DECIMAL_PLACES + 2, 1)
                          m = !r.times(r).eq(x)
                        }

                        break
                      }
                    }
                  }
                }

                return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m)
              }

              /*
               * Return a string representing the value of this BigNumber in exponential notation and
               * rounded using ROUNDING_MODE to dp fixed decimal places.
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
               */
              P.toExponential = function (dp, rm) {
                if (dp != null) {
                  intCheck(dp, 0, MAX)
                  dp++
                }
                return format(this, dp, rm, 1)
              }

              /*
               * Return a string representing the value of this BigNumber in fixed-point notation rounding
               * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
               *
               * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
               * but e.g. (-0.00001).toFixed(0) is '-0'.
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
               */
              P.toFixed = function (dp, rm) {
                if (dp != null) {
                  intCheck(dp, 0, MAX)
                  dp = dp + this.e + 1
                }
                return format(this, dp, rm)
              }

              /*
               * Return a string representing the value of this BigNumber in fixed-point notation rounded
               * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
               * of the format or FORMAT object (see BigNumber.set).
               *
               * The formatting object may contain some or all of the properties shown below.
               *
               * FORMAT = {
               *   prefix: '',
               *   groupSize: 3,
               *   secondaryGroupSize: 0,
               *   groupSeparator: ',',
               *   decimalSeparator: '.',
               *   fractionGroupSize: 0,
               *   fractionGroupSeparator: '\xA0',      // non-breaking space
               *   suffix: ''
               * };
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               * [format] {object} Formatting options. See FORMAT pbject above.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
               * '[BigNumber Error] Argument not an object: {format}'
               */
              P.toFormat = function (dp, rm, format) {
                var str,
                  x = this

                if (format == null) {
                  if (dp != null && rm && typeof rm == 'object') {
                    format = rm
                    rm = null
                  } else if (dp && typeof dp == 'object') {
                    format = dp
                    dp = rm = null
                  } else {
                    format = FORMAT
                  }
                } else if (typeof format != 'object') {
                  throw Error(
                    bignumberError + 'Argument not an object: ' + format
                  )
                }

                str = x.toFixed(dp, rm)

                if (x.c) {
                  var i,
                    arr = str.split('.'),
                    g1 = +format.groupSize,
                    g2 = +format.secondaryGroupSize,
                    groupSeparator = format.groupSeparator || '',
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = x.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length

                  if (g2) (i = g1), (g1 = g2), (g2 = i), (len -= i)

                  if (g1 > 0 && len > 0) {
                    i = len % g1 || g1
                    intPart = intDigits.substr(0, i)
                    for (; i < len; i += g1)
                      intPart += groupSeparator + intDigits.substr(i, g1)
                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i)
                    if (isNeg) intPart = '-' + intPart
                  }

                  str = fractionPart
                    ? intPart +
                      (format.decimalSeparator || '') +
                      ((g2 = +format.fractionGroupSize)
                        ? fractionPart.replace(
                            new RegExp('\\d{' + g2 + '}\\B', 'g'),
                            '$&' + (format.fractionGroupSeparator || '')
                          )
                        : fractionPart)
                    : intPart
                }

                return (format.prefix || '') + str + (format.suffix || '')
              }

              /*
               * Return an array of two BigNumbers representing the value of this BigNumber as a simple
               * fraction with an integer numerator and an integer denominator.
               * The denominator will be a positive non-zero value less than or equal to the specified
               * maximum denominator. If a maximum denominator is not specified, the denominator will be
               * the lowest value necessary to represent the number exactly.
               *
               * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
               *
               * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
               */
              P.toFraction = function (md) {
                var d,
                  d0,
                  d1,
                  d2,
                  e,
                  exp,
                  n,
                  n0,
                  n1,
                  q,
                  r,
                  s,
                  x = this,
                  xc = x.c

                if (md != null) {
                  n = new BigNumber(md)

                  // Throw if md is less than one or is not an integer, unless it is Infinity.
                  if ((!n.isInteger() && (n.c || n.s !== 1)) || n.lt(ONE)) {
                    throw Error(
                      bignumberError +
                        'Argument ' +
                        (n.isInteger()
                          ? 'out of range: '
                          : 'not an integer: ') +
                        valueOf(n)
                    )
                  }
                }

                if (!xc) return new BigNumber(x)

                d = new BigNumber(ONE)
                n1 = d0 = new BigNumber(ONE)
                d1 = n0 = new BigNumber(ONE)
                s = coeffToString(xc)

                // Determine initial denominator.
                // d is a power of 10 and the minimum max denominator that specifies the value exactly.
                e = d.e = s.length - x.e - 1
                d.c[0] =
                  POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp]
                md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n

                exp = MAX_EXP
                MAX_EXP = 1 / 0
                n = new BigNumber(s)

                // n0 = d1 = 0
                n0.c[0] = 0

                for (;;) {
                  q = div(n, d, 0, 1)
                  d2 = d0.plus(q.times(d1))
                  if (d2.comparedTo(md) == 1) break
                  d0 = d1
                  d1 = d2
                  n1 = n0.plus(q.times((d2 = n1)))
                  n0 = d2
                  d = n.minus(q.times((d2 = d)))
                  n = d2
                }

                d2 = div(md.minus(d0), d1, 0, 1)
                n0 = n0.plus(d2.times(n1))
                d0 = d0.plus(d2.times(d1))
                n0.s = n1.s = x.s
                e = e * 2

                // Determine which fraction is closer to x, n0/d0 or n1/d1
                r =
                  div(n1, d1, e, ROUNDING_MODE)
                    .minus(x)
                    .abs()
                    .comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) <
                  1
                    ? [n1, d1]
                    : [n0, d0]

                MAX_EXP = exp

                return r
              }

              /*
               * Return the value of this BigNumber converted to a number primitive.
               */
              P.toNumber = function () {
                return +valueOf(this)
              }

              /*
               * Return a string representing the value of this BigNumber rounded to sd significant digits
               * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
               * necessary to represent the integer part of the value in fixed-point notation, then use
               * exponential notation.
               *
               * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
               */
              P.toPrecision = function (sd, rm) {
                if (sd != null) intCheck(sd, 1, MAX)
                return format(this, sd, rm, 2)
              }

              /*
               * Return a string representing the value of this BigNumber in base b, or base 10 if b is
               * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
               * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
               * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
               * TO_EXP_NEG, return exponential notation.
               *
               * [b] {number} Integer, 2 to ALPHABET.length inclusive.
               *
               * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
               */
              P.toString = function (b) {
                var str,
                  n = this,
                  s = n.s,
                  e = n.e

                // Infinity or NaN?
                if (e === null) {
                  if (s) {
                    str = 'Infinity'
                    if (s < 0) str = '-' + str
                  } else {
                    str = 'NaN'
                  }
                } else {
                  if (b == null) {
                    str =
                      e <= TO_EXP_NEG || e >= TO_EXP_POS
                        ? toExponential(coeffToString(n.c), e)
                        : toFixedPoint(coeffToString(n.c), e, '0')
                  } else if (b === 10) {
                    n = round(
                      new BigNumber(n),
                      DECIMAL_PLACES + e + 1,
                      ROUNDING_MODE
                    )
                    str = toFixedPoint(coeffToString(n.c), n.e, '0')
                  } else {
                    intCheck(b, 2, ALPHABET.length, 'Base')
                    str = convertBase(
                      toFixedPoint(coeffToString(n.c), e, '0'),
                      10,
                      b,
                      s,
                      true
                    )
                  }

                  if (s < 0 && n.c[0]) str = '-' + str
                }

                return str
              }

              /*
               * Return as toString, but do not accept a base argument, and include the minus sign for
               * negative zero.
               */
              P.valueOf = P.toJSON = function () {
                return valueOf(this)
              }

              P._isBigNumber = true

              if (configObject != null) BigNumber.set(configObject)

              return BigNumber
            }

            // PRIVATE HELPER FUNCTIONS

            // These functions don't need access to variables,
            // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.

            function bitFloor(n) {
              var i = n | 0
              return n > 0 || n === i ? i : i - 1
            }

            // Return a coefficient array as a string of base 10 digits.
            function coeffToString(a) {
              var s,
                z,
                i = 1,
                j = a.length,
                r = a[0] + ''

              for (; i < j; ) {
                s = a[i++] + ''
                z = LOG_BASE - s.length
                for (; z--; s = '0' + s);
                r += s
              }

              // Determine trailing zeros.
              for (j = r.length; r.charCodeAt(--j) === 48; );

              return r.slice(0, j + 1 || 1)
            }

            // Compare the value of BigNumbers x and y.
            function compare(x, y) {
              var a,
                b,
                xc = x.c,
                yc = y.c,
                i = x.s,
                j = y.s,
                k = x.e,
                l = y.e

              // Either NaN?
              if (!i || !j) return null

              a = xc && !xc[0]
              b = yc && !yc[0]

              // Either zero?
              if (a || b) return a ? (b ? 0 : -j) : i

              // Signs differ?
              if (i != j) return i

              a = i < 0
              b = k == l

              // Either Infinity?
              if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1

              // Compare exponents.
              if (!b) return (k > l) ^ a ? 1 : -1

              j = (k = xc.length) < (l = yc.length) ? k : l

              // Compare digit by digit.
              for (i = 0; i < j; i++)
                if (xc[i] != yc[i]) return (xc[i] > yc[i]) ^ a ? 1 : -1

              // Compare lengths.
              return k == l ? 0 : (k > l) ^ a ? 1 : -1
            }

            /*
             * Check that n is a primitive number, an integer, and in range, otherwise throw.
             */
            function intCheck(n, min, max, name) {
              if (n < min || n > max || n !== mathfloor(n)) {
                throw Error(
                  bignumberError +
                    (name || 'Argument') +
                    (typeof n == 'number'
                      ? n < min || n > max
                        ? ' out of range: '
                        : ' not an integer: '
                      : ' not a primitive number: ') +
                    String(n)
                )
              }
            }

            // Assumes finite n.
            function isOdd(n) {
              var k = n.c.length - 1
              return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0
            }

            function toExponential(str, e) {
              return (
                (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
                (e < 0 ? 'e' : 'e+') +
                e
              )
            }

            function toFixedPoint(str, e, z) {
              var len, zs

              // Negative exponent?
              if (e < 0) {
                // Prepend zeros.
                for (zs = z + '.'; ++e; zs += z);
                str = zs + str

                // Positive exponent
              } else {
                len = str.length

                // Append zeros.
                if (++e > len) {
                  for (zs = z, e -= len; --e; zs += z);
                  str += zs
                } else if (e < len) {
                  str = str.slice(0, e) + '.' + str.slice(e)
                }
              }

              return str
            }

            // EXPORT

            BigNumber = clone()
            BigNumber['default'] = BigNumber.BigNumber = BigNumber

            // AMD.
            if (typeof define == 'function' && define.amd) {
              define(function () {
                return BigNumber
              })

              // Node.js and other environments that support module.exports.
            } else if (typeof module != 'undefined' && module.exports) {
              module.exports = BigNumber

              // Browser.
            } else {
              if (!globalObject) {
                globalObject =
                  typeof self != 'undefined' && self ? self : window
              }

              globalObject.BigNumber = BigNumber
            }
          })(this)
        },
        {},
      ],
      14: [
        function (require, module, exports) {
          module.exports = loadWebAssembly

          loadWebAssembly.supported = typeof WebAssembly !== 'undefined'

          function loadWebAssembly(opts) {
            if (!loadWebAssembly.supported) return null

            var imp = opts && opts.imports
            var wasm = toUint8Array(
              'AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL'
            )
            var ready = null

            var mod = {
              buffer: wasm,
              memory: null,
              exports: null,
              realloc: realloc,
              onload: onload,
            }

            onload(function () {})

            return mod

            function realloc(size) {
              mod.exports.memory.grow(
                Math.ceil(Math.abs(size - mod.memory.length) / 65536)
              )
              mod.memory = new Uint8Array(mod.exports.memory.buffer)
            }

            function onload(cb) {
              if (mod.exports) return cb()

              if (ready) {
                ready.then(cb.bind(null, null)).catch(cb)
                return
              }

              try {
                if (opts && opts.async) throw new Error('async')
                setup({
                  instance: new WebAssembly.Instance(
                    new WebAssembly.Module(wasm),
                    imp
                  ),
                })
              } catch (err) {
                ready = WebAssembly.instantiate(wasm, imp).then(setup)
              }

              onload(cb)
            }

            function setup(w) {
              mod.exports = w.instance.exports
              mod.memory =
                mod.exports.memory &&
                mod.exports.memory.buffer &&
                new Uint8Array(mod.exports.memory.buffer)
            }
          }

          function toUint8Array(s) {
            if (typeof atob === 'function')
              return new Uint8Array(atob(s).split('').map(charCodeAt))
            return new (require('buf' + 'fer').Buffer)(s, 'base64')
          }

          function charCodeAt(c) {
            return c.charCodeAt(0)
          }
        },
        {},
      ],
      15: [
        function (require, module, exports) {
          var assert = require('nanoassert')
          var wasm = require('./blake2b')()

          var head = 64
          var freeList = []

          module.exports = Blake2b
          var BYTES_MIN = (module.exports.BYTES_MIN = 16)
          var BYTES_MAX = (module.exports.BYTES_MAX = 64)
          var BYTES = (module.exports.BYTES = 32)
          var KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16)
          var KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64)
          var KEYBYTES = (module.exports.KEYBYTES = 32)
          var SALTBYTES = (module.exports.SALTBYTES = 16)
          var PERSONALBYTES = (module.exports.PERSONALBYTES = 16)

          function Blake2b(digestLength, key, salt, personal, noAssert) {
            if (!(this instanceof Blake2b))
              return new Blake2b(digestLength, key, salt, personal, noAssert)
            if (!(wasm && wasm.exports))
              throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)')
            if (!digestLength) digestLength = 32

            if (noAssert !== true) {
              assert(
                digestLength >= BYTES_MIN,
                'digestLength must be at least ' +
                  BYTES_MIN +
                  ', was given ' +
                  digestLength
              )
              assert(
                digestLength <= BYTES_MAX,
                'digestLength must be at most ' +
                  BYTES_MAX +
                  ', was given ' +
                  digestLength
              )
              if (key != null)
                assert(
                  key.length >= KEYBYTES_MIN,
                  'key must be at least ' +
                    KEYBYTES_MIN +
                    ', was given ' +
                    key.length
                )
              if (key != null)
                assert(
                  key.length <= KEYBYTES_MAX,
                  'key must be at least ' +
                    KEYBYTES_MAX +
                    ', was given ' +
                    key.length
                )
              if (salt != null)
                assert(
                  salt.length === SALTBYTES,
                  'salt must be exactly ' +
                    SALTBYTES +
                    ', was given ' +
                    salt.length
                )
              if (personal != null)
                assert(
                  personal.length === PERSONALBYTES,
                  'personal must be exactly ' +
                    PERSONALBYTES +
                    ', was given ' +
                    personal.length
                )
            }

            if (!freeList.length) {
              freeList.push(head)
              head += 216
            }

            this.digestLength = digestLength
            this.finalized = false
            this.pointer = freeList.pop()

            wasm.memory.fill(0, 0, 64)
            wasm.memory[0] = this.digestLength
            wasm.memory[1] = key ? key.length : 0
            wasm.memory[2] = 1 // fanout
            wasm.memory[3] = 1 // depth

            if (salt) wasm.memory.set(salt, 32)
            if (personal) wasm.memory.set(personal, 48)

            if (this.pointer + 216 > wasm.memory.length)
              wasm.realloc(this.pointer + 216) // we need 216 bytes for the state
            wasm.exports.blake2b_init(this.pointer, this.digestLength)

            if (key) {
              this.update(key)
              wasm.memory.fill(0, head, head + key.length) // whiteout key
              wasm.memory[this.pointer + 200] = 128
            }
          }

          Blake2b.prototype.update = function (input) {
            assert(this.finalized === false, 'Hash instance finalized')
            assert(input, 'input must be TypedArray or Buffer')

            if (head + input.length > wasm.memory.length)
              wasm.realloc(head + input.length)
            wasm.memory.set(input, head)
            wasm.exports.blake2b_update(this.pointer, head, head + input.length)
            return this
          }

          Blake2b.prototype.digest = function (enc) {
            assert(this.finalized === false, 'Hash instance finalized')
            this.finalized = true

            freeList.push(this.pointer)
            wasm.exports.blake2b_final(this.pointer)

            if (!enc || enc === 'binary') {
              return wasm.memory.slice(
                this.pointer + 128,
                this.pointer + 128 + this.digestLength
              )
            }

            if (enc === 'hex') {
              return hexSlice(
                wasm.memory,
                this.pointer + 128,
                this.digestLength
              )
            }

            assert(
              enc.length >= this.digestLength,
              'input must be TypedArray or Buffer'
            )
            for (var i = 0; i < this.digestLength; i++) {
              enc[i] = wasm.memory[this.pointer + 128 + i]
            }

            return enc
          }

          // libsodium compat
          Blake2b.prototype.final = Blake2b.prototype.digest

          Blake2b.WASM = wasm && wasm.buffer
          Blake2b.SUPPORTED = typeof WebAssembly !== 'undefined'

          Blake2b.ready = function (cb) {
            if (!cb) cb = noop
            if (!wasm) return cb(new Error('WebAssembly not supported'))

            // backwards compat, can be removed in a new major
            var p = new Promise(function (reject, resolve) {
              wasm.onload(function (err) {
                if (err) resolve()
                else reject()
                cb(err)
              })
            })

            return p
          }

          Blake2b.prototype.ready = Blake2b.ready

          function noop() {}

          function hexSlice(buf, start, len) {
            var str = ''
            for (var i = 0; i < len; i++) str += toHex(buf[start + i])
            return str
          }

          function toHex(n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
          }
        },
        { './blake2b': 14, nanoassert: 44 },
      ],
      16: [
        function (require, module, exports) {
          var assert = require('nanoassert')
          var b2wasm = require('blake2b-wasm')

          // 64-bit unsigned addition
          // Sets v[a,a+1] += v[b,b+1]
          // v should be a Uint32Array
          function ADD64AA(v, a, b) {
            var o0 = v[a] + v[b]
            var o1 = v[a + 1] + v[b + 1]
            if (o0 >= 0x100000000) {
              o1++
            }
            v[a] = o0
            v[a + 1] = o1
          }

          // 64-bit unsigned addition
          // Sets v[a,a+1] += b
          // b0 is the low 32 bits of b, b1 represents the high 32 bits
          function ADD64AC(v, a, b0, b1) {
            var o0 = v[a] + b0
            if (b0 < 0) {
              o0 += 0x100000000
            }
            var o1 = v[a + 1] + b1
            if (o0 >= 0x100000000) {
              o1++
            }
            v[a] = o0
            v[a + 1] = o1
          }

          // Little-endian byte access
          function B2B_GET32(arr, i) {
            return (
              arr[i] ^
              (arr[i + 1] << 8) ^
              (arr[i + 2] << 16) ^
              (arr[i + 3] << 24)
            )
          }

          // G Mixing function
          // The ROTRs are inlined for speed
          function B2B_G(a, b, c, d, ix, iy) {
            var x0 = m[ix]
            var x1 = m[ix + 1]
            var y0 = m[iy]
            var y1 = m[iy + 1]

            ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
            ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

            // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
            var xor0 = v[d] ^ v[a]
            var xor1 = v[d + 1] ^ v[a + 1]
            v[d] = xor1
            v[d + 1] = xor0

            ADD64AA(v, c, d)

            // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
            xor0 = v[b] ^ v[c]
            xor1 = v[b + 1] ^ v[c + 1]
            v[b] = (xor0 >>> 24) ^ (xor1 << 8)
            v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

            ADD64AA(v, a, b)
            ADD64AC(v, a, y0, y1)

            // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
            xor0 = v[d] ^ v[a]
            xor1 = v[d + 1] ^ v[a + 1]
            v[d] = (xor0 >>> 16) ^ (xor1 << 16)
            v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

            ADD64AA(v, c, d)

            // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
            xor0 = v[b] ^ v[c]
            xor1 = v[b + 1] ^ v[c + 1]
            v[b] = (xor1 >>> 31) ^ (xor0 << 1)
            v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
          }

          // Initialization Vector
          var BLAKE2B_IV32 = new Uint32Array([
            0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b,
            0x3c6ef372, 0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f,
            0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179,
            0x5be0cd19,
          ])

          var SIGMA8 = [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8,
            9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13,
            10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10,
            4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
            2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15,
            14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9,
            5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7,
            1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8,
            9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
          ]

          // These are offsets into a uint64 buffer.
          // Multiply them all by 2 to make them offsets into a uint32 buffer,
          // because this is Javascript and we don't have uint64s
          var SIGMA82 = new Uint8Array(
            SIGMA8.map(function (x) {
              return x * 2
            })
          )

          // Compression function. 'last' flag indicates last block.
          // Note we're representing 16 uint64s as 32 uint32s
          var v = new Uint32Array(32)
          var m = new Uint32Array(32)
          function blake2bCompress(ctx, last) {
            var i = 0

            // init work variables
            for (i = 0; i < 16; i++) {
              v[i] = ctx.h[i]
              v[i + 16] = BLAKE2B_IV32[i]
            }

            // low 64 bits of offset
            v[24] = v[24] ^ ctx.t
            v[25] = v[25] ^ (ctx.t / 0x100000000)
            // high 64 bits not supported, offset may not be higher than 2**53-1

            // last block flag set ?
            if (last) {
              v[28] = ~v[28]
              v[29] = ~v[29]
            }

            // get little-endian words
            for (i = 0; i < 32; i++) {
              m[i] = B2B_GET32(ctx.b, 4 * i)
            }

            // twelve rounds of mixing
            for (i = 0; i < 12; i++) {
              B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
              B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
              B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
              B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
              B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
              B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
              B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
              B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
            }

            for (i = 0; i < 16; i++) {
              ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
            }
          }

          // reusable parameter_block
          var parameter_block = new Uint8Array([
            0,
            0,
            0,
            0, //  0: outlen, keylen, fanout, depth
            0,
            0,
            0,
            0, //  4: leaf length, sequential mode
            0,
            0,
            0,
            0, //  8: node offset
            0,
            0,
            0,
            0, // 12: node offset
            0,
            0,
            0,
            0, // 16: node depth, inner length, rfu
            0,
            0,
            0,
            0, // 20: rfu
            0,
            0,
            0,
            0, // 24: rfu
            0,
            0,
            0,
            0, // 28: rfu
            0,
            0,
            0,
            0, // 32: salt
            0,
            0,
            0,
            0, // 36: salt
            0,
            0,
            0,
            0, // 40: salt
            0,
            0,
            0,
            0, // 44: salt
            0,
            0,
            0,
            0, // 48: personal
            0,
            0,
            0,
            0, // 52: personal
            0,
            0,
            0,
            0, // 56: personal
            0,
            0,
            0,
            0, // 60: personal
          ])

          // Creates a BLAKE2b hashing context
          // Requires an output length between 1 and 64 bytes
          // Takes an optional Uint8Array key
          function Blake2b(outlen, key, salt, personal) {
            // zero out parameter_block before usage
            parameter_block.fill(0)
            // state, 'param block'

            this.b = new Uint8Array(128)
            this.h = new Uint32Array(16)
            this.t = 0 // input count
            this.c = 0 // pointer within buffer
            this.outlen = outlen // output length in bytes

            parameter_block[0] = outlen
            if (key) parameter_block[1] = key.length
            parameter_block[2] = 1 // fanout
            parameter_block[3] = 1 // depth

            if (salt) parameter_block.set(salt, 32)
            if (personal) parameter_block.set(personal, 48)

            // initialize hash state
            for (var i = 0; i < 16; i++) {
              this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4)
            }

            // key the hash, if applicable
            if (key) {
              blake2bUpdate(this, key)
              // at the end
              this.c = 128
            }
          }

          Blake2b.prototype.update = function (input) {
            assert(input != null, 'input must be Uint8Array or Buffer')
            blake2bUpdate(this, input)
            return this
          }

          Blake2b.prototype.digest = function (out) {
            var buf =
              !out || out === 'binary' || out === 'hex'
                ? new Uint8Array(this.outlen)
                : out
            assert(
              buf.length >= this.outlen,
              'out must have at least outlen bytes of space'
            )
            blake2bFinal(this, buf)
            if (out === 'hex') return hexSlice(buf)
            return buf
          }

          Blake2b.prototype.final = Blake2b.prototype.digest

          Blake2b.ready = function (cb) {
            b2wasm.ready(function () {
              cb() // ignore the error
            })
          }

          // Updates a BLAKE2b streaming hash
          // Requires hash context and Uint8Array (byte array)
          function blake2bUpdate(ctx, input) {
            for (var i = 0; i < input.length; i++) {
              if (ctx.c === 128) {
                // buffer full ?
                ctx.t += ctx.c // add counters
                blake2bCompress(ctx, false) // compress (not last)
                ctx.c = 0 // counter to zero
              }
              ctx.b[ctx.c++] = input[i]
            }
          }

          // Completes a BLAKE2b streaming hash
          // Returns a Uint8Array containing the message digest
          function blake2bFinal(ctx, out) {
            ctx.t += ctx.c // mark last block offset

            while (ctx.c < 128) {
              // fill up with zeros
              ctx.b[ctx.c++] = 0
            }
            blake2bCompress(ctx, true) // final block flag = 1

            for (var i = 0; i < ctx.outlen; i++) {
              out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
            }
            return out
          }

          function hexSlice(buf) {
            var str = ''
            for (var i = 0; i < buf.length; i++) str += toHex(buf[i])
            return str
          }

          function toHex(n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
          }

          var Proto = Blake2b

          module.exports = function createHash(
            outlen,
            key,
            salt,
            personal,
            noAssert
          ) {
            if (noAssert !== true) {
              assert(
                outlen >= BYTES_MIN,
                'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen
              )
              assert(
                outlen <= BYTES_MAX,
                'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen
              )
              if (key != null)
                assert(
                  key.length >= KEYBYTES_MIN,
                  'key must be at least ' +
                    KEYBYTES_MIN +
                    ', was given ' +
                    key.length
                )
              if (key != null)
                assert(
                  key.length <= KEYBYTES_MAX,
                  'key must be at most ' +
                    KEYBYTES_MAX +
                    ', was given ' +
                    key.length
                )
              if (salt != null)
                assert(
                  salt.length === SALTBYTES,
                  'salt must be exactly ' +
                    SALTBYTES +
                    ', was given ' +
                    salt.length
                )
              if (personal != null)
                assert(
                  personal.length === PERSONALBYTES,
                  'personal must be exactly ' +
                    PERSONALBYTES +
                    ', was given ' +
                    personal.length
                )
            }

            return new Proto(outlen, key, salt, personal)
          }

          module.exports.ready = function (cb) {
            b2wasm.ready(function () {
              // ignore errors
              cb()
            })
          }

          module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED
          module.exports.WASM_LOADED = false

          var BYTES_MIN = (module.exports.BYTES_MIN = 16)
          var BYTES_MAX = (module.exports.BYTES_MAX = 64)
          var BYTES = (module.exports.BYTES = 32)
          var KEYBYTES_MIN = (module.exports.KEYBYTES_MIN = 16)
          var KEYBYTES_MAX = (module.exports.KEYBYTES_MAX = 64)
          var KEYBYTES = (module.exports.KEYBYTES = 32)
          var SALTBYTES = (module.exports.SALTBYTES = 16)
          var PERSONALBYTES = (module.exports.PERSONALBYTES = 16)

          b2wasm.ready(function (err) {
            if (!err) {
              module.exports.WASM_LOADED = true
              Proto = b2wasm
            }
          })
        },
        { 'blake2b-wasm': 15, nanoassert: 44 },
      ],
      17: [function (require, module, exports) {}, {}],
      18: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              /*!
               * The buffer module from node.js, for the browser.
               *
               * @author   Feross Aboukhadijeh <https://feross.org>
               * @license  MIT
               */
              /* eslint-disable no-proto */

              'use strict'

              var base64 = require('base64-js')
              var ieee754 = require('ieee754')

              exports.Buffer = Buffer
              exports.SlowBuffer = SlowBuffer
              exports.INSPECT_MAX_BYTES = 50

              var K_MAX_LENGTH = 0x7fffffff
              exports.kMaxLength = K_MAX_LENGTH

              /**
               * If `Buffer.TYPED_ARRAY_SUPPORT`:
               *   === true    Use Uint8Array implementation (fastest)
               *   === false   Print warning and recommend using `buffer` v4.x which has an Object
               *               implementation (most compatible, even IE6)
               *
               * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
               * Opera 11.6+, iOS 4.2+.
               *
               * We report that the browser does not support typed arrays if the are not subclassable
               * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
               * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
               * for __proto__ and has a buggy typed array implementation.
               */
              Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

              if (
                !Buffer.TYPED_ARRAY_SUPPORT &&
                typeof console !== 'undefined' &&
                typeof console.error === 'function'
              ) {
                console.error(
                  'This browser lacks typed array (Uint8Array) support which is required by ' +
                    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
                )
              }

              function typedArraySupport() {
                // Can typed array instances can be augmented?
                try {
                  var arr = new Uint8Array(1)
                  arr.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function () {
                      return 42
                    },
                  }
                  return arr.foo() === 42
                } catch (e) {
                  return false
                }
              }

              Object.defineProperty(Buffer.prototype, 'parent', {
                enumerable: true,
                get: function () {
                  if (!Buffer.isBuffer(this)) return undefined
                  return this.buffer
                },
              })

              Object.defineProperty(Buffer.prototype, 'offset', {
                enumerable: true,
                get: function () {
                  if (!Buffer.isBuffer(this)) return undefined
                  return this.byteOffset
                },
              })

              function createBuffer(length) {
                if (length > K_MAX_LENGTH) {
                  throw new RangeError(
                    'The value "' + length + '" is invalid for option "size"'
                  )
                }
                // Return an augmented `Uint8Array` instance
                var buf = new Uint8Array(length)
                buf.__proto__ = Buffer.prototype
                return buf
              }

              /**
               * The Buffer constructor returns instances of `Uint8Array` that have their
               * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
               * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
               * and the `Uint8Array` methods. Square bracket notation works as expected -- it
               * returns a single octet.
               *
               * The `Uint8Array` prototype remains unmodified.
               */

              function Buffer(arg, encodingOrOffset, length) {
                // Common case.
                if (typeof arg === 'number') {
                  if (typeof encodingOrOffset === 'string') {
                    throw new TypeError(
                      'The "string" argument must be of type string. Received type number'
                    )
                  }
                  return allocUnsafe(arg)
                }
                return from(arg, encodingOrOffset, length)
              }

              // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
              if (
                typeof Symbol !== 'undefined' &&
                Symbol.species != null &&
                Buffer[Symbol.species] === Buffer
              ) {
                Object.defineProperty(Buffer, Symbol.species, {
                  value: null,
                  configurable: true,
                  enumerable: false,
                  writable: false,
                })
              }

              Buffer.poolSize = 8192 // not used by this implementation

              function from(value, encodingOrOffset, length) {
                if (typeof value === 'string') {
                  return fromString(value, encodingOrOffset)
                }

                if (ArrayBuffer.isView(value)) {
                  return fromArrayLike(value)
                }

                if (value == null) {
                  throw TypeError(
                    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                      'or Array-like Object. Received type ' +
                      typeof value
                  )
                }

                if (
                  isInstance(value, ArrayBuffer) ||
                  (value && isInstance(value.buffer, ArrayBuffer))
                ) {
                  return fromArrayBuffer(value, encodingOrOffset, length)
                }

                if (typeof value === 'number') {
                  throw new TypeError(
                    'The "value" argument must not be of type number. Received type number'
                  )
                }

                var valueOf = value.valueOf && value.valueOf()
                if (valueOf != null && valueOf !== value) {
                  return Buffer.from(valueOf, encodingOrOffset, length)
                }

                var b = fromObject(value)
                if (b) return b

                if (
                  typeof Symbol !== 'undefined' &&
                  Symbol.toPrimitive != null &&
                  typeof value[Symbol.toPrimitive] === 'function'
                ) {
                  return Buffer.from(
                    value[Symbol.toPrimitive]('string'),
                    encodingOrOffset,
                    length
                  )
                }

                throw new TypeError(
                  'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                    'or Array-like Object. Received type ' +
                    typeof value
                )
              }

              /**
               * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
               * if value is a number.
               * Buffer.from(str[, encoding])
               * Buffer.from(array)
               * Buffer.from(buffer)
               * Buffer.from(arrayBuffer[, byteOffset[, length]])
               **/
              Buffer.from = function (value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length)
              }

              // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
              // https://github.com/feross/buffer/pull/148
              Buffer.prototype.__proto__ = Uint8Array.prototype
              Buffer.__proto__ = Uint8Array

              function assertSize(size) {
                if (typeof size !== 'number') {
                  throw new TypeError('"size" argument must be of type number')
                } else if (size < 0) {
                  throw new RangeError(
                    'The value "' + size + '" is invalid for option "size"'
                  )
                }
              }

              function alloc(size, fill, encoding) {
                assertSize(size)
                if (size <= 0) {
                  return createBuffer(size)
                }
                if (fill !== undefined) {
                  // Only pay attention to encoding if it's a string. This
                  // prevents accidentally sending in a number that would
                  // be interpretted as a start offset.
                  return typeof encoding === 'string'
                    ? createBuffer(size).fill(fill, encoding)
                    : createBuffer(size).fill(fill)
                }
                return createBuffer(size)
              }

              /**
               * Creates a new filled Buffer instance.
               * alloc(size[, fill[, encoding]])
               **/
              Buffer.alloc = function (size, fill, encoding) {
                return alloc(size, fill, encoding)
              }

              function allocUnsafe(size) {
                assertSize(size)
                return createBuffer(size < 0 ? 0 : checked(size) | 0)
              }

              /**
               * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
               * */
              Buffer.allocUnsafe = function (size) {
                return allocUnsafe(size)
              }
              /**
               * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
               */
              Buffer.allocUnsafeSlow = function (size) {
                return allocUnsafe(size)
              }

              function fromString(string, encoding) {
                if (typeof encoding !== 'string' || encoding === '') {
                  encoding = 'utf8'
                }

                if (!Buffer.isEncoding(encoding)) {
                  throw new TypeError('Unknown encoding: ' + encoding)
                }

                var length = byteLength(string, encoding) | 0
                var buf = createBuffer(length)

                var actual = buf.write(string, encoding)

                if (actual !== length) {
                  // Writing a hex string, for example, that contains invalid characters will
                  // cause everything after the first invalid character to be ignored. (e.g.
                  // 'abxxcd' will be treated as 'ab')
                  buf = buf.slice(0, actual)
                }

                return buf
              }

              function fromArrayLike(array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0
                var buf = createBuffer(length)
                for (var i = 0; i < length; i += 1) {
                  buf[i] = array[i] & 255
                }
                return buf
              }

              function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                  throw new RangeError('"offset" is outside of buffer bounds')
                }

                if (array.byteLength < byteOffset + (length || 0)) {
                  throw new RangeError('"length" is outside of buffer bounds')
                }

                var buf
                if (byteOffset === undefined && length === undefined) {
                  buf = new Uint8Array(array)
                } else if (length === undefined) {
                  buf = new Uint8Array(array, byteOffset)
                } else {
                  buf = new Uint8Array(array, byteOffset, length)
                }

                // Return an augmented `Uint8Array` instance
                buf.__proto__ = Buffer.prototype
                return buf
              }

              function fromObject(obj) {
                if (Buffer.isBuffer(obj)) {
                  var len = checked(obj.length) | 0
                  var buf = createBuffer(len)

                  if (buf.length === 0) {
                    return buf
                  }

                  obj.copy(buf, 0, 0, len)
                  return buf
                }

                if (obj.length !== undefined) {
                  if (
                    typeof obj.length !== 'number' ||
                    numberIsNaN(obj.length)
                  ) {
                    return createBuffer(0)
                  }
                  return fromArrayLike(obj)
                }

                if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                  return fromArrayLike(obj.data)
                }
              }

              function checked(length) {
                // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
                // length is NaN (which is otherwise coerced to zero.)
                if (length >= K_MAX_LENGTH) {
                  throw new RangeError(
                    'Attempt to allocate Buffer larger than maximum ' +
                      'size: 0x' +
                      K_MAX_LENGTH.toString(16) +
                      ' bytes'
                  )
                }
                return length | 0
              }

              function SlowBuffer(length) {
                if (+length != length) {
                  // eslint-disable-line eqeqeq
                  length = 0
                }
                return Buffer.alloc(+length)
              }

              Buffer.isBuffer = function isBuffer(b) {
                return (
                  b != null && b._isBuffer === true && b !== Buffer.prototype
                ) // so Buffer.isBuffer(Buffer.prototype) will be false
              }

              Buffer.compare = function compare(a, b) {
                if (isInstance(a, Uint8Array))
                  a = Buffer.from(a, a.offset, a.byteLength)
                if (isInstance(b, Uint8Array))
                  b = Buffer.from(b, b.offset, b.byteLength)
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                  )
                }

                if (a === b) return 0

                var x = a.length
                var y = b.length

                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i]
                    y = b[i]
                    break
                  }
                }

                if (x < y) return -1
                if (y < x) return 1
                return 0
              }

              Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                  case 'hex':
                  case 'utf8':
                  case 'utf-8':
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                  case 'base64':
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return true
                  default:
                    return false
                }
              }

              Buffer.concat = function concat(list, length) {
                if (!Array.isArray(list)) {
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  )
                }

                if (list.length === 0) {
                  return Buffer.alloc(0)
                }

                var i
                if (length === undefined) {
                  length = 0
                  for (i = 0; i < list.length; ++i) {
                    length += list[i].length
                  }
                }

                var buffer = Buffer.allocUnsafe(length)
                var pos = 0
                for (i = 0; i < list.length; ++i) {
                  var buf = list[i]
                  if (isInstance(buf, Uint8Array)) {
                    buf = Buffer.from(buf)
                  }
                  if (!Buffer.isBuffer(buf)) {
                    throw new TypeError(
                      '"list" argument must be an Array of Buffers'
                    )
                  }
                  buf.copy(buffer, pos)
                  pos += buf.length
                }
                return buffer
              }

              function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                  return string.length
                }
                if (
                  ArrayBuffer.isView(string) ||
                  isInstance(string, ArrayBuffer)
                ) {
                  return string.byteLength
                }
                if (typeof string !== 'string') {
                  throw new TypeError(
                    'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                      'Received type ' +
                      typeof string
                  )
                }

                var len = string.length
                var mustMatch = arguments.length > 2 && arguments[2] === true
                if (!mustMatch && len === 0) return 0

                // Use a for loop to avoid recursion
                var loweredCase = false
                for (;;) {
                  switch (encoding) {
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                      return len
                    case 'utf8':
                    case 'utf-8':
                      return utf8ToBytes(string).length
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                      return len * 2
                    case 'hex':
                      return len >>> 1
                    case 'base64':
                      return base64ToBytes(string).length
                    default:
                      if (loweredCase) {
                        return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                      }
                      encoding = ('' + encoding).toLowerCase()
                      loweredCase = true
                  }
                }
              }
              Buffer.byteLength = byteLength

              function slowToString(encoding, start, end) {
                var loweredCase = false

                // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                // property of a typed array.

                // This behaves neither like String nor Uint8Array in that we set start/end
                // to their upper/lower bounds if the value passed is out of range.
                // undefined is handled specially as per ECMA-262 6th Edition,
                // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                if (start === undefined || start < 0) {
                  start = 0
                }
                // Return early if start > this.length. Done here to prevent potential uint32
                // coercion fail below.
                if (start > this.length) {
                  return ''
                }

                if (end === undefined || end > this.length) {
                  end = this.length
                }

                if (end <= 0) {
                  return ''
                }

                // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
                end >>>= 0
                start >>>= 0

                if (end <= start) {
                  return ''
                }

                if (!encoding) encoding = 'utf8'

                while (true) {
                  switch (encoding) {
                    case 'hex':
                      return hexSlice(this, start, end)

                    case 'utf8':
                    case 'utf-8':
                      return utf8Slice(this, start, end)

                    case 'ascii':
                      return asciiSlice(this, start, end)

                    case 'latin1':
                    case 'binary':
                      return latin1Slice(this, start, end)

                    case 'base64':
                      return base64Slice(this, start, end)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                      return utf16leSlice(this, start, end)

                    default:
                      if (loweredCase)
                        throw new TypeError('Unknown encoding: ' + encoding)
                      encoding = (encoding + '').toLowerCase()
                      loweredCase = true
                  }
                }
              }

              // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
              // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
              // reliably in a browserify context because there could be multiple different
              // copies of the 'buffer' package in use. This method works even for Buffer
              // instances that were created from another copy of the `buffer` package.
              // See: https://github.com/feross/buffer/issues/154
              Buffer.prototype._isBuffer = true

              function swap(b, n, m) {
                var i = b[n]
                b[n] = b[m]
                b[m] = i
              }

              Buffer.prototype.swap16 = function swap16() {
                var len = this.length
                if (len % 2 !== 0) {
                  throw new RangeError(
                    'Buffer size must be a multiple of 16-bits'
                  )
                }
                for (var i = 0; i < len; i += 2) {
                  swap(this, i, i + 1)
                }
                return this
              }

              Buffer.prototype.swap32 = function swap32() {
                var len = this.length
                if (len % 4 !== 0) {
                  throw new RangeError(
                    'Buffer size must be a multiple of 32-bits'
                  )
                }
                for (var i = 0; i < len; i += 4) {
                  swap(this, i, i + 3)
                  swap(this, i + 1, i + 2)
                }
                return this
              }

              Buffer.prototype.swap64 = function swap64() {
                var len = this.length
                if (len % 8 !== 0) {
                  throw new RangeError(
                    'Buffer size must be a multiple of 64-bits'
                  )
                }
                for (var i = 0; i < len; i += 8) {
                  swap(this, i, i + 7)
                  swap(this, i + 1, i + 6)
                  swap(this, i + 2, i + 5)
                  swap(this, i + 3, i + 4)
                }
                return this
              }

              Buffer.prototype.toString = function toString() {
                var length = this.length
                if (length === 0) return ''
                if (arguments.length === 0) return utf8Slice(this, 0, length)
                return slowToString.apply(this, arguments)
              }

              Buffer.prototype.toLocaleString = Buffer.prototype.toString

              Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b))
                  throw new TypeError('Argument must be a Buffer')
                if (this === b) return true
                return Buffer.compare(this, b) === 0
              }

              Buffer.prototype.inspect = function inspect() {
                var str = ''
                var max = exports.INSPECT_MAX_BYTES
                str = this.toString('hex', 0, max)
                  .replace(/(.{2})/g, '$1 ')
                  .trim()
                if (this.length > max) str += ' ... '
                return '<Buffer ' + str + '>'
              }

              Buffer.prototype.compare = function compare(
                target,
                start,
                end,
                thisStart,
                thisEnd
              ) {
                if (isInstance(target, Uint8Array)) {
                  target = Buffer.from(target, target.offset, target.byteLength)
                }
                if (!Buffer.isBuffer(target)) {
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. ' +
                      'Received type ' +
                      typeof target
                  )
                }

                if (start === undefined) {
                  start = 0
                }
                if (end === undefined) {
                  end = target ? target.length : 0
                }
                if (thisStart === undefined) {
                  thisStart = 0
                }
                if (thisEnd === undefined) {
                  thisEnd = this.length
                }

                if (
                  start < 0 ||
                  end > target.length ||
                  thisStart < 0 ||
                  thisEnd > this.length
                ) {
                  throw new RangeError('out of range index')
                }

                if (thisStart >= thisEnd && start >= end) {
                  return 0
                }
                if (thisStart >= thisEnd) {
                  return -1
                }
                if (start >= end) {
                  return 1
                }

                start >>>= 0
                end >>>= 0
                thisStart >>>= 0
                thisEnd >>>= 0

                if (this === target) return 0

                var x = thisEnd - thisStart
                var y = end - start
                var len = Math.min(x, y)

                var thisCopy = this.slice(thisStart, thisEnd)
                var targetCopy = target.slice(start, end)

                for (var i = 0; i < len; ++i) {
                  if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i]
                    y = targetCopy[i]
                    break
                  }
                }

                if (x < y) return -1
                if (y < x) return 1
                return 0
              }

              // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
              // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
              //
              // Arguments:
              // - buffer - a Buffer to search
              // - val - a string, Buffer, or number
              // - byteOffset - an index into `buffer`; will be clamped to an int32
              // - encoding - an optional encoding, relevant is val is a string
              // - dir - true for indexOf, false for lastIndexOf
              function bidirectionalIndexOf(
                buffer,
                val,
                byteOffset,
                encoding,
                dir
              ) {
                // Empty buffer means no match
                if (buffer.length === 0) return -1

                // Normalize byteOffset
                if (typeof byteOffset === 'string') {
                  encoding = byteOffset
                  byteOffset = 0
                } else if (byteOffset > 0x7fffffff) {
                  byteOffset = 0x7fffffff
                } else if (byteOffset < -0x80000000) {
                  byteOffset = -0x80000000
                }
                byteOffset = +byteOffset // Coerce to Number.
                if (numberIsNaN(byteOffset)) {
                  // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                  byteOffset = dir ? 0 : buffer.length - 1
                }

                // Normalize byteOffset: negative offsets start from the end of the buffer
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset
                if (byteOffset >= buffer.length) {
                  if (dir) return -1
                  else byteOffset = buffer.length - 1
                } else if (byteOffset < 0) {
                  if (dir) byteOffset = 0
                  else return -1
                }

                // Normalize val
                if (typeof val === 'string') {
                  val = Buffer.from(val, encoding)
                }

                // Finally, search either indexOf (if dir is true) or lastIndexOf
                if (Buffer.isBuffer(val)) {
                  // Special case: looking for empty string/buffer always fails
                  if (val.length === 0) {
                    return -1
                  }
                  return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
                } else if (typeof val === 'number') {
                  val = val & 0xff // Search for a byte value [0-255]
                  if (typeof Uint8Array.prototype.indexOf === 'function') {
                    if (dir) {
                      return Uint8Array.prototype.indexOf.call(
                        buffer,
                        val,
                        byteOffset
                      )
                    } else {
                      return Uint8Array.prototype.lastIndexOf.call(
                        buffer,
                        val,
                        byteOffset
                      )
                    }
                  }
                  return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
                }

                throw new TypeError('val must be string, number or Buffer')
              }

              function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1
                var arrLength = arr.length
                var valLength = val.length

                if (encoding !== undefined) {
                  encoding = String(encoding).toLowerCase()
                  if (
                    encoding === 'ucs2' ||
                    encoding === 'ucs-2' ||
                    encoding === 'utf16le' ||
                    encoding === 'utf-16le'
                  ) {
                    if (arr.length < 2 || val.length < 2) {
                      return -1
                    }
                    indexSize = 2
                    arrLength /= 2
                    valLength /= 2
                    byteOffset /= 2
                  }
                }

                function read(buf, i) {
                  if (indexSize === 1) {
                    return buf[i]
                  } else {
                    return buf.readUInt16BE(i * indexSize)
                  }
                }

                var i
                if (dir) {
                  var foundIndex = -1
                  for (i = byteOffset; i < arrLength; i++) {
                    if (
                      read(arr, i) ===
                      read(val, foundIndex === -1 ? 0 : i - foundIndex)
                    ) {
                      if (foundIndex === -1) foundIndex = i
                      if (i - foundIndex + 1 === valLength)
                        return foundIndex * indexSize
                    } else {
                      if (foundIndex !== -1) i -= i - foundIndex
                      foundIndex = -1
                    }
                  }
                } else {
                  if (byteOffset + valLength > arrLength)
                    byteOffset = arrLength - valLength
                  for (i = byteOffset; i >= 0; i--) {
                    var found = true
                    for (var j = 0; j < valLength; j++) {
                      if (read(arr, i + j) !== read(val, j)) {
                        found = false
                        break
                      }
                    }
                    if (found) return i
                  }
                }

                return -1
              }

              Buffer.prototype.includes = function includes(
                val,
                byteOffset,
                encoding
              ) {
                return this.indexOf(val, byteOffset, encoding) !== -1
              }

              Buffer.prototype.indexOf = function indexOf(
                val,
                byteOffset,
                encoding
              ) {
                return bidirectionalIndexOf(
                  this,
                  val,
                  byteOffset,
                  encoding,
                  true
                )
              }

              Buffer.prototype.lastIndexOf = function lastIndexOf(
                val,
                byteOffset,
                encoding
              ) {
                return bidirectionalIndexOf(
                  this,
                  val,
                  byteOffset,
                  encoding,
                  false
                )
              }

              function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0
                var remaining = buf.length - offset
                if (!length) {
                  length = remaining
                } else {
                  length = Number(length)
                  if (length > remaining) {
                    length = remaining
                  }
                }

                var strLen = string.length

                if (length > strLen / 2) {
                  length = strLen / 2
                }
                for (var i = 0; i < length; ++i) {
                  var parsed = parseInt(string.substr(i * 2, 2), 16)
                  if (numberIsNaN(parsed)) return i
                  buf[offset + i] = parsed
                }
                return i
              }

              function utf8Write(buf, string, offset, length) {
                return blitBuffer(
                  utf8ToBytes(string, buf.length - offset),
                  buf,
                  offset,
                  length
                )
              }

              function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length)
              }

              function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length)
              }

              function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length)
              }

              function ucs2Write(buf, string, offset, length) {
                return blitBuffer(
                  utf16leToBytes(string, buf.length - offset),
                  buf,
                  offset,
                  length
                )
              }

              Buffer.prototype.write = function write(
                string,
                offset,
                length,
                encoding
              ) {
                // Buffer#write(string)
                if (offset === undefined) {
                  encoding = 'utf8'
                  length = this.length
                  offset = 0
                  // Buffer#write(string, encoding)
                } else if (length === undefined && typeof offset === 'string') {
                  encoding = offset
                  length = this.length
                  offset = 0
                  // Buffer#write(string, offset[, length][, encoding])
                } else if (isFinite(offset)) {
                  offset = offset >>> 0
                  if (isFinite(length)) {
                    length = length >>> 0
                    if (encoding === undefined) encoding = 'utf8'
                  } else {
                    encoding = length
                    length = undefined
                  }
                } else {
                  throw new Error(
                    'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                  )
                }

                var remaining = this.length - offset
                if (length === undefined || length > remaining)
                  length = remaining

                if (
                  (string.length > 0 && (length < 0 || offset < 0)) ||
                  offset > this.length
                ) {
                  throw new RangeError('Attempt to write outside buffer bounds')
                }

                if (!encoding) encoding = 'utf8'

                var loweredCase = false
                for (;;) {
                  switch (encoding) {
                    case 'hex':
                      return hexWrite(this, string, offset, length)

                    case 'utf8':
                    case 'utf-8':
                      return utf8Write(this, string, offset, length)

                    case 'ascii':
                      return asciiWrite(this, string, offset, length)

                    case 'latin1':
                    case 'binary':
                      return latin1Write(this, string, offset, length)

                    case 'base64':
                      // Warning: maxLength not taken into account in base64Write
                      return base64Write(this, string, offset, length)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                      return ucs2Write(this, string, offset, length)

                    default:
                      if (loweredCase)
                        throw new TypeError('Unknown encoding: ' + encoding)
                      encoding = ('' + encoding).toLowerCase()
                      loweredCase = true
                  }
                }
              }

              Buffer.prototype.toJSON = function toJSON() {
                return {
                  type: 'Buffer',
                  data: Array.prototype.slice.call(this._arr || this, 0),
                }
              }

              function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                  return base64.fromByteArray(buf)
                } else {
                  return base64.fromByteArray(buf.slice(start, end))
                }
              }

              function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end)
                var res = []

                var i = start
                while (i < end) {
                  var firstByte = buf[i]
                  var codePoint = null
                  var bytesPerSequence =
                    firstByte > 0xef
                      ? 4
                      : firstByte > 0xdf
                      ? 3
                      : firstByte > 0xbf
                      ? 2
                      : 1

                  if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint

                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 0x80) {
                          codePoint = firstByte
                        }
                        break
                      case 2:
                        secondByte = buf[i + 1]
                        if ((secondByte & 0xc0) === 0x80) {
                          tempCodePoint =
                            ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f)
                          if (tempCodePoint > 0x7f) {
                            codePoint = tempCodePoint
                          }
                        }
                        break
                      case 3:
                        secondByte = buf[i + 1]
                        thirdByte = buf[i + 2]
                        if (
                          (secondByte & 0xc0) === 0x80 &&
                          (thirdByte & 0xc0) === 0x80
                        ) {
                          tempCodePoint =
                            ((firstByte & 0xf) << 0xc) |
                            ((secondByte & 0x3f) << 0x6) |
                            (thirdByte & 0x3f)
                          if (
                            tempCodePoint > 0x7ff &&
                            (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)
                          ) {
                            codePoint = tempCodePoint
                          }
                        }
                        break
                      case 4:
                        secondByte = buf[i + 1]
                        thirdByte = buf[i + 2]
                        fourthByte = buf[i + 3]
                        if (
                          (secondByte & 0xc0) === 0x80 &&
                          (thirdByte & 0xc0) === 0x80 &&
                          (fourthByte & 0xc0) === 0x80
                        ) {
                          tempCodePoint =
                            ((firstByte & 0xf) << 0x12) |
                            ((secondByte & 0x3f) << 0xc) |
                            ((thirdByte & 0x3f) << 0x6) |
                            (fourthByte & 0x3f)
                          if (
                            tempCodePoint > 0xffff &&
                            tempCodePoint < 0x110000
                          ) {
                            codePoint = tempCodePoint
                          }
                        }
                    }
                  }

                  if (codePoint === null) {
                    // we did not generate a valid codePoint so insert a
                    // replacement char (U+FFFD) and advance only 1 byte
                    codePoint = 0xfffd
                    bytesPerSequence = 1
                  } else if (codePoint > 0xffff) {
                    // encode to utf16 (surrogate pair dance)
                    codePoint -= 0x10000
                    res.push(((codePoint >>> 10) & 0x3ff) | 0xd800)
                    codePoint = 0xdc00 | (codePoint & 0x3ff)
                  }

                  res.push(codePoint)
                  i += bytesPerSequence
                }

                return decodeCodePointsArray(res)
              }

              // Based on http://stackoverflow.com/a/22747272/680742, the browser with
              // the lowest limit is Chrome, with 0x10000 args.
              // We go 1 magnitude less, for safety
              var MAX_ARGUMENTS_LENGTH = 0x1000

              function decodeCodePointsArray(codePoints) {
                var len = codePoints.length
                if (len <= MAX_ARGUMENTS_LENGTH) {
                  return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
                }

                // Decode in chunks to avoid "call stack size exceeded".
                var res = ''
                var i = 0
                while (i < len) {
                  res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
                  )
                }
                return res
              }

              function asciiSlice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i] & 0x7f)
                }
                return ret
              }

              function latin1Slice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)

                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i])
                }
                return ret
              }

              function hexSlice(buf, start, end) {
                var len = buf.length

                if (!start || start < 0) start = 0
                if (!end || end < 0 || end > len) end = len

                var out = ''
                for (var i = start; i < end; ++i) {
                  out += toHex(buf[i])
                }
                return out
              }

              function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end)
                var res = ''
                for (var i = 0; i < bytes.length; i += 2) {
                  res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
                }
                return res
              }

              Buffer.prototype.slice = function slice(start, end) {
                var len = this.length
                start = ~~start
                end = end === undefined ? len : ~~end

                if (start < 0) {
                  start += len
                  if (start < 0) start = 0
                } else if (start > len) {
                  start = len
                }

                if (end < 0) {
                  end += len
                  if (end < 0) end = 0
                } else if (end > len) {
                  end = len
                }

                if (end < start) end = start

                var newBuf = this.subarray(start, end)
                // Return an augmented `Uint8Array` instance
                newBuf.__proto__ = Buffer.prototype
                return newBuf
              }

              /*
               * Need to make sure that buffer isn't trying to write out of bounds.
               */
              function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0)
                  throw new RangeError('offset is not uint')
                if (offset + ext > length)
                  throw new RangeError('Trying to access beyond buffer length')
              }

              Buffer.prototype.readUIntLE = function readUIntLE(
                offset,
                byteLength,
                noAssert
              ) {
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                  val += this[offset + i] * mul
                }

                return val
              }

              Buffer.prototype.readUIntBE = function readUIntBE(
                offset,
                byteLength,
                noAssert
              ) {
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) {
                  checkOffset(offset, byteLength, this.length)
                }

                var val = this[offset + --byteLength]
                var mul = 1
                while (byteLength > 0 && (mul *= 0x100)) {
                  val += this[offset + --byteLength] * mul
                }

                return val
              }

              Buffer.prototype.readUInt8 = function readUInt8(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 1, this.length)
                return this[offset]
              }

              Buffer.prototype.readUInt16LE = function readUInt16LE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 2, this.length)
                return this[offset] | (this[offset + 1] << 8)
              }

              Buffer.prototype.readUInt16BE = function readUInt16BE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 2, this.length)
                return (this[offset] << 8) | this[offset + 1]
              }

              Buffer.prototype.readUInt32LE = function readUInt32LE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (
                  (this[offset] |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16)) +
                  this[offset + 3] * 0x1000000
                )
              }

              Buffer.prototype.readUInt32BE = function readUInt32BE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (
                  this[offset] * 0x1000000 +
                  ((this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    this[offset + 3])
                )
              }

              Buffer.prototype.readIntLE = function readIntLE(
                offset,
                byteLength,
                noAssert
              ) {
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                  val += this[offset + i] * mul
                }
                mul *= 0x80

                if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                return val
              }

              Buffer.prototype.readIntBE = function readIntBE(
                offset,
                byteLength,
                noAssert
              ) {
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)

                var i = byteLength
                var mul = 1
                var val = this[offset + --i]
                while (i > 0 && (mul *= 0x100)) {
                  val += this[offset + --i] * mul
                }
                mul *= 0x80

                if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                return val
              }

              Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 1, this.length)
                if (!(this[offset] & 0x80)) return this[offset]
                return (0xff - this[offset] + 1) * -1
              }

              Buffer.prototype.readInt16LE = function readInt16LE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset] | (this[offset + 1] << 8)
                return val & 0x8000 ? val | 0xffff0000 : val
              }

              Buffer.prototype.readInt16BE = function readInt16BE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset + 1] | (this[offset] << 8)
                return val & 0x8000 ? val | 0xffff0000 : val
              }

              Buffer.prototype.readInt32LE = function readInt32LE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (
                  this[offset] |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16) |
                  (this[offset + 3] << 24)
                )
              }

              Buffer.prototype.readInt32BE = function readInt32BE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)

                return (
                  (this[offset] << 24) |
                  (this[offset + 1] << 16) |
                  (this[offset + 2] << 8) |
                  this[offset + 3]
                )
              }

              Buffer.prototype.readFloatLE = function readFloatLE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, true, 23, 4)
              }

              Buffer.prototype.readFloatBE = function readFloatBE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, false, 23, 4)
              }

              Buffer.prototype.readDoubleLE = function readDoubleLE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, true, 52, 8)
              }

              Buffer.prototype.readDoubleBE = function readDoubleBE(
                offset,
                noAssert
              ) {
                offset = offset >>> 0
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, false, 52, 8)
              }

              function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf))
                  throw new TypeError(
                    '"buffer" argument must be a Buffer instance'
                  )
                if (value > max || value < min)
                  throw new RangeError('"value" argument is out of bounds')
                if (offset + ext > buf.length)
                  throw new RangeError('Index out of range')
              }

              Buffer.prototype.writeUIntLE = function writeUIntLE(
                value,
                offset,
                byteLength,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength) - 1
                  checkInt(this, value, offset, byteLength, maxBytes, 0)
                }

                var mul = 1
                var i = 0
                this[offset] = value & 0xff
                while (++i < byteLength && (mul *= 0x100)) {
                  this[offset + i] = (value / mul) & 0xff
                }

                return offset + byteLength
              }

              Buffer.prototype.writeUIntBE = function writeUIntBE(
                value,
                offset,
                byteLength,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                byteLength = byteLength >>> 0
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength) - 1
                  checkInt(this, value, offset, byteLength, maxBytes, 0)
                }

                var i = byteLength - 1
                var mul = 1
                this[offset + i] = value & 0xff
                while (--i >= 0 && (mul *= 0x100)) {
                  this[offset + i] = (value / mul) & 0xff
                }

                return offset + byteLength
              }

              Buffer.prototype.writeUInt8 = function writeUInt8(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
                this[offset] = value & 0xff
                return offset + 1
              }

              Buffer.prototype.writeUInt16LE = function writeUInt16LE(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                this[offset] = value & 0xff
                this[offset + 1] = value >>> 8
                return offset + 2
              }

              Buffer.prototype.writeUInt16BE = function writeUInt16BE(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                this[offset] = value >>> 8
                this[offset + 1] = value & 0xff
                return offset + 2
              }

              Buffer.prototype.writeUInt32LE = function writeUInt32LE(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                this[offset + 3] = value >>> 24
                this[offset + 2] = value >>> 16
                this[offset + 1] = value >>> 8
                this[offset] = value & 0xff
                return offset + 4
              }

              Buffer.prototype.writeUInt32BE = function writeUInt32BE(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                this[offset] = value >>> 24
                this[offset + 1] = value >>> 16
                this[offset + 2] = value >>> 8
                this[offset + 3] = value & 0xff
                return offset + 4
              }

              Buffer.prototype.writeIntLE = function writeIntLE(
                value,
                offset,
                byteLength,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength - 1)

                  checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }

                var i = 0
                var mul = 1
                var sub = 0
                this[offset] = value & 0xff
                while (++i < byteLength && (mul *= 0x100)) {
                  if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1
                  }
                  this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
                }

                return offset + byteLength
              }

              Buffer.prototype.writeIntBE = function writeIntBE(
                value,
                offset,
                byteLength,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength - 1)

                  checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }

                var i = byteLength - 1
                var mul = 1
                var sub = 0
                this[offset + i] = value & 0xff
                while (--i >= 0 && (mul *= 0x100)) {
                  if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1
                  }
                  this[offset + i] = (((value / mul) >> 0) - sub) & 0xff
                }

                return offset + byteLength
              }

              Buffer.prototype.writeInt8 = function writeInt8(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
                if (value < 0) value = 0xff + value + 1
                this[offset] = value & 0xff
                return offset + 1
              }

              Buffer.prototype.writeInt16LE = function writeInt16LE(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                this[offset] = value & 0xff
                this[offset + 1] = value >>> 8
                return offset + 2
              }

              Buffer.prototype.writeInt16BE = function writeInt16BE(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                this[offset] = value >>> 8
                this[offset + 1] = value & 0xff
                return offset + 2
              }

              Buffer.prototype.writeInt32LE = function writeInt32LE(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert)
                  checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                this[offset] = value & 0xff
                this[offset + 1] = value >>> 8
                this[offset + 2] = value >>> 16
                this[offset + 3] = value >>> 24
                return offset + 4
              }

              Buffer.prototype.writeInt32BE = function writeInt32BE(
                value,
                offset,
                noAssert
              ) {
                value = +value
                offset = offset >>> 0
                if (!noAssert)
                  checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (value < 0) value = 0xffffffff + value + 1
                this[offset] = value >>> 24
                this[offset + 1] = value >>> 16
                this[offset + 2] = value >>> 8
                this[offset + 3] = value & 0xff
                return offset + 4
              }

              function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length)
                  throw new RangeError('Index out of range')
                if (offset < 0) throw new RangeError('Index out of range')
              }

              function writeFloat(buf, value, offset, littleEndian, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) {
                  checkIEEE754(
                    buf,
                    value,
                    offset,
                    4,
                    3.4028234663852886e38,
                    -3.4028234663852886e38
                  )
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4)
                return offset + 4
              }

              Buffer.prototype.writeFloatLE = function writeFloatLE(
                value,
                offset,
                noAssert
              ) {
                return writeFloat(this, value, offset, true, noAssert)
              }

              Buffer.prototype.writeFloatBE = function writeFloatBE(
                value,
                offset,
                noAssert
              ) {
                return writeFloat(this, value, offset, false, noAssert)
              }

              function writeDouble(buf, value, offset, littleEndian, noAssert) {
                value = +value
                offset = offset >>> 0
                if (!noAssert) {
                  checkIEEE754(
                    buf,
                    value,
                    offset,
                    8,
                    1.7976931348623157e308,
                    -1.7976931348623157e308
                  )
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8)
                return offset + 8
              }

              Buffer.prototype.writeDoubleLE = function writeDoubleLE(
                value,
                offset,
                noAssert
              ) {
                return writeDouble(this, value, offset, true, noAssert)
              }

              Buffer.prototype.writeDoubleBE = function writeDoubleBE(
                value,
                offset,
                noAssert
              ) {
                return writeDouble(this, value, offset, false, noAssert)
              }

              // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
              Buffer.prototype.copy = function copy(
                target,
                targetStart,
                start,
                end
              ) {
                if (!Buffer.isBuffer(target))
                  throw new TypeError('argument should be a Buffer')
                if (!start) start = 0
                if (!end && end !== 0) end = this.length
                if (targetStart >= target.length) targetStart = target.length
                if (!targetStart) targetStart = 0
                if (end > 0 && end < start) end = start

                // Copy 0 bytes; we're done
                if (end === start) return 0
                if (target.length === 0 || this.length === 0) return 0

                // Fatal error conditions
                if (targetStart < 0) {
                  throw new RangeError('targetStart out of bounds')
                }
                if (start < 0 || start >= this.length)
                  throw new RangeError('Index out of range')
                if (end < 0) throw new RangeError('sourceEnd out of bounds')

                // Are we oob?
                if (end > this.length) end = this.length
                if (target.length - targetStart < end - start) {
                  end = target.length - targetStart + start
                }

                var len = end - start

                if (
                  this === target &&
                  typeof Uint8Array.prototype.copyWithin === 'function'
                ) {
                  // Use built-in when available, missing from IE11
                  this.copyWithin(targetStart, start, end)
                } else if (
                  this === target &&
                  start < targetStart &&
                  targetStart < end
                ) {
                  // descending copy from end
                  for (var i = len - 1; i >= 0; --i) {
                    target[i + targetStart] = this[i + start]
                  }
                } else {
                  Uint8Array.prototype.set.call(
                    target,
                    this.subarray(start, end),
                    targetStart
                  )
                }

                return len
              }

              // Usage:
              //    buffer.fill(number[, offset[, end]])
              //    buffer.fill(buffer[, offset[, end]])
              //    buffer.fill(string[, offset[, end]][, encoding])
              Buffer.prototype.fill = function fill(val, start, end, encoding) {
                // Handle string cases:
                if (typeof val === 'string') {
                  if (typeof start === 'string') {
                    encoding = start
                    start = 0
                    end = this.length
                  } else if (typeof end === 'string') {
                    encoding = end
                    end = this.length
                  }
                  if (encoding !== undefined && typeof encoding !== 'string') {
                    throw new TypeError('encoding must be a string')
                  }
                  if (
                    typeof encoding === 'string' &&
                    !Buffer.isEncoding(encoding)
                  ) {
                    throw new TypeError('Unknown encoding: ' + encoding)
                  }
                  if (val.length === 1) {
                    var code = val.charCodeAt(0)
                    if (
                      (encoding === 'utf8' && code < 128) ||
                      encoding === 'latin1'
                    ) {
                      // Fast path: If `val` fits into a single byte, use that numeric value.
                      val = code
                    }
                  }
                } else if (typeof val === 'number') {
                  val = val & 255
                }

                // Invalid ranges are not set to a default, so can range check early.
                if (start < 0 || this.length < start || this.length < end) {
                  throw new RangeError('Out of range index')
                }

                if (end <= start) {
                  return this
                }

                start = start >>> 0
                end = end === undefined ? this.length : end >>> 0

                if (!val) val = 0

                var i
                if (typeof val === 'number') {
                  for (i = start; i < end; ++i) {
                    this[i] = val
                  }
                } else {
                  var bytes = Buffer.isBuffer(val)
                    ? val
                    : Buffer.from(val, encoding)
                  var len = bytes.length
                  if (len === 0) {
                    throw new TypeError(
                      'The value "' + val + '" is invalid for argument "value"'
                    )
                  }
                  for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len]
                  }
                }

                return this
              }

              // HELPER FUNCTIONS
              // ================

              var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

              function base64clean(str) {
                // Node takes equal signs as end of the Base64 encoding
                str = str.split('=')[0]
                // Node strips out invalid characters like \n and \t from the string, base64-js does not
                str = str.trim().replace(INVALID_BASE64_RE, '')
                // Node converts strings with length < 2 to ''
                if (str.length < 2) return ''
                // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                while (str.length % 4 !== 0) {
                  str = str + '='
                }
                return str
              }

              function toHex(n) {
                if (n < 16) return '0' + n.toString(16)
                return n.toString(16)
              }

              function utf8ToBytes(string, units) {
                units = units || Infinity
                var codePoint
                var length = string.length
                var leadSurrogate = null
                var bytes = []

                for (var i = 0; i < length; ++i) {
                  codePoint = string.charCodeAt(i)

                  // is surrogate component
                  if (codePoint > 0xd7ff && codePoint < 0xe000) {
                    // last char was a lead
                    if (!leadSurrogate) {
                      // no lead yet
                      if (codePoint > 0xdbff) {
                        // unexpected trail
                        if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                        continue
                      } else if (i + 1 === length) {
                        // unpaired lead
                        if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                        continue
                      }

                      // valid lead
                      leadSurrogate = codePoint

                      continue
                    }

                    // 2 leads in a row
                    if (codePoint < 0xdc00) {
                      if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                      leadSurrogate = codePoint
                      continue
                    }

                    // valid surrogate pair
                    codePoint =
                      (((leadSurrogate - 0xd800) << 10) |
                        (codePoint - 0xdc00)) +
                      0x10000
                  } else if (leadSurrogate) {
                    // valid bmp char, but last char was a lead
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)
                  }

                  leadSurrogate = null

                  // encode utf8
                  if (codePoint < 0x80) {
                    if ((units -= 1) < 0) break
                    bytes.push(codePoint)
                  } else if (codePoint < 0x800) {
                    if ((units -= 2) < 0) break
                    bytes.push(
                      (codePoint >> 0x6) | 0xc0,
                      (codePoint & 0x3f) | 0x80
                    )
                  } else if (codePoint < 0x10000) {
                    if ((units -= 3) < 0) break
                    bytes.push(
                      (codePoint >> 0xc) | 0xe0,
                      ((codePoint >> 0x6) & 0x3f) | 0x80,
                      (codePoint & 0x3f) | 0x80
                    )
                  } else if (codePoint < 0x110000) {
                    if ((units -= 4) < 0) break
                    bytes.push(
                      (codePoint >> 0x12) | 0xf0,
                      ((codePoint >> 0xc) & 0x3f) | 0x80,
                      ((codePoint >> 0x6) & 0x3f) | 0x80,
                      (codePoint & 0x3f) | 0x80
                    )
                  } else {
                    throw new Error('Invalid code point')
                  }
                }

                return bytes
              }

              function asciiToBytes(str) {
                var byteArray = []
                for (var i = 0; i < str.length; ++i) {
                  // Node's code seems to be doing this and not & 0x7F..
                  byteArray.push(str.charCodeAt(i) & 0xff)
                }
                return byteArray
              }

              function utf16leToBytes(str, units) {
                var c, hi, lo
                var byteArray = []
                for (var i = 0; i < str.length; ++i) {
                  if ((units -= 2) < 0) break

                  c = str.charCodeAt(i)
                  hi = c >> 8
                  lo = c % 256
                  byteArray.push(lo)
                  byteArray.push(hi)
                }

                return byteArray
              }

              function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str))
              }

              function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                  if (i + offset >= dst.length || i >= src.length) break
                  dst[i + offset] = src[i]
                }
                return i
              }

              // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
              // the `instanceof` check but they should be treated as of that type.
              // See: https://github.com/feross/buffer/issues/166
              function isInstance(obj, type) {
                return (
                  obj instanceof type ||
                  (obj != null &&
                    obj.constructor != null &&
                    obj.constructor.name != null &&
                    obj.constructor.name === type.name)
                )
              }
              function numberIsNaN(obj) {
                // For IE11 support
                return obj !== obj // eslint-disable-line no-self-compare
              }
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { 'base64-js': 11, buffer: 18, ieee754: 20 },
      ],
      19: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          'use strict'

          var R = typeof Reflect === 'object' ? Reflect : null
          var ReflectApply =
            R && typeof R.apply === 'function'
              ? R.apply
              : function ReflectApply(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args)
                }

          var ReflectOwnKeys
          if (R && typeof R.ownKeys === 'function') {
            ReflectOwnKeys = R.ownKeys
          } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target).concat(
                Object.getOwnPropertySymbols(target)
              )
            }
          } else {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
              return Object.getOwnPropertyNames(target)
            }
          }

          function ProcessEmitWarning(warning) {
            if (console && console.warn) console.warn(warning)
          }

          var NumberIsNaN =
            Number.isNaN ||
            function NumberIsNaN(value) {
              return value !== value
            }

          function EventEmitter() {
            EventEmitter.init.call(this)
          }
          module.exports = EventEmitter
          module.exports.once = once

          // Backwards-compat with node 0.10.x
          EventEmitter.EventEmitter = EventEmitter

          EventEmitter.prototype._events = undefined
          EventEmitter.prototype._eventsCount = 0
          EventEmitter.prototype._maxListeners = undefined

          // By default EventEmitters will print a warning if more than 10 listeners are
          // added to it. This is a useful default which helps finding memory leaks.
          var defaultMaxListeners = 10

          function checkListener(listener) {
            if (typeof listener !== 'function') {
              throw new TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  typeof listener
              )
            }
          }

          Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
            enumerable: true,
            get: function () {
              return defaultMaxListeners
            },
            set: function (arg) {
              if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
                throw new RangeError(
                  'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                    arg +
                    '.'
                )
              }
              defaultMaxListeners = arg
            },
          })

          EventEmitter.init = function () {
            if (
              this._events === undefined ||
              this._events === Object.getPrototypeOf(this)._events
            ) {
              this._events = Object.create(null)
              this._eventsCount = 0
            }

            this._maxListeners = this._maxListeners || undefined
          }

          // Obviously not all Emitters should be limited to 10. This function allows
          // that to be increased. Set to zero for unlimited.
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
              throw new RangeError(
                'The value of "n" is out of range. It must be a non-negative number. Received ' +
                  n +
                  '.'
              )
            }
            this._maxListeners = n
            return this
          }

          function _getMaxListeners(that) {
            if (that._maxListeners === undefined)
              return EventEmitter.defaultMaxListeners
            return that._maxListeners
          }

          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this)
          }

          EventEmitter.prototype.emit = function emit(type) {
            var args = []
            for (var i = 1; i < arguments.length; i++) args.push(arguments[i])
            var doError = type === 'error'

            var events = this._events
            if (events !== undefined)
              doError = doError && events.error === undefined
            else if (!doError) return false

            // If there is no 'error' event listener then throw.
            if (doError) {
              var er
              if (args.length > 0) er = args[0]
              if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er // Unhandled 'error' event
              }
              // At least give some kind of context to the user
              var err = new Error(
                'Unhandled error.' + (er ? ' (' + er.message + ')' : '')
              )
              err.context = er
              throw err // Unhandled 'error' event
            }

            var handler = events[type]

            if (handler === undefined) return false

            if (typeof handler === 'function') {
              ReflectApply(handler, this, args)
            } else {
              var len = handler.length
              var listeners = arrayClone(handler, len)
              for (var i = 0; i < len; ++i)
                ReflectApply(listeners[i], this, args)
            }

            return true
          }

          function _addListener(target, type, listener, prepend) {
            var m
            var events
            var existing

            checkListener(listener)

            events = target._events
            if (events === undefined) {
              events = target._events = Object.create(null)
              target._eventsCount = 0
            } else {
              // To avoid recursion in the case that type === "newListener"! Before
              // adding it to the listeners, first emit "newListener".
              if (events.newListener !== undefined) {
                target.emit(
                  'newListener',
                  type,
                  listener.listener ? listener.listener : listener
                )

                // Re-assign `events` because a newListener handler could have caused the
                // this._events to be assigned to a new object
                events = target._events
              }
              existing = events[type]
            }

            if (existing === undefined) {
              // Optimize the case of one listener. Don't need the extra array object.
              existing = events[type] = listener
              ++target._eventsCount
            } else {
              if (typeof existing === 'function') {
                // Adding the second element, need to change to array.
                existing = events[type] = prepend
                  ? [listener, existing]
                  : [existing, listener]
                // If we've already got an array, just append.
              } else if (prepend) {
                existing.unshift(listener)
              } else {
                existing.push(listener)
              }

              // Check for listener leak
              m = _getMaxListeners(target)
              if (m > 0 && existing.length > m && !existing.warned) {
                existing.warned = true
                // No error code for this since it is a Warning
                // eslint-disable-next-line no-restricted-syntax
                var w = new Error(
                  'Possible EventEmitter memory leak detected. ' +
                    existing.length +
                    ' ' +
                    String(type) +
                    ' listeners ' +
                    'added. Use emitter.setMaxListeners() to ' +
                    'increase limit'
                )
                w.name = 'MaxListenersExceededWarning'
                w.emitter = target
                w.type = type
                w.count = existing.length
                ProcessEmitWarning(w)
              }
            }

            return target
          }

          EventEmitter.prototype.addListener = function addListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, false)
          }

          EventEmitter.prototype.on = EventEmitter.prototype.addListener

          EventEmitter.prototype.prependListener = function prependListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, true)
          }

          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn)
              this.fired = true
              if (arguments.length === 0) return this.listener.call(this.target)
              return this.listener.apply(this.target, arguments)
            }
          }

          function _onceWrap(target, type, listener) {
            var state = {
              fired: false,
              wrapFn: undefined,
              target: target,
              type: type,
              listener: listener,
            }
            var wrapped = onceWrapper.bind(state)
            wrapped.listener = listener
            state.wrapFn = wrapped
            return wrapped
          }

          EventEmitter.prototype.once = function once(type, listener) {
            checkListener(listener)
            this.on(type, _onceWrap(this, type, listener))
            return this
          }

          EventEmitter.prototype.prependOnceListener =
            function prependOnceListener(type, listener) {
              checkListener(listener)
              this.prependListener(type, _onceWrap(this, type, listener))
              return this
            }

          // Emits a 'removeListener' event if and only if the listener was removed.
          EventEmitter.prototype.removeListener = function removeListener(
            type,
            listener
          ) {
            var list, events, position, i, originalListener

            checkListener(listener)

            events = this._events
            if (events === undefined) return this

            list = events[type]
            if (list === undefined) return this

            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0) this._events = Object.create(null)
              else {
                delete events[type]
                if (events.removeListener)
                  this.emit('removeListener', type, list.listener || listener)
              }
            } else if (typeof list !== 'function') {
              position = -1

              for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                  originalListener = list[i].listener
                  position = i
                  break
                }
              }

              if (position < 0) return this

              if (position === 0) list.shift()
              else {
                spliceOne(list, position)
              }

              if (list.length === 1) events[type] = list[0]

              if (events.removeListener !== undefined)
                this.emit('removeListener', type, originalListener || listener)
            }

            return this
          }

          EventEmitter.prototype.off = EventEmitter.prototype.removeListener

          EventEmitter.prototype.removeAllListeners =
            function removeAllListeners(type) {
              var listeners, events, i

              events = this._events
              if (events === undefined) return this

              // not listening for removeListener, no need to emit
              if (events.removeListener === undefined) {
                if (arguments.length === 0) {
                  this._events = Object.create(null)
                  this._eventsCount = 0
                } else if (events[type] !== undefined) {
                  if (--this._eventsCount === 0)
                    this._events = Object.create(null)
                  else delete events[type]
                }
                return this
              }

              // emit removeListener for all listeners on all events
              if (arguments.length === 0) {
                var keys = Object.keys(events)
                var key
                for (i = 0; i < keys.length; ++i) {
                  key = keys[i]
                  if (key === 'removeListener') continue
                  this.removeAllListeners(key)
                }
                this.removeAllListeners('removeListener')
                this._events = Object.create(null)
                this._eventsCount = 0
                return this
              }

              listeners = events[type]

              if (typeof listeners === 'function') {
                this.removeListener(type, listeners)
              } else if (listeners !== undefined) {
                // LIFO order
                for (i = listeners.length - 1; i >= 0; i--) {
                  this.removeListener(type, listeners[i])
                }
              }

              return this
            }

          function _listeners(target, type, unwrap) {
            var events = target._events

            if (events === undefined) return []

            var evlistener = events[type]
            if (evlistener === undefined) return []

            if (typeof evlistener === 'function')
              return unwrap ? [evlistener.listener || evlistener] : [evlistener]

            return unwrap
              ? unwrapListeners(evlistener)
              : arrayClone(evlistener, evlistener.length)
          }

          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true)
          }

          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false)
          }

          EventEmitter.listenerCount = function (emitter, type) {
            if (typeof emitter.listenerCount === 'function') {
              return emitter.listenerCount(type)
            } else {
              return listenerCount.call(emitter, type)
            }
          }

          EventEmitter.prototype.listenerCount = listenerCount
          function listenerCount(type) {
            var events = this._events

            if (events !== undefined) {
              var evlistener = events[type]

              if (typeof evlistener === 'function') {
                return 1
              } else if (evlistener !== undefined) {
                return evlistener.length
              }
            }

            return 0
          }

          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
          }

          function arrayClone(arr, n) {
            var copy = new Array(n)
            for (var i = 0; i < n; ++i) copy[i] = arr[i]
            return copy
          }

          function spliceOne(list, index) {
            for (; index + 1 < list.length; index++)
              list[index] = list[index + 1]
            list.pop()
          }

          function unwrapListeners(arr) {
            var ret = new Array(arr.length)
            for (var i = 0; i < ret.length; ++i) {
              ret[i] = arr[i].listener || arr[i]
            }
            return ret
          }

          function once(emitter, name) {
            return new Promise(function (resolve, reject) {
              function errorListener(err) {
                emitter.removeListener(name, resolver)
                reject(err)
              }

              function resolver() {
                if (typeof emitter.removeListener === 'function') {
                  emitter.removeListener('error', errorListener)
                }
                resolve([].slice.call(arguments))
              }

              eventTargetAgnosticAddListener(emitter, name, resolver, {
                once: true,
              })
              if (name !== 'error') {
                addErrorHandlerIfEventEmitter(emitter, errorListener, {
                  once: true,
                })
              }
            })
          }

          function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
            if (typeof emitter.on === 'function') {
              eventTargetAgnosticAddListener(emitter, 'error', handler, flags)
            }
          }

          function eventTargetAgnosticAddListener(
            emitter,
            name,
            listener,
            flags
          ) {
            if (typeof emitter.on === 'function') {
              if (flags.once) {
                emitter.once(name, listener)
              } else {
                emitter.on(name, listener)
              }
            } else if (typeof emitter.addEventListener === 'function') {
              // EventTarget does not have `error` event semantics like Node
              // EventEmitters, we do not listen for `error` events here.
              emitter.addEventListener(name, function wrapListener(arg) {
                // IE does not have builtin `{ once: true }` support so we
                // have to do it manually.
                if (flags.once) {
                  emitter.removeEventListener(name, wrapListener)
                }
                listener(arg)
              })
            } else {
              throw new TypeError(
                'The "emitter" argument must be of type EventEmitter. Received type ' +
                  typeof emitter
              )
            }
          }
        },
        {},
      ],
      20: [
        function (require, module, exports) {
          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
          exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var nBits = -7
            var i = isLE ? nBytes - 1 : 0
            var d = isLE ? -1 : 1
            var s = buffer[offset + i]

            i += d

            e = s & ((1 << -nBits) - 1)
            s >>= -nBits
            nBits += eLen
            for (
              ;
              nBits > 0;
              e = e * 256 + buffer[offset + i], i += d, nBits -= 8
            ) {}

            m = e & ((1 << -nBits) - 1)
            e >>= -nBits
            nBits += mLen
            for (
              ;
              nBits > 0;
              m = m * 256 + buffer[offset + i], i += d, nBits -= 8
            ) {}

            if (e === 0) {
              e = 1 - eBias
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity
            } else {
              m = m + Math.pow(2, mLen)
              e = e - eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
          }

          exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0
            var i = isLE ? 0 : nBytes - 1
            var d = isLE ? 1 : -1
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

            value = Math.abs(value)

            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0
              e = eMax
            } else {
              e = Math.floor(Math.log(value) / Math.LN2)
              if (value * (c = Math.pow(2, -e)) < 1) {
                e--
                c *= 2
              }
              if (e + eBias >= 1) {
                value += rt / c
              } else {
                value += rt * Math.pow(2, 1 - eBias)
              }
              if (value * c >= 2) {
                e++
                c /= 2
              }

              if (e + eBias >= eMax) {
                m = 0
                e = eMax
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen)
                e = e + eBias
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                e = 0
              }
            }

            for (
              ;
              mLen >= 8;
              buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8
            ) {}

            e = (e << mLen) | m
            eLen += mLen
            for (
              ;
              eLen > 0;
              buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8
            ) {}

            buffer[offset + i - d] |= s * 128
          }
        },
        {},
      ],
      21: [
        function (require, module, exports) {
          if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true,
                  },
                })
              }
            }
          } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () {}
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
              }
            }
          }
        },
        {},
      ],
      22: [
        function (require, module, exports) {
          var backslash = require('backslash')
          module.exports = {
            validate: validate,
            parse: parse,
          }

          /**
           * Validates a json string.
           * Errors are returned
           * @param jsonString
           * @param allowDuplicatedKeys
           * @returns {String} error. undefined if no error
           */
          function validate(jsonString, allowDuplicatedKeys) {
            var error
            allowDuplicatedKeys = allowDuplicatedKeys || false
            if (typeof jsonString !== 'string') {
              error = 'Input must be a string'
            } else {
              try {
                // Try to find a value starting from index 0
                _findValue(jsonString, 0, allowDuplicatedKeys, false)
              } catch (e) {
                error = e.message
              }
            }
            return error
          }

          /**
           * Parses a json. Errors are thrown if any
           * @param jsonString
           * @param allowDuplicatedKeys
           * @returns {Object}
           */
          function parse(jsonString, allowDuplicatedKeys) {
            if (typeof jsonString !== 'string') {
              throw new Error('Input must be a string')
            }

            allowDuplicatedKeys = allowDuplicatedKeys || false

            // Try to find a value starting from index 0
            var value = _findValue(jsonString, 0, allowDuplicatedKeys, true)
            return value.value
          }

          /**
           * Find the comma separator, ], } or end of file
           * @param {String} str - original json string
           * @param {Number} startInd - starting index
           * @returns {{start: Number, end: Number, value: String}} value: the separator found
           * @private
           */
          function _findSeparator(str, startInd) {
            var len = str.length
            var sepStartInd = startInd
            var sepEndInd
            for (var i = startInd; i < len; i++) {
              var ch = str[i]
              if (ch === ',') {
                sepEndInd = i
                break
              } else if (ch === ']' || ch === '}') {
                sepEndInd = i - 1
                break
              } else if (!_isWhiteSpace(ch)) {
                throw _syntaxError(
                  str,
                  i,
                  'expecting end of expression or separator'
                )
              }
            }

            var value
            if (sepEndInd === undefined) {
              sepEndInd = len
              value = str[sepEndInd]
            } else {
              value = str[sepEndInd]
              sepEndInd++
            }
            return {
              start: sepStartInd,
              end: sepEndInd,
              value: value,
            }
          }

          /**
           * Find the semi-colon separator ':'
           * @param {String} str - original json string
           * @param {Number} startInd
           * @returns {{start: Number, end: Number}}
           * @private
           */
          function _findSemiColonSeparator(str, startInd) {
            var len = str.length
            var semiColStartInd = startInd
            var semiColEndInd
            for (var i = startInd; i < len; i++) {
              var ch = str[i]
              if (ch === ':') {
                semiColEndInd = i
                break
              } else if (!_isWhiteSpace(ch)) {
                throw _syntaxError(str, i, "expecting ':'")
              }
            }
            if (semiColEndInd === undefined) {
              throw _syntaxError(str, i, "expecting ':'")
            }
            semiColEndInd++
            return {
              start: semiColStartInd,
              end: semiColEndInd,
            }
          }

          /**
           * Find a value it can be number, array, object, strings or boolean
           * @param {String} str - original json string
           * @param {Number} startInd
           * @param {Boolean} allowDuplicatedKeys - allow duplicated keys in objects or not
           * @returns {{value: *, start: Number, end: Number}}
           * @private
           */
          function _findValue(str, startInd, allowDuplicatedKeys, parse) {
            var len = str.length
            var valueStartInd
            var valueEndInd
            var isArray = false
            var isObject = false
            var isString = false
            var isNumber = false
            var dotFound = false
            var whiteSpaceInNumber = false
            var value

            for (var i = startInd; i < len; i++) {
              var ch = str[i]
              if (valueStartInd === undefined) {
                if (!_isWhiteSpace(ch)) {
                  if (ch === '[') {
                    isArray = true
                  } else if (ch === '{') {
                    isObject = true
                  } else if (ch === '"') {
                    isString = true
                  } else if (_isTrueFromIndex(str, i)) {
                    valueStartInd = i
                    i = i + 3
                    valueEndInd = i
                    value = true
                    break
                  } else if (_isFalseFromIndex(str, i)) {
                    valueStartInd = i
                    i = i + 4
                    valueEndInd = i
                    value = false
                    break
                  } else if (_isNullFromIndex(str, i)) {
                    valueStartInd = i
                    i = i + 3
                    valueEndInd = i
                    value = null
                    break
                  } else if (_isNumber(ch)) {
                    isNumber = true
                  } else if (ch === '-') {
                    isNumber = true
                  } else {
                    throw _syntaxError(str, i, '')
                  }
                  valueStartInd = i
                }
              } else {
                if (isArray) {
                  var arr = _findArray(str, i, allowDuplicatedKeys, parse)
                  valueEndInd = arr.end
                  value = arr.value
                  break
                } else if (isObject) {
                  var obj = _findObject(str, i, allowDuplicatedKeys, parse)
                  valueEndInd = obj.end
                  value = obj.value
                  break
                } else if (
                  isString &&
                  ch === '"' &&
                  _hasEvenNumberOfBackSlash(str, i - 1)
                ) {
                  valueEndInd = i
                  value = backslash(
                    str.substring(valueStartInd + 1, valueEndInd)
                  )
                  break
                } else if (isNumber) {
                  if (_isWhiteSpace(ch)) {
                    whiteSpaceInNumber = true
                  } else if (ch === ',' || ch === ']' || ch === '}') {
                    value = parseFloat(
                      str.substring(valueStartInd, valueEndInd),
                      10
                    )
                    valueEndInd = i - 1
                    break
                  } else if (_isNumber(ch) && !whiteSpaceInNumber) {
                    continue
                  } else if (ch === '.' && !dotFound && !whiteSpaceInNumber) {
                    dotFound = true
                  } else {
                    throw _syntaxError(str, i, 'expecting number')
                  }
                }
              }
            }

            if (valueEndInd === undefined) {
              if (isNumber) {
                value = parseFloat(str.substring(valueStartInd, i), 10)
                valueEndInd = i - 1
              } else {
                throw _syntaxError(str, i, 'unclosed statement')
              }
            }
            valueEndInd++
            return {
              value: value,
              start: valueStartInd,
              end: valueEndInd,
            }
          }

          /**
           * Find a key in an object
           * @param {String} str - original json string
           * @param {Number} startInd
           * @returns {{start: Number, end: Number, value: String}}
           * @private
           */
          function _findKey(str, startInd) {
            var len = str.length
            var keyStartInd
            var keyEndInd
            for (var i = startInd; i < len; i++) {
              var ch = str[i]
              if (keyStartInd === undefined) {
                if (!_isWhiteSpace(ch)) {
                  if (ch !== '"') {
                    throw _syntaxError(str, i, 'expecting String')
                  }
                  keyStartInd = i
                }
              } else {
                if (ch === '"' && _hasEvenNumberOfBackSlash(str, i - 1)) {
                  keyEndInd = i
                  break
                }
              }
            }

            if (keyEndInd === undefined) {
              throw _syntaxError(str, len, 'expecting String')
            }

            var value = backslash(str.substring(keyStartInd + 1, keyEndInd))
            if (value === '') {
              throw _syntaxError(str, keyStartInd, 'empty string')
            }
            keyEndInd++
            return {
              start: keyStartInd,
              end: keyEndInd,
              value: value,
            }
          }

          /**
           * Find an object by identifying the key, ':' separator and value
           * @param {String} str - original json string
           * @param {Number} startInd
           * @param {Boolean} allowDuplicatedKeys
           * @returns {{start: Number, end: Number, value: Object}}
           * @private
           */
          function _findObject(str, startInd, allowDuplicatedKeys, parse) {
            var i = startInd
            var sepValue = ','
            var obj = {}
            var keys = []
            var values = []

            var j = startInd
            while (_isWhiteSpace(str[j])) {
              j++
            }

            if (str[j] === '}') {
              return {
                start: startInd,
                end: j,
                value: obj,
              }
            }

            while (sepValue === ',') {
              var key = _findKey(str, i)
              var semi = _findSemiColonSeparator(str, key.end)
              var value = _findValue(str, semi.end, allowDuplicatedKeys, parse)
              var sepIndex = _findSeparator(str, value.end)

              if (!allowDuplicatedKeys) {
                if (keys.indexOf(key.value) !== -1) {
                  key.value = key.value + '1'
                  // throw _syntaxError(str, key.end, 'duplicated keys "' + key.value + '"');
                }
              }
              keys.push(key.value)
              values.push(value.value)
              i = sepIndex.end
              sepValue = sepIndex.value
            }

            if (parse) {
              var indx = 0
              for (indx = 0; indx < keys.length; indx++) {
                obj[keys[indx]] = values[indx]
              }
            }

            return {
              start: startInd,
              end: i,
              value: obj,
            }
          }

          /**
           * Going backward from an index, determine if there are even number
           * of consecutive backslashes in the string
           * @param {String} str - original json string
           * @param {Number} endInd
           * @returns {Boolean}
           * @private
           */
          function _hasEvenNumberOfBackSlash(str, endInd) {
            var i = endInd
            var count = 0
            while (i > -1 && str[i] === '\\') {
              count++
              i--
            }
            return count % 2 === 0
          }

          /**
           * Find an array by identifying values separated by ',' separator
           * @param {String} str - original json string
           * @param {Number} startInd
           * @returns {{start: Number, end: Number, value: Array}}
           * @private
           */
          function _findArray(str, startInd, allowDuplicatedKeys, parse) {
            var i = startInd
            var sepValue = ','
            var arr = []

            var j = startInd
            while (_isWhiteSpace(str[j])) {
              j++
            }

            if (str[j] === ']') {
              return {
                start: startInd,
                end: j,
                value: arr,
              }
            }

            while (sepValue === ',') {
              var value = _findValue(str, i, allowDuplicatedKeys, parse)
              var sepIndex = _findSeparator(str, value.end)

              if (parse) {
                arr.push(value.value)
              }
              i = sepIndex.end
              sepValue = sepIndex.value
            }
            return {
              start: startInd,
              end: i,
              value: arr,
            }
          }

          /**
           * Determine if the string is 'true' from specified index
           * @param {String} str - original json string
           * @param {Number} ind
           * @returns {Boolean}
           * @private
           */
          function _isTrueFromIndex(str, ind) {
            return str.substr(ind, 4) === 'true'
          }

          /**
           * Determine if the string is 'false' from specified index
           * @param {String} str - original json string
           * @param {Number} ind
           * @returns {Boolean}
           * @private
           */
          function _isFalseFromIndex(str, ind) {
            return str.substr(ind, 5) === 'false'
          }

          /**
           * Determine if the string is 'null' from specified index
           * @param {String} str - original json string
           * @param {Number} ind
           * @returns {Boolean}
           * @private
           */
          function _isNullFromIndex(str, ind) {
            return str.substr(ind, 4) === 'null'
          }

          var white = new RegExp(/^\s$/)
          /**
           * Determine if this character is a white space
           * @param {String} ch - single character string
           * @returns {Boolean}
           * @private
           */
          function _isWhiteSpace(ch) {
            return white.test(ch)
          }

          var numberReg = new RegExp(/^\d$/)
          /**
           * Determine if this character is a numeric character
           * @param {String} ch - single character string
           * @returns {Boolean}
           * @private
           */
          function _isNumber(ch) {
            return numberReg.test(ch)
          }

          /**
           * Generate syntax error
           * @param {String} str - original json string
           * @param {Number} index - index in which the error was detected
           * @param {String} reason
           * @returns {Error}
           * @private
           */
          function _syntaxError(str, index, reason) {
            var regionLen = 10

            var regionStr
            if (str.length < index + regionLen) {
              regionStr = str.substr(
                _normalizeNegativeNumber(str.length - regionLen),
                str.length
              )
            } else if (index - regionLen / 2 < 0) {
              regionStr = str.substr(0, regionLen)
            } else {
              regionStr = str.substr(
                _normalizeNegativeNumber(index - regionLen / 2),
                regionLen
              )
            }

            var message
            if (reason) {
              message = 'Syntax error: ' + reason + ' near ' + regionStr
            } else {
              message = 'Syntax error near ' + regionStr
            }
            return new Error(message)
          }

          /**
           * Return 0 if number is negative, the original number otherwise
           * @param {Number} num
           * @returns {Number}
           * @private
           */
          function _normalizeNegativeNumber(num) {
            return num < 0 ? 0 : num
          }
        },
        { backslash: 10 },
      ],
      23: [
        function (require, module, exports) {
          module.exports = require('./lib/api')(require('./lib/keccak'))
        },
        { './lib/api': 24, './lib/keccak': 28 },
      ],
      24: [
        function (require, module, exports) {
          const createKeccak = require('./keccak')
          const createShake = require('./shake')

          module.exports = function (KeccakState) {
            const Keccak = createKeccak(KeccakState)
            const Shake = createShake(KeccakState)

            return function (algorithm, options) {
              const hash =
                typeof algorithm === 'string'
                  ? algorithm.toLowerCase()
                  : algorithm
              switch (hash) {
                case 'keccak224':
                  return new Keccak(1152, 448, null, 224, options)
                case 'keccak256':
                  return new Keccak(1088, 512, null, 256, options)
                case 'keccak384':
                  return new Keccak(832, 768, null, 384, options)
                case 'keccak512':
                  return new Keccak(576, 1024, null, 512, options)

                case 'sha3-224':
                  return new Keccak(1152, 448, 0x06, 224, options)
                case 'sha3-256':
                  return new Keccak(1088, 512, 0x06, 256, options)
                case 'sha3-384':
                  return new Keccak(832, 768, 0x06, 384, options)
                case 'sha3-512':
                  return new Keccak(576, 1024, 0x06, 512, options)

                case 'shake128':
                  return new Shake(1344, 256, 0x1f, options)
                case 'shake256':
                  return new Shake(1088, 512, 0x1f, options)

                default:
                  throw new Error('Invald algorithm: ' + algorithm)
              }
            }
          }
        },
        { './keccak': 25, './shake': 26 },
      ],
      25: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              const { Transform } = require('readable-stream')

              module.exports = (KeccakState) =>
                class Keccak extends Transform {
                  constructor(
                    rate,
                    capacity,
                    delimitedSuffix,
                    hashBitLength,
                    options
                  ) {
                    super(options)

                    this._rate = rate
                    this._capacity = capacity
                    this._delimitedSuffix = delimitedSuffix
                    this._hashBitLength = hashBitLength
                    this._options = options

                    this._state = new KeccakState()
                    this._state.initialize(rate, capacity)
                    this._finalized = false
                  }

                  _transform(chunk, encoding, callback) {
                    let error = null
                    try {
                      this.update(chunk, encoding)
                    } catch (err) {
                      error = err
                    }

                    callback(error)
                  }

                  _flush(callback) {
                    let error = null
                    try {
                      this.push(this.digest())
                    } catch (err) {
                      error = err
                    }

                    callback(error)
                  }

                  update(data, encoding) {
                    if (!Buffer.isBuffer(data) && typeof data !== 'string')
                      throw new TypeError('Data must be a string or a buffer')
                    if (this._finalized)
                      throw new Error('Digest already called')
                    if (!Buffer.isBuffer(data))
                      data = Buffer.from(data, encoding)

                    this._state.absorb(data)

                    return this
                  }

                  digest(encoding) {
                    if (this._finalized)
                      throw new Error('Digest already called')
                    this._finalized = true

                    if (this._delimitedSuffix)
                      this._state.absorbLastFewBits(this._delimitedSuffix)
                    let digest = this._state.squeeze(this._hashBitLength / 8)
                    if (encoding !== undefined)
                      digest = digest.toString(encoding)

                    this._resetState()

                    return digest
                  }

                  // remove result from memory
                  _resetState() {
                    this._state.initialize(this._rate, this._capacity)
                    return this
                  }

                  // because sometimes we need hash right now and little later
                  _clone() {
                    const clone = new Keccak(
                      this._rate,
                      this._capacity,
                      this._delimitedSuffix,
                      this._hashBitLength,
                      this._options
                    )
                    this._state.copy(clone._state)
                    clone._finalized = this._finalized

                    return clone
                  }
                }
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { buffer: 18, 'readable-stream': 43 },
      ],
      26: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              const { Transform } = require('readable-stream')

              module.exports = (KeccakState) =>
                class Shake extends Transform {
                  constructor(rate, capacity, delimitedSuffix, options) {
                    super(options)

                    this._rate = rate
                    this._capacity = capacity
                    this._delimitedSuffix = delimitedSuffix
                    this._options = options

                    this._state = new KeccakState()
                    this._state.initialize(rate, capacity)
                    this._finalized = false
                  }

                  _transform(chunk, encoding, callback) {
                    let error = null
                    try {
                      this.update(chunk, encoding)
                    } catch (err) {
                      error = err
                    }

                    callback(error)
                  }

                  _flush() {}

                  _read(size) {
                    this.push(this.squeeze(size))
                  }

                  update(data, encoding) {
                    if (!Buffer.isBuffer(data) && typeof data !== 'string')
                      throw new TypeError('Data must be a string or a buffer')
                    if (this._finalized)
                      throw new Error('Squeeze already called')
                    if (!Buffer.isBuffer(data))
                      data = Buffer.from(data, encoding)

                    this._state.absorb(data)

                    return this
                  }

                  squeeze(dataByteLength, encoding) {
                    if (!this._finalized) {
                      this._finalized = true
                      this._state.absorbLastFewBits(this._delimitedSuffix)
                    }

                    let data = this._state.squeeze(dataByteLength)
                    if (encoding !== undefined) data = data.toString(encoding)

                    return data
                  }

                  _resetState() {
                    this._state.initialize(this._rate, this._capacity)
                    return this
                  }

                  _clone() {
                    const clone = new Shake(
                      this._rate,
                      this._capacity,
                      this._delimitedSuffix,
                      this._options
                    )
                    this._state.copy(clone._state)
                    clone._finalized = this._finalized

                    return clone
                  }
                }
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { buffer: 18, 'readable-stream': 43 },
      ],
      27: [
        function (require, module, exports) {
          const P1600_ROUND_CONSTANTS = [
            1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
            2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0,
            136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139,
            2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648,
            128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545,
            2147483648, 32896, 2147483648, 2147483649, 0, 2147516424,
            2147483648,
          ]

          exports.p1600 = function (s) {
            for (let round = 0; round < 24; ++round) {
              // theta
              const lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]
              const hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]
              const lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]
              const hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]
              const lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]
              const hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]
              const lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]
              const hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]
              const lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]
              const hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]

              let lo = lo4 ^ ((lo1 << 1) | (hi1 >>> 31))
              let hi = hi4 ^ ((hi1 << 1) | (lo1 >>> 31))
              const t1slo0 = s[0] ^ lo
              const t1shi0 = s[1] ^ hi
              const t1slo5 = s[10] ^ lo
              const t1shi5 = s[11] ^ hi
              const t1slo10 = s[20] ^ lo
              const t1shi10 = s[21] ^ hi
              const t1slo15 = s[30] ^ lo
              const t1shi15 = s[31] ^ hi
              const t1slo20 = s[40] ^ lo
              const t1shi20 = s[41] ^ hi
              lo = lo0 ^ ((lo2 << 1) | (hi2 >>> 31))
              hi = hi0 ^ ((hi2 << 1) | (lo2 >>> 31))
              const t1slo1 = s[2] ^ lo
              const t1shi1 = s[3] ^ hi
              const t1slo6 = s[12] ^ lo
              const t1shi6 = s[13] ^ hi
              const t1slo11 = s[22] ^ lo
              const t1shi11 = s[23] ^ hi
              const t1slo16 = s[32] ^ lo
              const t1shi16 = s[33] ^ hi
              const t1slo21 = s[42] ^ lo
              const t1shi21 = s[43] ^ hi
              lo = lo1 ^ ((lo3 << 1) | (hi3 >>> 31))
              hi = hi1 ^ ((hi3 << 1) | (lo3 >>> 31))
              const t1slo2 = s[4] ^ lo
              const t1shi2 = s[5] ^ hi
              const t1slo7 = s[14] ^ lo
              const t1shi7 = s[15] ^ hi
              const t1slo12 = s[24] ^ lo
              const t1shi12 = s[25] ^ hi
              const t1slo17 = s[34] ^ lo
              const t1shi17 = s[35] ^ hi
              const t1slo22 = s[44] ^ lo
              const t1shi22 = s[45] ^ hi
              lo = lo2 ^ ((lo4 << 1) | (hi4 >>> 31))
              hi = hi2 ^ ((hi4 << 1) | (lo4 >>> 31))
              const t1slo3 = s[6] ^ lo
              const t1shi3 = s[7] ^ hi
              const t1slo8 = s[16] ^ lo
              const t1shi8 = s[17] ^ hi
              const t1slo13 = s[26] ^ lo
              const t1shi13 = s[27] ^ hi
              const t1slo18 = s[36] ^ lo
              const t1shi18 = s[37] ^ hi
              const t1slo23 = s[46] ^ lo
              const t1shi23 = s[47] ^ hi
              lo = lo3 ^ ((lo0 << 1) | (hi0 >>> 31))
              hi = hi3 ^ ((hi0 << 1) | (lo0 >>> 31))
              const t1slo4 = s[8] ^ lo
              const t1shi4 = s[9] ^ hi
              const t1slo9 = s[18] ^ lo
              const t1shi9 = s[19] ^ hi
              const t1slo14 = s[28] ^ lo
              const t1shi14 = s[29] ^ hi
              const t1slo19 = s[38] ^ lo
              const t1shi19 = s[39] ^ hi
              const t1slo24 = s[48] ^ lo
              const t1shi24 = s[49] ^ hi

              // rho & pi
              const t2slo0 = t1slo0
              const t2shi0 = t1shi0
              const t2slo16 = (t1shi5 << 4) | (t1slo5 >>> 28)
              const t2shi16 = (t1slo5 << 4) | (t1shi5 >>> 28)
              const t2slo7 = (t1slo10 << 3) | (t1shi10 >>> 29)
              const t2shi7 = (t1shi10 << 3) | (t1slo10 >>> 29)
              const t2slo23 = (t1shi15 << 9) | (t1slo15 >>> 23)
              const t2shi23 = (t1slo15 << 9) | (t1shi15 >>> 23)
              const t2slo14 = (t1slo20 << 18) | (t1shi20 >>> 14)
              const t2shi14 = (t1shi20 << 18) | (t1slo20 >>> 14)
              const t2slo10 = (t1slo1 << 1) | (t1shi1 >>> 31)
              const t2shi10 = (t1shi1 << 1) | (t1slo1 >>> 31)
              const t2slo1 = (t1shi6 << 12) | (t1slo6 >>> 20)
              const t2shi1 = (t1slo6 << 12) | (t1shi6 >>> 20)
              const t2slo17 = (t1slo11 << 10) | (t1shi11 >>> 22)
              const t2shi17 = (t1shi11 << 10) | (t1slo11 >>> 22)
              const t2slo8 = (t1shi16 << 13) | (t1slo16 >>> 19)
              const t2shi8 = (t1slo16 << 13) | (t1shi16 >>> 19)
              const t2slo24 = (t1slo21 << 2) | (t1shi21 >>> 30)
              const t2shi24 = (t1shi21 << 2) | (t1slo21 >>> 30)
              const t2slo20 = (t1shi2 << 30) | (t1slo2 >>> 2)
              const t2shi20 = (t1slo2 << 30) | (t1shi2 >>> 2)
              const t2slo11 = (t1slo7 << 6) | (t1shi7 >>> 26)
              const t2shi11 = (t1shi7 << 6) | (t1slo7 >>> 26)
              const t2slo2 = (t1shi12 << 11) | (t1slo12 >>> 21)
              const t2shi2 = (t1slo12 << 11) | (t1shi12 >>> 21)
              const t2slo18 = (t1slo17 << 15) | (t1shi17 >>> 17)
              const t2shi18 = (t1shi17 << 15) | (t1slo17 >>> 17)
              const t2slo9 = (t1shi22 << 29) | (t1slo22 >>> 3)
              const t2shi9 = (t1slo22 << 29) | (t1shi22 >>> 3)
              const t2slo5 = (t1slo3 << 28) | (t1shi3 >>> 4)
              const t2shi5 = (t1shi3 << 28) | (t1slo3 >>> 4)
              const t2slo21 = (t1shi8 << 23) | (t1slo8 >>> 9)
              const t2shi21 = (t1slo8 << 23) | (t1shi8 >>> 9)
              const t2slo12 = (t1slo13 << 25) | (t1shi13 >>> 7)
              const t2shi12 = (t1shi13 << 25) | (t1slo13 >>> 7)
              const t2slo3 = (t1slo18 << 21) | (t1shi18 >>> 11)
              const t2shi3 = (t1shi18 << 21) | (t1slo18 >>> 11)
              const t2slo19 = (t1shi23 << 24) | (t1slo23 >>> 8)
              const t2shi19 = (t1slo23 << 24) | (t1shi23 >>> 8)
              const t2slo15 = (t1slo4 << 27) | (t1shi4 >>> 5)
              const t2shi15 = (t1shi4 << 27) | (t1slo4 >>> 5)
              const t2slo6 = (t1slo9 << 20) | (t1shi9 >>> 12)
              const t2shi6 = (t1shi9 << 20) | (t1slo9 >>> 12)
              const t2slo22 = (t1shi14 << 7) | (t1slo14 >>> 25)
              const t2shi22 = (t1slo14 << 7) | (t1shi14 >>> 25)
              const t2slo13 = (t1slo19 << 8) | (t1shi19 >>> 24)
              const t2shi13 = (t1shi19 << 8) | (t1slo19 >>> 24)
              const t2slo4 = (t1slo24 << 14) | (t1shi24 >>> 18)
              const t2shi4 = (t1shi24 << 14) | (t1slo24 >>> 18)

              // chi
              s[0] = t2slo0 ^ (~t2slo1 & t2slo2)
              s[1] = t2shi0 ^ (~t2shi1 & t2shi2)
              s[10] = t2slo5 ^ (~t2slo6 & t2slo7)
              s[11] = t2shi5 ^ (~t2shi6 & t2shi7)
              s[20] = t2slo10 ^ (~t2slo11 & t2slo12)
              s[21] = t2shi10 ^ (~t2shi11 & t2shi12)
              s[30] = t2slo15 ^ (~t2slo16 & t2slo17)
              s[31] = t2shi15 ^ (~t2shi16 & t2shi17)
              s[40] = t2slo20 ^ (~t2slo21 & t2slo22)
              s[41] = t2shi20 ^ (~t2shi21 & t2shi22)
              s[2] = t2slo1 ^ (~t2slo2 & t2slo3)
              s[3] = t2shi1 ^ (~t2shi2 & t2shi3)
              s[12] = t2slo6 ^ (~t2slo7 & t2slo8)
              s[13] = t2shi6 ^ (~t2shi7 & t2shi8)
              s[22] = t2slo11 ^ (~t2slo12 & t2slo13)
              s[23] = t2shi11 ^ (~t2shi12 & t2shi13)
              s[32] = t2slo16 ^ (~t2slo17 & t2slo18)
              s[33] = t2shi16 ^ (~t2shi17 & t2shi18)
              s[42] = t2slo21 ^ (~t2slo22 & t2slo23)
              s[43] = t2shi21 ^ (~t2shi22 & t2shi23)
              s[4] = t2slo2 ^ (~t2slo3 & t2slo4)
              s[5] = t2shi2 ^ (~t2shi3 & t2shi4)
              s[14] = t2slo7 ^ (~t2slo8 & t2slo9)
              s[15] = t2shi7 ^ (~t2shi8 & t2shi9)
              s[24] = t2slo12 ^ (~t2slo13 & t2slo14)
              s[25] = t2shi12 ^ (~t2shi13 & t2shi14)
              s[34] = t2slo17 ^ (~t2slo18 & t2slo19)
              s[35] = t2shi17 ^ (~t2shi18 & t2shi19)
              s[44] = t2slo22 ^ (~t2slo23 & t2slo24)
              s[45] = t2shi22 ^ (~t2shi23 & t2shi24)
              s[6] = t2slo3 ^ (~t2slo4 & t2slo0)
              s[7] = t2shi3 ^ (~t2shi4 & t2shi0)
              s[16] = t2slo8 ^ (~t2slo9 & t2slo5)
              s[17] = t2shi8 ^ (~t2shi9 & t2shi5)
              s[26] = t2slo13 ^ (~t2slo14 & t2slo10)
              s[27] = t2shi13 ^ (~t2shi14 & t2shi10)
              s[36] = t2slo18 ^ (~t2slo19 & t2slo15)
              s[37] = t2shi18 ^ (~t2shi19 & t2shi15)
              s[46] = t2slo23 ^ (~t2slo24 & t2slo20)
              s[47] = t2shi23 ^ (~t2shi24 & t2shi20)
              s[8] = t2slo4 ^ (~t2slo0 & t2slo1)
              s[9] = t2shi4 ^ (~t2shi0 & t2shi1)
              s[18] = t2slo9 ^ (~t2slo5 & t2slo6)
              s[19] = t2shi9 ^ (~t2shi5 & t2shi6)
              s[28] = t2slo14 ^ (~t2slo10 & t2slo11)
              s[29] = t2shi14 ^ (~t2shi10 & t2shi11)
              s[38] = t2slo19 ^ (~t2slo15 & t2slo16)
              s[39] = t2shi19 ^ (~t2shi15 & t2shi16)
              s[48] = t2slo24 ^ (~t2slo20 & t2slo21)
              s[49] = t2shi24 ^ (~t2shi20 & t2shi21)

              // iota
              s[0] ^= P1600_ROUND_CONSTANTS[round * 2]
              s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]
            }
          }
        },
        {},
      ],
      28: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              const keccakState = require('./keccak-state-unroll')

              function Keccak() {
                // much faster than `new Array(50)`
                this.state = [
                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0,
                ]

                this.blockSize = null
                this.count = 0
                this.squeezing = false
              }

              Keccak.prototype.initialize = function (rate, capacity) {
                for (let i = 0; i < 50; ++i) this.state[i] = 0
                this.blockSize = rate / 8
                this.count = 0
                this.squeezing = false
              }

              Keccak.prototype.absorb = function (data) {
                for (let i = 0; i < data.length; ++i) {
                  this.state[~~(this.count / 4)] ^=
                    data[i] << (8 * (this.count % 4))
                  this.count += 1
                  if (this.count === this.blockSize) {
                    keccakState.p1600(this.state)
                    this.count = 0
                  }
                }
              }

              Keccak.prototype.absorbLastFewBits = function (bits) {
                this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))
                if ((bits & 0x80) !== 0 && this.count === this.blockSize - 1)
                  keccakState.p1600(this.state)
                this.state[~~((this.blockSize - 1) / 4)] ^=
                  0x80 << (8 * ((this.blockSize - 1) % 4))
                keccakState.p1600(this.state)
                this.count = 0
                this.squeezing = true
              }

              Keccak.prototype.squeeze = function (length) {
                if (!this.squeezing) this.absorbLastFewBits(0x01)

                const output = Buffer.alloc(length)
                for (let i = 0; i < length; ++i) {
                  output[i] =
                    (this.state[~~(this.count / 4)] >>>
                      (8 * (this.count % 4))) &
                    0xff
                  this.count += 1
                  if (this.count === this.blockSize) {
                    keccakState.p1600(this.state)
                    this.count = 0
                  }
                }

                return output
              }

              Keccak.prototype.copy = function (dest) {
                for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i]
                dest.blockSize = this.blockSize
                dest.count = this.count
                dest.squeezing = this.squeezing
              }

              module.exports = Keccak
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { './keccak-state-unroll': 27, buffer: 18 },
      ],
      29: [
        function (require, module, exports) {
          'use strict'

          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype)
            subClass.prototype.constructor = subClass
            subClass.__proto__ = superClass
          }

          var codes = {}

          function createErrorType(code, message, Base) {
            if (!Base) {
              Base = Error
            }

            function getMessage(arg1, arg2, arg3) {
              if (typeof message === 'string') {
                return message
              } else {
                return message(arg1, arg2, arg3)
              }
            }

            var NodeError =
              /*#__PURE__*/
              (function (_Base) {
                _inheritsLoose(NodeError, _Base)

                function NodeError(arg1, arg2, arg3) {
                  return _Base.call(this, getMessage(arg1, arg2, arg3)) || this
                }

                return NodeError
              })(Base)

            NodeError.prototype.name = Base.name
            NodeError.prototype.code = code
            codes[code] = NodeError
          } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

          function oneOf(expected, thing) {
            if (Array.isArray(expected)) {
              var len = expected.length
              expected = expected.map(function (i) {
                return String(i)
              })

              if (len > 2) {
                return (
                  'one of '
                    .concat(thing, ' ')
                    .concat(expected.slice(0, len - 1).join(', '), ', or ') +
                  expected[len - 1]
                )
              } else if (len === 2) {
                return 'one of '
                  .concat(thing, ' ')
                  .concat(expected[0], ' or ')
                  .concat(expected[1])
              } else {
                return 'of '.concat(thing, ' ').concat(expected[0])
              }
            } else {
              return 'of '.concat(thing, ' ').concat(String(expected))
            }
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

          function startsWith(str, search, pos) {
            return (
              str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search
            )
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

          function endsWith(str, search, this_len) {
            if (this_len === undefined || this_len > str.length) {
              this_len = str.length
            }

            return str.substring(this_len - search.length, this_len) === search
          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

          function includes(str, search, start) {
            if (typeof start !== 'number') {
              start = 0
            }

            if (start + search.length > str.length) {
              return false
            } else {
              return str.indexOf(search, start) !== -1
            }
          }

          createErrorType(
            'ERR_INVALID_OPT_VALUE',
            function (name, value) {
              return (
                'The value "' + value + '" is invalid for option "' + name + '"'
              )
            },
            TypeError
          )
          createErrorType(
            'ERR_INVALID_ARG_TYPE',
            function (name, expected, actual) {
              // determiner: 'must be' or 'must not be'
              var determiner

              if (
                typeof expected === 'string' &&
                startsWith(expected, 'not ')
              ) {
                determiner = 'must not be'
                expected = expected.replace(/^not /, '')
              } else {
                determiner = 'must be'
              }

              var msg

              if (endsWith(name, ' argument')) {
                // For cases like 'first argument'
                msg = 'The '
                  .concat(name, ' ')
                  .concat(determiner, ' ')
                  .concat(oneOf(expected, 'type'))
              } else {
                var type = includes(name, '.') ? 'property' : 'argument'
                msg = 'The "'
                  .concat(name, '" ')
                  .concat(type, ' ')
                  .concat(determiner, ' ')
                  .concat(oneOf(expected, 'type'))
              }

              msg += '. Received type '.concat(typeof actual)
              return msg
            },
            TypeError
          )
          createErrorType(
            'ERR_STREAM_PUSH_AFTER_EOF',
            'stream.push() after EOF'
          )
          createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
            return 'The ' + name + ' method is not implemented'
          })
          createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close')
          createErrorType('ERR_STREAM_DESTROYED', function (name) {
            return 'Cannot call ' + name + ' after a stream was destroyed'
          })
          createErrorType(
            'ERR_MULTIPLE_CALLBACK',
            'Callback called multiple times'
          )
          createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable')
          createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end')
          createErrorType(
            'ERR_STREAM_NULL_VALUES',
            'May not write null values to stream',
            TypeError
          )
          createErrorType(
            'ERR_UNKNOWN_ENCODING',
            function (arg) {
              return 'Unknown encoding: ' + arg
            },
            TypeError
          )
          createErrorType(
            'ERR_STREAM_UNSHIFT_AFTER_END_EVENT',
            'stream.unshift() after end event'
          )
          module.exports.codes = codes
        },
        {},
      ],
      30: [
        function (require, module, exports) {
          ;(function (process) {
            ;(function () {
              // Copyright Joyent, Inc. and other Node contributors.
              //
              // Permission is hereby granted, free of charge, to any person obtaining a
              // copy of this software and associated documentation files (the
              // "Software"), to deal in the Software without restriction, including
              // without limitation the rights to use, copy, modify, merge, publish,
              // distribute, sublicense, and/or sell copies of the Software, and to permit
              // persons to whom the Software is furnished to do so, subject to the
              // following conditions:
              //
              // The above copyright notice and this permission notice shall be included
              // in all copies or substantial portions of the Software.
              //
              // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
              // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
              // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
              // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
              // USE OR OTHER DEALINGS IN THE SOFTWARE.
              // a duplex stream is just a stream that is both readable and writable.
              // Since JS doesn't have multiple prototypal inheritance, this class
              // prototypally inherits from Readable, and then parasitically from
              // Writable.
              'use strict'
              /*<replacement>*/

              var objectKeys =
                Object.keys ||
                function (obj) {
                  var keys = []

                  for (var key in obj) {
                    keys.push(key)
                  }

                  return keys
                }
              /*</replacement>*/

              module.exports = Duplex

              var Readable = require('./_stream_readable')

              var Writable = require('./_stream_writable')

              require('inherits')(Duplex, Readable)

              {
                // Allow the keys array to be GC'ed.
                var keys = objectKeys(Writable.prototype)

                for (var v = 0; v < keys.length; v++) {
                  var method = keys[v]
                  if (!Duplex.prototype[method])
                    Duplex.prototype[method] = Writable.prototype[method]
                }
              }

              function Duplex(options) {
                if (!(this instanceof Duplex)) return new Duplex(options)
                Readable.call(this, options)
                Writable.call(this, options)
                this.allowHalfOpen = true

                if (options) {
                  if (options.readable === false) this.readable = false
                  if (options.writable === false) this.writable = false

                  if (options.allowHalfOpen === false) {
                    this.allowHalfOpen = false
                    this.once('end', onend)
                  }
                }
              }

              Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.highWaterMark
                },
              })
              Object.defineProperty(Duplex.prototype, 'writableBuffer', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState && this._writableState.getBuffer()
                },
              })
              Object.defineProperty(Duplex.prototype, 'writableLength', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.length
                },
              }) // the no-half-open enforcer

              function onend() {
                // If the writable side ended, then we're ok.
                if (this._writableState.ended) return // no more data can be written.
                // But allow more writes to happen in this tick.

                process.nextTick(onEndNT, this)
              }

              function onEndNT(self) {
                self.end()
              }

              Object.defineProperty(Duplex.prototype, 'destroyed', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (
                    this._readableState === undefined ||
                    this._writableState === undefined
                  ) {
                    return false
                  }

                  return (
                    this._readableState.destroyed &&
                    this._writableState.destroyed
                  )
                },
                set: function set(value) {
                  // we ignore the value if the stream
                  // has not been initialized yet
                  if (
                    this._readableState === undefined ||
                    this._writableState === undefined
                  ) {
                    return
                  } // backward compatibility, the user is explicitly
                  // managing destroyed

                  this._readableState.destroyed = value
                  this._writableState.destroyed = value
                },
              })
            }.call(this))
          }.call(this, require('_process')))
        },
        {
          './_stream_readable': 32,
          './_stream_writable': 34,
          _process: 45,
          inherits: 21,
        },
      ],
      31: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // a passthrough stream.
          // basically just the most minimal sort of Transform stream.
          // Every written chunk gets output as-is.
          'use strict'

          module.exports = PassThrough

          var Transform = require('./_stream_transform')

          require('inherits')(PassThrough, Transform)

          function PassThrough(options) {
            if (!(this instanceof PassThrough)) return new PassThrough(options)
            Transform.call(this, options)
          }

          PassThrough.prototype._transform = function (chunk, encoding, cb) {
            cb(null, chunk)
          }
        },
        { './_stream_transform': 33, inherits: 21 },
      ],
      32: [
        function (require, module, exports) {
          ;(function (process, global) {
            ;(function () {
              // Copyright Joyent, Inc. and other Node contributors.
              //
              // Permission is hereby granted, free of charge, to any person obtaining a
              // copy of this software and associated documentation files (the
              // "Software"), to deal in the Software without restriction, including
              // without limitation the rights to use, copy, modify, merge, publish,
              // distribute, sublicense, and/or sell copies of the Software, and to permit
              // persons to whom the Software is furnished to do so, subject to the
              // following conditions:
              //
              // The above copyright notice and this permission notice shall be included
              // in all copies or substantial portions of the Software.
              //
              // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
              // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
              // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
              // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
              // USE OR OTHER DEALINGS IN THE SOFTWARE.
              'use strict'

              module.exports = Readable
              /*<replacement>*/

              var Duplex
              /*</replacement>*/

              Readable.ReadableState = ReadableState
              /*<replacement>*/

              var EE = require('events').EventEmitter

              var EElistenerCount = function EElistenerCount(emitter, type) {
                return emitter.listeners(type).length
              }
              /*</replacement>*/

              /*<replacement>*/

              var Stream = require('./internal/streams/stream')
              /*</replacement>*/

              var Buffer = require('buffer').Buffer

              var OurUint8Array = global.Uint8Array || function () {}

              function _uint8ArrayToBuffer(chunk) {
                return Buffer.from(chunk)
              }

              function _isUint8Array(obj) {
                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
              }
              /*<replacement>*/

              var debugUtil = require('util')

              var debug

              if (debugUtil && debugUtil.debuglog) {
                debug = debugUtil.debuglog('stream')
              } else {
                debug = function debug() {}
              }
              /*</replacement>*/

              var BufferList = require('./internal/streams/buffer_list')

              var destroyImpl = require('./internal/streams/destroy')

              var _require = require('./internal/streams/state'),
                getHighWaterMark = _require.getHighWaterMark

              var _require$codes = require('../errors').codes,
                ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
                ERR_STREAM_PUSH_AFTER_EOF =
                  _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
                ERR_METHOD_NOT_IMPLEMENTED =
                  _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
                ERR_STREAM_UNSHIFT_AFTER_END_EVENT =
                  _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT // Lazy loaded to improve the startup performance.

              var StringDecoder
              var createReadableStreamAsyncIterator
              var from

              require('inherits')(Readable, Stream)

              var errorOrDestroy = destroyImpl.errorOrDestroy
              var kProxyEvents = [
                'error',
                'close',
                'destroy',
                'pause',
                'resume',
              ]

              function prependListener(emitter, event, fn) {
                // Sadly this is not cacheable as some libraries bundle their own
                // event emitter implementation with them.
                if (typeof emitter.prependListener === 'function')
                  return emitter.prependListener(event, fn) // This is a hack to make sure that our error handler is attached before any
                // userland ones.  NEVER DO THIS. This is here only because this code needs
                // to continue to work with older versions of Node.js that do not include
                // the prependListener() method. The goal is to eventually remove this hack.

                if (!emitter._events || !emitter._events[event])
                  emitter.on(event, fn)
                else if (Array.isArray(emitter._events[event]))
                  emitter._events[event].unshift(fn)
                else emitter._events[event] = [fn, emitter._events[event]]
              }

              function ReadableState(options, stream, isDuplex) {
                Duplex = Duplex || require('./_stream_duplex')
                options = options || {} // Duplex streams are both readable and writable, but share
                // the same options object.
                // However, some cases require setting options to different
                // values for the readable and the writable sides of the duplex stream.
                // These options can be provided separately as readableXXX and writableXXX.

                if (typeof isDuplex !== 'boolean')
                  isDuplex = stream instanceof Duplex // object stream flag. Used to make read(n) ignore n and to
                // make all the buffer merging and length checks go away

                this.objectMode = !!options.objectMode
                if (isDuplex)
                  this.objectMode =
                    this.objectMode || !!options.readableObjectMode // the point at which it stops calling _read() to fill the buffer
                // Note: 0 is a valid value, means "don't call _read preemptively ever"

                this.highWaterMark = getHighWaterMark(
                  this,
                  options,
                  'readableHighWaterMark',
                  isDuplex
                ) // A linked list is used to store data chunks instead of an array because the
                // linked list can remove elements from the beginning faster than
                // array.shift()

                this.buffer = new BufferList()
                this.length = 0
                this.pipes = null
                this.pipesCount = 0
                this.flowing = null
                this.ended = false
                this.endEmitted = false
                this.reading = false // a flag to be able to tell if the event 'readable'/'data' is emitted
                // immediately, or on a later tick.  We set this to true at first, because
                // any actions that shouldn't happen until "later" should generally also
                // not happen before the first read call.

                this.sync = true // whenever we return null, then we set a flag to say
                // that we're awaiting a 'readable' event emission.

                this.needReadable = false
                this.emittedReadable = false
                this.readableListening = false
                this.resumeScheduled = false
                this.paused = true // Should close be emitted on destroy. Defaults to true.

                this.emitClose = options.emitClose !== false // Should .destroy() be called after 'end' (and potentially 'finish')

                this.autoDestroy = !!options.autoDestroy // has it been destroyed

                this.destroyed = false // Crypto is kind of old and crusty.  Historically, its default string
                // encoding is 'binary' so we have to make this configurable.
                // Everything else in the universe uses 'utf8', though.

                this.defaultEncoding = options.defaultEncoding || 'utf8' // the number of writers that are awaiting a drain event in .pipe()s

                this.awaitDrain = 0 // if true, a maybeReadMore has been scheduled

                this.readingMore = false
                this.decoder = null
                this.encoding = null

                if (options.encoding) {
                  if (!StringDecoder)
                    StringDecoder = require('string_decoder/').StringDecoder
                  this.decoder = new StringDecoder(options.encoding)
                  this.encoding = options.encoding
                }
              }

              function Readable(options) {
                Duplex = Duplex || require('./_stream_duplex')
                if (!(this instanceof Readable)) return new Readable(options) // Checking for a Stream.Duplex instance is faster here instead of inside
                // the ReadableState constructor, at least with V8 6.5

                var isDuplex = this instanceof Duplex
                this._readableState = new ReadableState(options, this, isDuplex) // legacy

                this.readable = true

                if (options) {
                  if (typeof options.read === 'function')
                    this._read = options.read
                  if (typeof options.destroy === 'function')
                    this._destroy = options.destroy
                }

                Stream.call(this)
              }

              Object.defineProperty(Readable.prototype, 'destroyed', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (this._readableState === undefined) {
                    return false
                  }

                  return this._readableState.destroyed
                },
                set: function set(value) {
                  // we ignore the value if the stream
                  // has not been initialized yet
                  if (!this._readableState) {
                    return
                  } // backward compatibility, the user is explicitly
                  // managing destroyed

                  this._readableState.destroyed = value
                },
              })
              Readable.prototype.destroy = destroyImpl.destroy
              Readable.prototype._undestroy = destroyImpl.undestroy

              Readable.prototype._destroy = function (err, cb) {
                cb(err)
              } // Manually shove something into the read() buffer.
              // This returns true if the highWaterMark has not been hit yet,
              // similar to how Writable.write() returns true if you should
              // write() some more.

              Readable.prototype.push = function (chunk, encoding) {
                var state = this._readableState
                var skipChunkCheck

                if (!state.objectMode) {
                  if (typeof chunk === 'string') {
                    encoding = encoding || state.defaultEncoding

                    if (encoding !== state.encoding) {
                      chunk = Buffer.from(chunk, encoding)
                      encoding = ''
                    }

                    skipChunkCheck = true
                  }
                } else {
                  skipChunkCheck = true
                }

                return readableAddChunk(
                  this,
                  chunk,
                  encoding,
                  false,
                  skipChunkCheck
                )
              } // Unshift should *always* be something directly out of read()

              Readable.prototype.unshift = function (chunk) {
                return readableAddChunk(this, chunk, null, true, false)
              }

              function readableAddChunk(
                stream,
                chunk,
                encoding,
                addToFront,
                skipChunkCheck
              ) {
                debug('readableAddChunk', chunk)
                var state = stream._readableState

                if (chunk === null) {
                  state.reading = false
                  onEofChunk(stream, state)
                } else {
                  var er
                  if (!skipChunkCheck) er = chunkInvalid(state, chunk)

                  if (er) {
                    errorOrDestroy(stream, er)
                  } else if (state.objectMode || (chunk && chunk.length > 0)) {
                    if (
                      typeof chunk !== 'string' &&
                      !state.objectMode &&
                      Object.getPrototypeOf(chunk) !== Buffer.prototype
                    ) {
                      chunk = _uint8ArrayToBuffer(chunk)
                    }

                    if (addToFront) {
                      if (state.endEmitted)
                        errorOrDestroy(
                          stream,
                          new ERR_STREAM_UNSHIFT_AFTER_END_EVENT()
                        )
                      else addChunk(stream, state, chunk, true)
                    } else if (state.ended) {
                      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF())
                    } else if (state.destroyed) {
                      return false
                    } else {
                      state.reading = false

                      if (state.decoder && !encoding) {
                        chunk = state.decoder.write(chunk)
                        if (state.objectMode || chunk.length !== 0)
                          addChunk(stream, state, chunk, false)
                        else maybeReadMore(stream, state)
                      } else {
                        addChunk(stream, state, chunk, false)
                      }
                    }
                  } else if (!addToFront) {
                    state.reading = false
                    maybeReadMore(stream, state)
                  }
                } // We can push more data if we are below the highWaterMark.
                // Also, if we have no data yet, we can stand some more bytes.
                // This is to work around cases where hwm=0, such as the repl.

                return (
                  !state.ended &&
                  (state.length < state.highWaterMark || state.length === 0)
                )
              }

              function addChunk(stream, state, chunk, addToFront) {
                if (state.flowing && state.length === 0 && !state.sync) {
                  state.awaitDrain = 0
                  stream.emit('data', chunk)
                } else {
                  // update the buffer info.
                  state.length += state.objectMode ? 1 : chunk.length
                  if (addToFront) state.buffer.unshift(chunk)
                  else state.buffer.push(chunk)
                  if (state.needReadable) emitReadable(stream)
                }

                maybeReadMore(stream, state)
              }

              function chunkInvalid(state, chunk) {
                var er

                if (
                  !_isUint8Array(chunk) &&
                  typeof chunk !== 'string' &&
                  chunk !== undefined &&
                  !state.objectMode
                ) {
                  er = new ERR_INVALID_ARG_TYPE(
                    'chunk',
                    ['string', 'Buffer', 'Uint8Array'],
                    chunk
                  )
                }

                return er
              }

              Readable.prototype.isPaused = function () {
                return this._readableState.flowing === false
              } // backwards compatibility.

              Readable.prototype.setEncoding = function (enc) {
                if (!StringDecoder)
                  StringDecoder = require('string_decoder/').StringDecoder
                var decoder = new StringDecoder(enc)
                this._readableState.decoder = decoder // If setEncoding(null), decoder.encoding equals utf8

                this._readableState.encoding =
                  this._readableState.decoder.encoding // Iterate over current buffer to convert already stored Buffers:

                var p = this._readableState.buffer.head
                var content = ''

                while (p !== null) {
                  content += decoder.write(p.data)
                  p = p.next
                }

                this._readableState.buffer.clear()

                if (content !== '') this._readableState.buffer.push(content)
                this._readableState.length = content.length
                return this
              } // Don't raise the hwm > 1GB

              var MAX_HWM = 0x40000000

              function computeNewHighWaterMark(n) {
                if (n >= MAX_HWM) {
                  // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
                  n = MAX_HWM
                } else {
                  // Get the next highest power of 2 to prevent increasing hwm excessively in
                  // tiny amounts
                  n--
                  n |= n >>> 1
                  n |= n >>> 2
                  n |= n >>> 4
                  n |= n >>> 8
                  n |= n >>> 16
                  n++
                }

                return n
              } // This function is designed to be inlinable, so please take care when making
              // changes to the function body.

              function howMuchToRead(n, state) {
                if (n <= 0 || (state.length === 0 && state.ended)) return 0
                if (state.objectMode) return 1

                if (n !== n) {
                  // Only flow one buffer at a time
                  if (state.flowing && state.length)
                    return state.buffer.head.data.length
                  else return state.length
                } // If we're asking for more than the current hwm, then raise the hwm.

                if (n > state.highWaterMark)
                  state.highWaterMark = computeNewHighWaterMark(n)
                if (n <= state.length) return n // Don't have enough

                if (!state.ended) {
                  state.needReadable = true
                  return 0
                }

                return state.length
              } // you can override either this method, or the async _read(n) below.

              Readable.prototype.read = function (n) {
                debug('read', n)
                n = parseInt(n, 10)
                var state = this._readableState
                var nOrig = n
                if (n !== 0) state.emittedReadable = false // if we're doing read(0) to trigger a readable event, but we
                // already have a bunch of data in the buffer, then just trigger
                // the 'readable' event and move on.

                if (
                  n === 0 &&
                  state.needReadable &&
                  ((state.highWaterMark !== 0
                    ? state.length >= state.highWaterMark
                    : state.length > 0) ||
                    state.ended)
                ) {
                  debug('read: emitReadable', state.length, state.ended)
                  if (state.length === 0 && state.ended) endReadable(this)
                  else emitReadable(this)
                  return null
                }

                n = howMuchToRead(n, state) // if we've ended, and we're now clear, then finish it up.

                if (n === 0 && state.ended) {
                  if (state.length === 0) endReadable(this)
                  return null
                } // All the actual chunk generation logic needs to be
                // *below* the call to _read.  The reason is that in certain
                // synthetic stream cases, such as passthrough streams, _read
                // may be a completely synchronous operation which may change
                // the state of the read buffer, providing enough data when
                // before there was *not* enough.
                //
                // So, the steps are:
                // 1. Figure out what the state of things will be after we do
                // a read from the buffer.
                //
                // 2. If that resulting state will trigger a _read, then call _read.
                // Note that this may be asynchronous, or synchronous.  Yes, it is
                // deeply ugly to write APIs this way, but that still doesn't mean
                // that the Readable class should behave improperly, as streams are
                // designed to be sync/async agnostic.
                // Take note if the _read call is sync or async (ie, if the read call
                // has returned yet), so that we know whether or not it's safe to emit
                // 'readable' etc.
                //
                // 3. Actually pull the requested chunks out of the buffer and return.
                // if we need a readable event, then we need to do some reading.

                var doRead = state.needReadable
                debug('need readable', doRead) // if we currently have less than the highWaterMark, then also read some

                if (
                  state.length === 0 ||
                  state.length - n < state.highWaterMark
                ) {
                  doRead = true
                  debug('length less than watermark', doRead)
                } // however, if we've ended, then there's no point, and if we're already
                // reading, then it's unnecessary.

                if (state.ended || state.reading) {
                  doRead = false
                  debug('reading or ended', doRead)
                } else if (doRead) {
                  debug('do read')
                  state.reading = true
                  state.sync = true // if the length is currently zero, then we *need* a readable event.

                  if (state.length === 0) state.needReadable = true // call internal read method

                  this._read(state.highWaterMark)

                  state.sync = false // If _read pushed data synchronously, then `reading` will be false,
                  // and we need to re-evaluate how much data we can return to the user.

                  if (!state.reading) n = howMuchToRead(nOrig, state)
                }

                var ret
                if (n > 0) ret = fromList(n, state)
                else ret = null

                if (ret === null) {
                  state.needReadable = state.length <= state.highWaterMark
                  n = 0
                } else {
                  state.length -= n
                  state.awaitDrain = 0
                }

                if (state.length === 0) {
                  // If we have nothing in the buffer, then we want to know
                  // as soon as we *do* get something into the buffer.
                  if (!state.ended) state.needReadable = true // If we tried to read() past the EOF, then emit end on the next tick.

                  if (nOrig !== n && state.ended) endReadable(this)
                }

                if (ret !== null) this.emit('data', ret)
                return ret
              }

              function onEofChunk(stream, state) {
                debug('onEofChunk')
                if (state.ended) return

                if (state.decoder) {
                  var chunk = state.decoder.end()

                  if (chunk && chunk.length) {
                    state.buffer.push(chunk)
                    state.length += state.objectMode ? 1 : chunk.length
                  }
                }

                state.ended = true

                if (state.sync) {
                  // if we are sync, wait until next tick to emit the data.
                  // Otherwise we risk emitting data in the flow()
                  // the readable code triggers during a read() call
                  emitReadable(stream)
                } else {
                  // emit 'readable' now to make sure it gets picked up.
                  state.needReadable = false

                  if (!state.emittedReadable) {
                    state.emittedReadable = true
                    emitReadable_(stream)
                  }
                }
              } // Don't emit readable right away in sync mode, because this can trigger
              // another read() call => stack overflow.  This way, it might trigger
              // a nextTick recursion warning, but that's not so bad.

              function emitReadable(stream) {
                var state = stream._readableState
                debug('emitReadable', state.needReadable, state.emittedReadable)
                state.needReadable = false

                if (!state.emittedReadable) {
                  debug('emitReadable', state.flowing)
                  state.emittedReadable = true
                  process.nextTick(emitReadable_, stream)
                }
              }

              function emitReadable_(stream) {
                var state = stream._readableState
                debug(
                  'emitReadable_',
                  state.destroyed,
                  state.length,
                  state.ended
                )

                if (!state.destroyed && (state.length || state.ended)) {
                  stream.emit('readable')
                  state.emittedReadable = false
                } // The stream needs another readable event if
                // 1. It is not flowing, as the flow mechanism will take
                //    care of it.
                // 2. It is not ended.
                // 3. It is below the highWaterMark, so we can schedule
                //    another readable later.

                state.needReadable =
                  !state.flowing &&
                  !state.ended &&
                  state.length <= state.highWaterMark
                flow(stream)
              } // at this point, the user has presumably seen the 'readable' event,
              // and called read() to consume some data.  that may have triggered
              // in turn another _read(n) call, in which case reading = true if
              // it's in progress.
              // However, if we're not ended, or reading, and the length < hwm,
              // then go ahead and try to read some more preemptively.

              function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                  state.readingMore = true
                  process.nextTick(maybeReadMore_, stream, state)
                }
              }

              function maybeReadMore_(stream, state) {
                // Attempt to read more data if we should.
                //
                // The conditions for reading more data are (one of):
                // - Not enough data buffered (state.length < state.highWaterMark). The loop
                //   is responsible for filling the buffer with enough data if such data
                //   is available. If highWaterMark is 0 and we are not in the flowing mode
                //   we should _not_ attempt to buffer any extra data. We'll get more data
                //   when the stream consumer calls read() instead.
                // - No data in the buffer, and the stream is in flowing mode. In this mode
                //   the loop below is responsible for ensuring read() is called. Failing to
                //   call read here would abort the flow and there's no other mechanism for
                //   continuing the flow if the stream consumer has just subscribed to the
                //   'data' event.
                //
                // In addition to the above conditions to keep reading data, the following
                // conditions prevent the data from being read:
                // - The stream has ended (state.ended).
                // - There is already a pending 'read' operation (state.reading). This is a
                //   case where the the stream has called the implementation defined _read()
                //   method, but they are processing the call asynchronously and have _not_
                //   called push() with new data. In this case we skip performing more
                //   read()s. The execution ends in this method again after the _read() ends
                //   up calling push() with more data.
                while (
                  !state.reading &&
                  !state.ended &&
                  (state.length < state.highWaterMark ||
                    (state.flowing && state.length === 0))
                ) {
                  var len = state.length
                  debug('maybeReadMore read 0')
                  stream.read(0)
                  if (len === state.length)
                    // didn't get any data, stop spinning.
                    break
                }

                state.readingMore = false
              } // abstract method.  to be overridden in specific implementation classes.
              // call cb(er, data) where data is <= n in length.
              // for virtual (non-string, non-buffer) streams, "length" is somewhat
              // arbitrary, and perhaps not very meaningful.

              Readable.prototype._read = function (n) {
                errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'))
              }

              Readable.prototype.pipe = function (dest, pipeOpts) {
                var src = this
                var state = this._readableState

                switch (state.pipesCount) {
                  case 0:
                    state.pipes = dest
                    break

                  case 1:
                    state.pipes = [state.pipes, dest]
                    break

                  default:
                    state.pipes.push(dest)
                    break
                }

                state.pipesCount += 1
                debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts)
                var doEnd =
                  (!pipeOpts || pipeOpts.end !== false) &&
                  dest !== process.stdout &&
                  dest !== process.stderr
                var endFn = doEnd ? onend : unpipe
                if (state.endEmitted) process.nextTick(endFn)
                else src.once('end', endFn)
                dest.on('unpipe', onunpipe)

                function onunpipe(readable, unpipeInfo) {
                  debug('onunpipe')

                  if (readable === src) {
                    if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                      unpipeInfo.hasUnpiped = true
                      cleanup()
                    }
                  }
                }

                function onend() {
                  debug('onend')
                  dest.end()
                } // when the dest drains, it reduces the awaitDrain counter
                // on the source.  This would be more elegant with a .once()
                // handler in flow(), but adding and removing repeatedly is
                // too slow.

                var ondrain = pipeOnDrain(src)
                dest.on('drain', ondrain)
                var cleanedUp = false

                function cleanup() {
                  debug('cleanup') // cleanup event handlers once the pipe is broken

                  dest.removeListener('close', onclose)
                  dest.removeListener('finish', onfinish)
                  dest.removeListener('drain', ondrain)
                  dest.removeListener('error', onerror)
                  dest.removeListener('unpipe', onunpipe)
                  src.removeListener('end', onend)
                  src.removeListener('end', unpipe)
                  src.removeListener('data', ondata)
                  cleanedUp = true // if the reader is waiting for a drain event from this
                  // specific writer, then it would cause it to never start
                  // flowing again.
                  // So, if this is awaiting a drain, then we just call it now.
                  // If we don't know, then assume that we are waiting for one.

                  if (
                    state.awaitDrain &&
                    (!dest._writableState || dest._writableState.needDrain)
                  )
                    ondrain()
                }

                src.on('data', ondata)

                function ondata(chunk) {
                  debug('ondata')
                  var ret = dest.write(chunk)
                  debug('dest.write', ret)

                  if (ret === false) {
                    // If the user unpiped during `dest.write()`, it is possible
                    // to get stuck in a permanently paused state if that write
                    // also returned false.
                    // => Check whether `dest` is still a piping destination.
                    if (
                      ((state.pipesCount === 1 && state.pipes === dest) ||
                        (state.pipesCount > 1 &&
                          indexOf(state.pipes, dest) !== -1)) &&
                      !cleanedUp
                    ) {
                      debug('false write response, pause', state.awaitDrain)
                      state.awaitDrain++
                    }

                    src.pause()
                  }
                } // if the dest has an error, then stop piping into it.
                // however, don't suppress the throwing behavior for this.

                function onerror(er) {
                  debug('onerror', er)
                  unpipe()
                  dest.removeListener('error', onerror)
                  if (EElistenerCount(dest, 'error') === 0)
                    errorOrDestroy(dest, er)
                } // Make sure our error handler is attached before userland ones.

                prependListener(dest, 'error', onerror) // Both close and finish should trigger unpipe, but only once.

                function onclose() {
                  dest.removeListener('finish', onfinish)
                  unpipe()
                }

                dest.once('close', onclose)

                function onfinish() {
                  debug('onfinish')
                  dest.removeListener('close', onclose)
                  unpipe()
                }

                dest.once('finish', onfinish)

                function unpipe() {
                  debug('unpipe')
                  src.unpipe(dest)
                } // tell the dest that it's being piped to

                dest.emit('pipe', src) // start the flow if it hasn't been started already.

                if (!state.flowing) {
                  debug('pipe resume')
                  src.resume()
                }

                return dest
              }

              function pipeOnDrain(src) {
                return function pipeOnDrainFunctionResult() {
                  var state = src._readableState
                  debug('pipeOnDrain', state.awaitDrain)
                  if (state.awaitDrain) state.awaitDrain--

                  if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                    state.flowing = true
                    flow(src)
                  }
                }
              }

              Readable.prototype.unpipe = function (dest) {
                var state = this._readableState
                var unpipeInfo = {
                  hasUnpiped: false,
                } // if we're not piping anywhere, then do nothing.

                if (state.pipesCount === 0) return this // just one destination.  most common case.

                if (state.pipesCount === 1) {
                  // passed in one, but it's not the right one.
                  if (dest && dest !== state.pipes) return this
                  if (!dest) dest = state.pipes // got a match.

                  state.pipes = null
                  state.pipesCount = 0
                  state.flowing = false
                  if (dest) dest.emit('unpipe', this, unpipeInfo)
                  return this
                } // slow case. multiple pipe destinations.

                if (!dest) {
                  // remove all.
                  var dests = state.pipes
                  var len = state.pipesCount
                  state.pipes = null
                  state.pipesCount = 0
                  state.flowing = false

                  for (var i = 0; i < len; i++) {
                    dests[i].emit('unpipe', this, {
                      hasUnpiped: false,
                    })
                  }

                  return this
                } // try to find the right one.

                var index = indexOf(state.pipes, dest)
                if (index === -1) return this
                state.pipes.splice(index, 1)
                state.pipesCount -= 1
                if (state.pipesCount === 1) state.pipes = state.pipes[0]
                dest.emit('unpipe', this, unpipeInfo)
                return this
              } // set up data events if they are asked for
              // Ensure readable listeners eventually get something

              Readable.prototype.on = function (ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn)
                var state = this._readableState

                if (ev === 'data') {
                  // update readableListening so that resume() may be a no-op
                  // a few lines down. This is needed to support once('readable').
                  state.readableListening = this.listenerCount('readable') > 0 // Try start flowing on next tick if stream isn't explicitly paused

                  if (state.flowing !== false) this.resume()
                } else if (ev === 'readable') {
                  if (!state.endEmitted && !state.readableListening) {
                    state.readableListening = state.needReadable = true
                    state.flowing = false
                    state.emittedReadable = false
                    debug('on readable', state.length, state.reading)

                    if (state.length) {
                      emitReadable(this)
                    } else if (!state.reading) {
                      process.nextTick(nReadingNextTick, this)
                    }
                  }
                }

                return res
              }

              Readable.prototype.addListener = Readable.prototype.on

              Readable.prototype.removeListener = function (ev, fn) {
                var res = Stream.prototype.removeListener.call(this, ev, fn)

                if (ev === 'readable') {
                  // We need to check if there is someone still listening to
                  // readable and reset the state. However this needs to happen
                  // after readable has been emitted but before I/O (nextTick) to
                  // support once('readable', fn) cycles. This means that calling
                  // resume within the same tick will have no
                  // effect.
                  process.nextTick(updateReadableListening, this)
                }

                return res
              }

              Readable.prototype.removeAllListeners = function (ev) {
                var res = Stream.prototype.removeAllListeners.apply(
                  this,
                  arguments
                )

                if (ev === 'readable' || ev === undefined) {
                  // We need to check if there is someone still listening to
                  // readable and reset the state. However this needs to happen
                  // after readable has been emitted but before I/O (nextTick) to
                  // support once('readable', fn) cycles. This means that calling
                  // resume within the same tick will have no
                  // effect.
                  process.nextTick(updateReadableListening, this)
                }

                return res
              }

              function updateReadableListening(self) {
                var state = self._readableState
                state.readableListening = self.listenerCount('readable') > 0

                if (state.resumeScheduled && !state.paused) {
                  // flowing needs to be set to true now, otherwise
                  // the upcoming resume will not flow.
                  state.flowing = true // crude way to check if we should resume
                } else if (self.listenerCount('data') > 0) {
                  self.resume()
                }
              }

              function nReadingNextTick(self) {
                debug('readable nexttick read 0')
                self.read(0)
              } // pause() and resume() are remnants of the legacy readable stream API
              // If the user uses them, then switch into old mode.

              Readable.prototype.resume = function () {
                var state = this._readableState

                if (!state.flowing) {
                  debug('resume') // we flow only if there is no one listening
                  // for readable, but we still have to call
                  // resume()

                  state.flowing = !state.readableListening
                  resume(this, state)
                }

                state.paused = false
                return this
              }

              function resume(stream, state) {
                if (!state.resumeScheduled) {
                  state.resumeScheduled = true
                  process.nextTick(resume_, stream, state)
                }
              }

              function resume_(stream, state) {
                debug('resume', state.reading)

                if (!state.reading) {
                  stream.read(0)
                }

                state.resumeScheduled = false
                stream.emit('resume')
                flow(stream)
                if (state.flowing && !state.reading) stream.read(0)
              }

              Readable.prototype.pause = function () {
                debug('call pause flowing=%j', this._readableState.flowing)

                if (this._readableState.flowing !== false) {
                  debug('pause')
                  this._readableState.flowing = false
                  this.emit('pause')
                }

                this._readableState.paused = true
                return this
              }

              function flow(stream) {
                var state = stream._readableState
                debug('flow', state.flowing)

                while (state.flowing && stream.read() !== null) {}
              } // wrap an old-style stream as the async data source.
              // This is *not* part of the readable stream interface.
              // It is an ugly unfortunate mess of history.

              Readable.prototype.wrap = function (stream) {
                var _this = this

                var state = this._readableState
                var paused = false
                stream.on('end', function () {
                  debug('wrapped end')

                  if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end()
                    if (chunk && chunk.length) _this.push(chunk)
                  }

                  _this.push(null)
                })
                stream.on('data', function (chunk) {
                  debug('wrapped data')
                  if (state.decoder) chunk = state.decoder.write(chunk) // don't skip over falsy values in objectMode

                  if (
                    state.objectMode &&
                    (chunk === null || chunk === undefined)
                  )
                    return
                  else if (!state.objectMode && (!chunk || !chunk.length))
                    return

                  var ret = _this.push(chunk)

                  if (!ret) {
                    paused = true
                    stream.pause()
                  }
                }) // proxy all the other methods.
                // important when wrapping filters and duplexes.

                for (var i in stream) {
                  if (
                    this[i] === undefined &&
                    typeof stream[i] === 'function'
                  ) {
                    this[i] = (function methodWrap(method) {
                      return function methodWrapReturnFunction() {
                        return stream[method].apply(stream, arguments)
                      }
                    })(i)
                  }
                } // proxy certain important events.

                for (var n = 0; n < kProxyEvents.length; n++) {
                  stream.on(
                    kProxyEvents[n],
                    this.emit.bind(this, kProxyEvents[n])
                  )
                } // when we try to consume some more bytes, simply unpause the
                // underlying stream.

                this._read = function (n) {
                  debug('wrapped _read', n)

                  if (paused) {
                    paused = false
                    stream.resume()
                  }
                }

                return this
              }

              if (typeof Symbol === 'function') {
                Readable.prototype[Symbol.asyncIterator] = function () {
                  if (createReadableStreamAsyncIterator === undefined) {
                    createReadableStreamAsyncIterator = require('./internal/streams/async_iterator')
                  }

                  return createReadableStreamAsyncIterator(this)
                }
              }

              Object.defineProperty(
                Readable.prototype,
                'readableHighWaterMark',
                {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState.highWaterMark
                  },
                }
              )
              Object.defineProperty(Readable.prototype, 'readableBuffer', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState && this._readableState.buffer
                },
              })
              Object.defineProperty(Readable.prototype, 'readableFlowing', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState.flowing
                },
                set: function set(state) {
                  if (this._readableState) {
                    this._readableState.flowing = state
                  }
                },
              }) // exposed for testing purposes only.

              Readable._fromList = fromList
              Object.defineProperty(Readable.prototype, 'readableLength', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._readableState.length
                },
              }) // Pluck off n bytes from an array of buffers.
              // Length is the combined lengths of all the buffers in the list.
              // This function is designed to be inlinable, so please take care when making
              // changes to the function body.

              function fromList(n, state) {
                // nothing buffered
                if (state.length === 0) return null
                var ret
                if (state.objectMode) ret = state.buffer.shift()
                else if (!n || n >= state.length) {
                  // read it all, truncate the list
                  if (state.decoder) ret = state.buffer.join('')
                  else if (state.buffer.length === 1) ret = state.buffer.first()
                  else ret = state.buffer.concat(state.length)
                  state.buffer.clear()
                } else {
                  // read part of list
                  ret = state.buffer.consume(n, state.decoder)
                }
                return ret
              }

              function endReadable(stream) {
                var state = stream._readableState
                debug('endReadable', state.endEmitted)

                if (!state.endEmitted) {
                  state.ended = true
                  process.nextTick(endReadableNT, state, stream)
                }
              }

              function endReadableNT(state, stream) {
                debug('endReadableNT', state.endEmitted, state.length) // Check that we didn't get one last unshift.

                if (!state.endEmitted && state.length === 0) {
                  state.endEmitted = true
                  stream.readable = false
                  stream.emit('end')

                  if (state.autoDestroy) {
                    // In case of duplex streams we need a way to detect
                    // if the writable side is ready for autoDestroy as well
                    var wState = stream._writableState

                    if (!wState || (wState.autoDestroy && wState.finished)) {
                      stream.destroy()
                    }
                  }
                }
              }

              if (typeof Symbol === 'function') {
                Readable.from = function (iterable, opts) {
                  if (from === undefined) {
                    from = require('./internal/streams/from')
                  }

                  return from(Readable, iterable, opts)
                }
              }

              function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                  if (xs[i] === x) return i
                }

                return -1
              }
            }.call(this))
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ))
        },
        {
          '../errors': 29,
          './_stream_duplex': 30,
          './internal/streams/async_iterator': 35,
          './internal/streams/buffer_list': 36,
          './internal/streams/destroy': 37,
          './internal/streams/from': 39,
          './internal/streams/state': 41,
          './internal/streams/stream': 42,
          _process: 45,
          buffer: 18,
          events: 19,
          inherits: 21,
          'string_decoder/': 59,
          util: 17,
        },
      ],
      33: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.
          // a transform stream is a readable/writable stream where you do
          // something with the data.  Sometimes it's called a "filter",
          // but that's not a great name for it, since that implies a thing where
          // some bits pass through, and others are simply ignored.  (That would
          // be a valid example of a transform, of course.)
          //
          // While the output is causally related to the input, it's not a
          // necessarily symmetric or synchronous transformation.  For example,
          // a zlib stream might take multiple plain-text writes(), and then
          // emit a single compressed chunk some time in the future.
          //
          // Here's how this works:
          //
          // The Transform stream has all the aspects of the readable and writable
          // stream classes.  When you write(chunk), that calls _write(chunk,cb)
          // internally, and returns false if there's a lot of pending writes
          // buffered up.  When you call read(), that calls _read(n) until
          // there's enough pending readable data buffered up.
          //
          // In a transform stream, the written data is placed in a buffer.  When
          // _read(n) is called, it transforms the queued up data, calling the
          // buffered _write cb's as it consumes chunks.  If consuming a single
          // written chunk would result in multiple output chunks, then the first
          // outputted bit calls the readcb, and subsequent chunks just go into
          // the read buffer, and will cause it to emit 'readable' if necessary.
          //
          // This way, back-pressure is actually determined by the reading side,
          // since _read has to be called to start processing a new chunk.  However,
          // a pathological inflate type of transform can cause excessive buffering
          // here.  For example, imagine a stream where every byte of input is
          // interpreted as an integer from 0-255, and then results in that many
          // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
          // 1kb of data being output.  In this case, you could write a very small
          // amount of input, and end up with a very large amount of output.  In
          // such a pathological inflating mechanism, there'd be no way to tell
          // the system to stop doing the transform.  A single 4MB write could
          // cause the system to run out of memory.
          //
          // However, even in such a pathological case, only a single written chunk
          // would be consumed, and then the rest would wait (un-transformed) until
          // the results of the previous transformed chunk were consumed.
          'use strict'

          module.exports = Transform

          var _require$codes = require('../errors').codes,
            ERR_METHOD_NOT_IMPLEMENTED =
              _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
            ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
            ERR_TRANSFORM_ALREADY_TRANSFORMING =
              _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
            ERR_TRANSFORM_WITH_LENGTH_0 =
              _require$codes.ERR_TRANSFORM_WITH_LENGTH_0

          var Duplex = require('./_stream_duplex')

          require('inherits')(Transform, Duplex)

          function afterTransform(er, data) {
            var ts = this._transformState
            ts.transforming = false
            var cb = ts.writecb

            if (cb === null) {
              return this.emit('error', new ERR_MULTIPLE_CALLBACK())
            }

            ts.writechunk = null
            ts.writecb = null
            if (data != null)
              // single equals check for both `null` and `undefined`
              this.push(data)
            cb(er)
            var rs = this._readableState
            rs.reading = false

            if (rs.needReadable || rs.length < rs.highWaterMark) {
              this._read(rs.highWaterMark)
            }
          }

          function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options)
            Duplex.call(this, options)
            this._transformState = {
              afterTransform: afterTransform.bind(this),
              needTransform: false,
              transforming: false,
              writecb: null,
              writechunk: null,
              writeencoding: null,
            } // start out asking for a readable event once data is transformed.

            this._readableState.needReadable = true // we have implemented the _read method, and done the other things
            // that Readable wants before the first _read call, so unset the
            // sync guard flag.

            this._readableState.sync = false

            if (options) {
              if (typeof options.transform === 'function')
                this._transform = options.transform
              if (typeof options.flush === 'function')
                this._flush = options.flush
            } // When the writable side finishes, then flush out anything remaining.

            this.on('prefinish', prefinish)
          }

          function prefinish() {
            var _this = this

            if (
              typeof this._flush === 'function' &&
              !this._readableState.destroyed
            ) {
              this._flush(function (er, data) {
                done(_this, er, data)
              })
            } else {
              done(this, null, null)
            }
          }

          Transform.prototype.push = function (chunk, encoding) {
            this._transformState.needTransform = false
            return Duplex.prototype.push.call(this, chunk, encoding)
          } // This is the part where you do stuff!
          // override this function in implementation classes.
          // 'chunk' is an input chunk.
          //
          // Call `push(newChunk)` to pass along transformed output
          // to the readable side.  You may call 'push' zero or more times.
          //
          // Call `cb(err)` when you are done with this chunk.  If you pass
          // an error, then that'll put the hurt on the whole operation.  If you
          // never call cb(), then you'll never get another chunk.

          Transform.prototype._transform = function (chunk, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'))
          }

          Transform.prototype._write = function (chunk, encoding, cb) {
            var ts = this._transformState
            ts.writecb = cb
            ts.writechunk = chunk
            ts.writeencoding = encoding

            if (!ts.transforming) {
              var rs = this._readableState
              if (
                ts.needTransform ||
                rs.needReadable ||
                rs.length < rs.highWaterMark
              )
                this._read(rs.highWaterMark)
            }
          } // Doesn't matter what the args are here.
          // _transform does all the work.
          // That we got here means that the readable side wants more data.

          Transform.prototype._read = function (n) {
            var ts = this._transformState

            if (ts.writechunk !== null && !ts.transforming) {
              ts.transforming = true

              this._transform(
                ts.writechunk,
                ts.writeencoding,
                ts.afterTransform
              )
            } else {
              // mark that we need a transform, so that any data that comes in
              // will get processed, now that we've asked for it.
              ts.needTransform = true
            }
          }

          Transform.prototype._destroy = function (err, cb) {
            Duplex.prototype._destroy.call(this, err, function (err2) {
              cb(err2)
            })
          }

          function done(stream, er, data) {
            if (er) return stream.emit('error', er)
            if (data != null)
              // single equals check for both `null` and `undefined`
              stream.push(data) // TODO(BridgeAR): Write a test for these two error cases
            // if there's nothing in the write buffer, then that means
            // that nothing more will ever be provided

            if (stream._writableState.length)
              throw new ERR_TRANSFORM_WITH_LENGTH_0()
            if (stream._transformState.transforming)
              throw new ERR_TRANSFORM_ALREADY_TRANSFORMING()
            return stream.push(null)
          }
        },
        { '../errors': 29, './_stream_duplex': 30, inherits: 21 },
      ],
      34: [
        function (require, module, exports) {
          ;(function (process, global) {
            ;(function () {
              // Copyright Joyent, Inc. and other Node contributors.
              //
              // Permission is hereby granted, free of charge, to any person obtaining a
              // copy of this software and associated documentation files (the
              // "Software"), to deal in the Software without restriction, including
              // without limitation the rights to use, copy, modify, merge, publish,
              // distribute, sublicense, and/or sell copies of the Software, and to permit
              // persons to whom the Software is furnished to do so, subject to the
              // following conditions:
              //
              // The above copyright notice and this permission notice shall be included
              // in all copies or substantial portions of the Software.
              //
              // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
              // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
              // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
              // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
              // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
              // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
              // USE OR OTHER DEALINGS IN THE SOFTWARE.
              // A bit simpler than readable streams.
              // Implement an async ._write(chunk, encoding, cb), and it'll handle all
              // the drain event emission and buffering.
              'use strict'

              module.exports = Writable
              /* <replacement> */

              function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk
                this.encoding = encoding
                this.callback = cb
                this.next = null
              } // It seems a linked list but it is not
              // there will be only 2 of these for each stream

              function CorkedRequest(state) {
                var _this = this

                this.next = null
                this.entry = null

                this.finish = function () {
                  onCorkedFinish(_this, state)
                }
              }
              /* </replacement> */

              /*<replacement>*/

              var Duplex
              /*</replacement>*/

              Writable.WritableState = WritableState
              /*<replacement>*/

              var internalUtil = {
                deprecate: require('util-deprecate'),
              }
              /*</replacement>*/

              /*<replacement>*/

              var Stream = require('./internal/streams/stream')
              /*</replacement>*/

              var Buffer = require('buffer').Buffer

              var OurUint8Array = global.Uint8Array || function () {}

              function _uint8ArrayToBuffer(chunk) {
                return Buffer.from(chunk)
              }

              function _isUint8Array(obj) {
                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
              }

              var destroyImpl = require('./internal/streams/destroy')

              var _require = require('./internal/streams/state'),
                getHighWaterMark = _require.getHighWaterMark

              var _require$codes = require('../errors').codes,
                ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
                ERR_METHOD_NOT_IMPLEMENTED =
                  _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
                ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
                ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
                ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
                ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
                ERR_STREAM_WRITE_AFTER_END =
                  _require$codes.ERR_STREAM_WRITE_AFTER_END,
                ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING

              var errorOrDestroy = destroyImpl.errorOrDestroy

              require('inherits')(Writable, Stream)

              function nop() {}

              function WritableState(options, stream, isDuplex) {
                Duplex = Duplex || require('./_stream_duplex')
                options = options || {} // Duplex streams are both readable and writable, but share
                // the same options object.
                // However, some cases require setting options to different
                // values for the readable and the writable sides of the duplex stream,
                // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

                if (typeof isDuplex !== 'boolean')
                  isDuplex = stream instanceof Duplex // object stream flag to indicate whether or not this stream
                // contains buffers or objects.

                this.objectMode = !!options.objectMode
                if (isDuplex)
                  this.objectMode =
                    this.objectMode || !!options.writableObjectMode // the point at which write() starts returning false
                // Note: 0 is a valid value, means that we always return false if
                // the entire buffer is not flushed immediately on write()

                this.highWaterMark = getHighWaterMark(
                  this,
                  options,
                  'writableHighWaterMark',
                  isDuplex
                ) // if _final has been called

                this.finalCalled = false // drain event flag.

                this.needDrain = false // at the start of calling end()

                this.ending = false // when end() has been called, and returned

                this.ended = false // when 'finish' is emitted

                this.finished = false // has it been destroyed

                this.destroyed = false // should we decode strings into buffers before passing to _write?
                // this is here so that some node-core streams can optimize string
                // handling at a lower level.

                var noDecode = options.decodeStrings === false
                this.decodeStrings = !noDecode // Crypto is kind of old and crusty.  Historically, its default string
                // encoding is 'binary' so we have to make this configurable.
                // Everything else in the universe uses 'utf8', though.

                this.defaultEncoding = options.defaultEncoding || 'utf8' // not an actual buffer we keep track of, but a measurement
                // of how much we're waiting to get pushed to some underlying
                // socket or file.

                this.length = 0 // a flag to see when we're in the middle of a write.

                this.writing = false // when true all writes will be buffered until .uncork() call

                this.corked = 0 // a flag to be able to tell if the onwrite cb is called immediately,
                // or on a later tick.  We set this to true at first, because any
                // actions that shouldn't happen until "later" should generally also
                // not happen before the first write call.

                this.sync = true // a flag to know if we're processing previously buffered items, which
                // may call the _write() callback in the same tick, so that we don't
                // end up in an overlapped onwrite situation.

                this.bufferProcessing = false // the callback that's passed to _write(chunk,cb)

                this.onwrite = function (er) {
                  onwrite(stream, er)
                } // the callback that the user supplies to write(chunk,encoding,cb)

                this.writecb = null // the amount that is being written when _write is called.

                this.writelen = 0
                this.bufferedRequest = null
                this.lastBufferedRequest = null // number of pending user-supplied write callbacks
                // this must be 0 before 'finish' can be emitted

                this.pendingcb = 0 // emit prefinish if the only thing we're waiting for is _write cbs
                // This is relevant for synchronous Transform streams

                this.prefinished = false // True if the error was already emitted and should not be thrown again

                this.errorEmitted = false // Should close be emitted on destroy. Defaults to true.

                this.emitClose = options.emitClose !== false // Should .destroy() be called after 'finish' (and potentially 'end')

                this.autoDestroy = !!options.autoDestroy // count buffered requests

                this.bufferedRequestCount = 0 // allocate the first CorkedRequest, there is always
                // one allocated and free to use, and we maintain at most two

                this.corkedRequestsFree = new CorkedRequest(this)
              }

              WritableState.prototype.getBuffer = function getBuffer() {
                var current = this.bufferedRequest
                var out = []

                while (current) {
                  out.push(current)
                  current = current.next
                }

                return out
              }

              ;(function () {
                try {
                  Object.defineProperty(WritableState.prototype, 'buffer', {
                    get: internalUtil.deprecate(
                      function writableStateBufferGetter() {
                        return this.getBuffer()
                      },
                      '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +
                        'instead.',
                      'DEP0003'
                    ),
                  })
                } catch (_) {}
              })() // Test _writableState for inheritance to account for Duplex streams,
              // whose prototype chain only points to Readable.

              var realHasInstance

              if (
                typeof Symbol === 'function' &&
                Symbol.hasInstance &&
                typeof Function.prototype[Symbol.hasInstance] === 'function'
              ) {
                realHasInstance = Function.prototype[Symbol.hasInstance]
                Object.defineProperty(Writable, Symbol.hasInstance, {
                  value: function value(object) {
                    if (realHasInstance.call(this, object)) return true
                    if (this !== Writable) return false
                    return (
                      object && object._writableState instanceof WritableState
                    )
                  },
                })
              } else {
                realHasInstance = function realHasInstance(object) {
                  return object instanceof this
                }
              }

              function Writable(options) {
                Duplex = Duplex || require('./_stream_duplex') // Writable ctor is applied to Duplexes, too.
                // `realHasInstance` is necessary because using plain `instanceof`
                // would return false, as no `_writableState` property is attached.
                // Trying to use the custom `instanceof` for Writable here will also break the
                // Node.js LazyTransform implementation, which has a non-trivial getter for
                // `_writableState` that would lead to infinite recursion.
                // Checking for a Stream.Duplex instance is faster here instead of inside
                // the WritableState constructor, at least with V8 6.5

                var isDuplex = this instanceof Duplex
                if (!isDuplex && !realHasInstance.call(Writable, this))
                  return new Writable(options)
                this._writableState = new WritableState(options, this, isDuplex) // legacy.

                this.writable = true

                if (options) {
                  if (typeof options.write === 'function')
                    this._write = options.write
                  if (typeof options.writev === 'function')
                    this._writev = options.writev
                  if (typeof options.destroy === 'function')
                    this._destroy = options.destroy
                  if (typeof options.final === 'function')
                    this._final = options.final
                }

                Stream.call(this)
              } // Otherwise people can pipe Writable streams, which is just wrong.

              Writable.prototype.pipe = function () {
                errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE())
              }

              function writeAfterEnd(stream, cb) {
                var er = new ERR_STREAM_WRITE_AFTER_END() // TODO: defer error events consistently everywhere, not just the cb

                errorOrDestroy(stream, er)
                process.nextTick(cb, er)
              } // Checks that a user-supplied chunk is valid, especially for the particular
              // mode the stream is in. Currently this means that `null` is never accepted
              // and undefined/non-string values are only allowed in object mode.

              function validChunk(stream, state, chunk, cb) {
                var er

                if (chunk === null) {
                  er = new ERR_STREAM_NULL_VALUES()
                } else if (typeof chunk !== 'string' && !state.objectMode) {
                  er = new ERR_INVALID_ARG_TYPE(
                    'chunk',
                    ['string', 'Buffer'],
                    chunk
                  )
                }

                if (er) {
                  errorOrDestroy(stream, er)
                  process.nextTick(cb, er)
                  return false
                }

                return true
              }

              Writable.prototype.write = function (chunk, encoding, cb) {
                var state = this._writableState
                var ret = false

                var isBuf = !state.objectMode && _isUint8Array(chunk)

                if (isBuf && !Buffer.isBuffer(chunk)) {
                  chunk = _uint8ArrayToBuffer(chunk)
                }

                if (typeof encoding === 'function') {
                  cb = encoding
                  encoding = null
                }

                if (isBuf) encoding = 'buffer'
                else if (!encoding) encoding = state.defaultEncoding
                if (typeof cb !== 'function') cb = nop
                if (state.ending) writeAfterEnd(this, cb)
                else if (isBuf || validChunk(this, state, chunk, cb)) {
                  state.pendingcb++
                  ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb)
                }
                return ret
              }

              Writable.prototype.cork = function () {
                this._writableState.corked++
              }

              Writable.prototype.uncork = function () {
                var state = this._writableState

                if (state.corked) {
                  state.corked--
                  if (
                    !state.writing &&
                    !state.corked &&
                    !state.bufferProcessing &&
                    state.bufferedRequest
                  )
                    clearBuffer(this, state)
                }
              }

              Writable.prototype.setDefaultEncoding =
                function setDefaultEncoding(encoding) {
                  // node::ParseEncoding() requires lower case.
                  if (typeof encoding === 'string')
                    encoding = encoding.toLowerCase()
                  if (
                    !(
                      [
                        'hex',
                        'utf8',
                        'utf-8',
                        'ascii',
                        'binary',
                        'base64',
                        'ucs2',
                        'ucs-2',
                        'utf16le',
                        'utf-16le',
                        'raw',
                      ].indexOf((encoding + '').toLowerCase()) > -1
                    )
                  )
                    throw new ERR_UNKNOWN_ENCODING(encoding)
                  this._writableState.defaultEncoding = encoding
                  return this
                }

              Object.defineProperty(Writable.prototype, 'writableBuffer', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState && this._writableState.getBuffer()
                },
              })

              function decodeChunk(state, chunk, encoding) {
                if (
                  !state.objectMode &&
                  state.decodeStrings !== false &&
                  typeof chunk === 'string'
                ) {
                  chunk = Buffer.from(chunk, encoding)
                }

                return chunk
              }

              Object.defineProperty(
                Writable.prototype,
                'writableHighWaterMark',
                {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.highWaterMark
                  },
                }
              ) // if we're already writing something, then just put this
              // in the queue, and wait our turn.  Otherwise, call _write
              // If we return false, then we need a drain event, so set that flag.

              function writeOrBuffer(
                stream,
                state,
                isBuf,
                chunk,
                encoding,
                cb
              ) {
                if (!isBuf) {
                  var newChunk = decodeChunk(state, chunk, encoding)

                  if (chunk !== newChunk) {
                    isBuf = true
                    encoding = 'buffer'
                    chunk = newChunk
                  }
                }

                var len = state.objectMode ? 1 : chunk.length
                state.length += len
                var ret = state.length < state.highWaterMark // we must ensure that previous needDrain will not be reset to false.

                if (!ret) state.needDrain = true

                if (state.writing || state.corked) {
                  var last = state.lastBufferedRequest
                  state.lastBufferedRequest = {
                    chunk: chunk,
                    encoding: encoding,
                    isBuf: isBuf,
                    callback: cb,
                    next: null,
                  }

                  if (last) {
                    last.next = state.lastBufferedRequest
                  } else {
                    state.bufferedRequest = state.lastBufferedRequest
                  }

                  state.bufferedRequestCount += 1
                } else {
                  doWrite(stream, state, false, len, chunk, encoding, cb)
                }

                return ret
              }

              function doWrite(
                stream,
                state,
                writev,
                len,
                chunk,
                encoding,
                cb
              ) {
                state.writelen = len
                state.writecb = cb
                state.writing = true
                state.sync = true
                if (state.destroyed)
                  state.onwrite(new ERR_STREAM_DESTROYED('write'))
                else if (writev) stream._writev(chunk, state.onwrite)
                else stream._write(chunk, encoding, state.onwrite)
                state.sync = false
              }

              function onwriteError(stream, state, sync, er, cb) {
                --state.pendingcb

                if (sync) {
                  // defer the callback if we are being called synchronously
                  // to avoid piling up things on the stack
                  process.nextTick(cb, er) // this can emit finish, and it will always happen
                  // after error

                  process.nextTick(finishMaybe, stream, state)
                  stream._writableState.errorEmitted = true
                  errorOrDestroy(stream, er)
                } else {
                  // the caller expect this to happen before if
                  // it is async
                  cb(er)
                  stream._writableState.errorEmitted = true
                  errorOrDestroy(stream, er) // this can emit finish, but finish must
                  // always follow error

                  finishMaybe(stream, state)
                }
              }

              function onwriteStateUpdate(state) {
                state.writing = false
                state.writecb = null
                state.length -= state.writelen
                state.writelen = 0
              }

              function onwrite(stream, er) {
                var state = stream._writableState
                var sync = state.sync
                var cb = state.writecb
                if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK()
                onwriteStateUpdate(state)
                if (er) onwriteError(stream, state, sync, er, cb)
                else {
                  // Check if we're actually ready to finish, but don't emit yet
                  var finished = needFinish(state) || stream.destroyed

                  if (
                    !finished &&
                    !state.corked &&
                    !state.bufferProcessing &&
                    state.bufferedRequest
                  ) {
                    clearBuffer(stream, state)
                  }

                  if (sync) {
                    process.nextTick(afterWrite, stream, state, finished, cb)
                  } else {
                    afterWrite(stream, state, finished, cb)
                  }
                }
              }

              function afterWrite(stream, state, finished, cb) {
                if (!finished) onwriteDrain(stream, state)
                state.pendingcb--
                cb()
                finishMaybe(stream, state)
              } // Must force callback to be called on nextTick, so that we don't
              // emit 'drain' before the write() consumer gets the 'false' return
              // value, and has a chance to attach a 'drain' listener.

              function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                  state.needDrain = false
                  stream.emit('drain')
                }
              } // if there's something in the buffer waiting, then process it

              function clearBuffer(stream, state) {
                state.bufferProcessing = true
                var entry = state.bufferedRequest

                if (stream._writev && entry && entry.next) {
                  // Fast case, write everything using _writev()
                  var l = state.bufferedRequestCount
                  var buffer = new Array(l)
                  var holder = state.corkedRequestsFree
                  holder.entry = entry
                  var count = 0
                  var allBuffers = true

                  while (entry) {
                    buffer[count] = entry
                    if (!entry.isBuf) allBuffers = false
                    entry = entry.next
                    count += 1
                  }

                  buffer.allBuffers = allBuffers
                  doWrite(
                    stream,
                    state,
                    true,
                    state.length,
                    buffer,
                    '',
                    holder.finish
                  ) // doWrite is almost always async, defer these to save a bit of time
                  // as the hot path ends with doWrite

                  state.pendingcb++
                  state.lastBufferedRequest = null

                  if (holder.next) {
                    state.corkedRequestsFree = holder.next
                    holder.next = null
                  } else {
                    state.corkedRequestsFree = new CorkedRequest(state)
                  }

                  state.bufferedRequestCount = 0
                } else {
                  // Slow case, write chunks one-by-one
                  while (entry) {
                    var chunk = entry.chunk
                    var encoding = entry.encoding
                    var cb = entry.callback
                    var len = state.objectMode ? 1 : chunk.length
                    doWrite(stream, state, false, len, chunk, encoding, cb)
                    entry = entry.next
                    state.bufferedRequestCount-- // if we didn't call the onwrite immediately, then
                    // it means that we need to wait until it does.
                    // also, that means that the chunk and cb are currently
                    // being processed, so move the buffer counter past them.

                    if (state.writing) {
                      break
                    }
                  }

                  if (entry === null) state.lastBufferedRequest = null
                }

                state.bufferedRequest = entry
                state.bufferProcessing = false
              }

              Writable.prototype._write = function (chunk, encoding, cb) {
                cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'))
              }

              Writable.prototype._writev = null

              Writable.prototype.end = function (chunk, encoding, cb) {
                var state = this._writableState

                if (typeof chunk === 'function') {
                  cb = chunk
                  chunk = null
                  encoding = null
                } else if (typeof encoding === 'function') {
                  cb = encoding
                  encoding = null
                }

                if (chunk !== null && chunk !== undefined)
                  this.write(chunk, encoding) // .end() fully uncorks

                if (state.corked) {
                  state.corked = 1
                  this.uncork()
                } // ignore unnecessary end() calls.

                if (!state.ending) endWritable(this, state, cb)
                return this
              }

              Object.defineProperty(Writable.prototype, 'writableLength', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  return this._writableState.length
                },
              })

              function needFinish(state) {
                return (
                  state.ending &&
                  state.length === 0 &&
                  state.bufferedRequest === null &&
                  !state.finished &&
                  !state.writing
                )
              }

              function callFinal(stream, state) {
                stream._final(function (err) {
                  state.pendingcb--

                  if (err) {
                    errorOrDestroy(stream, err)
                  }

                  state.prefinished = true
                  stream.emit('prefinish')
                  finishMaybe(stream, state)
                })
              }

              function prefinish(stream, state) {
                if (!state.prefinished && !state.finalCalled) {
                  if (typeof stream._final === 'function' && !state.destroyed) {
                    state.pendingcb++
                    state.finalCalled = true
                    process.nextTick(callFinal, stream, state)
                  } else {
                    state.prefinished = true
                    stream.emit('prefinish')
                  }
                }
              }

              function finishMaybe(stream, state) {
                var need = needFinish(state)

                if (need) {
                  prefinish(stream, state)

                  if (state.pendingcb === 0) {
                    state.finished = true
                    stream.emit('finish')

                    if (state.autoDestroy) {
                      // In case of duplex streams we need a way to detect
                      // if the readable side is ready for autoDestroy as well
                      var rState = stream._readableState

                      if (
                        !rState ||
                        (rState.autoDestroy && rState.endEmitted)
                      ) {
                        stream.destroy()
                      }
                    }
                  }
                }

                return need
              }

              function endWritable(stream, state, cb) {
                state.ending = true
                finishMaybe(stream, state)

                if (cb) {
                  if (state.finished) process.nextTick(cb)
                  else stream.once('finish', cb)
                }

                state.ended = true
                stream.writable = false
              }

              function onCorkedFinish(corkReq, state, err) {
                var entry = corkReq.entry
                corkReq.entry = null

                while (entry) {
                  var cb = entry.callback
                  state.pendingcb--
                  cb(err)
                  entry = entry.next
                } // reuse the free corkReq.

                state.corkedRequestsFree.next = corkReq
              }

              Object.defineProperty(Writable.prototype, 'destroyed', {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get() {
                  if (this._writableState === undefined) {
                    return false
                  }

                  return this._writableState.destroyed
                },
                set: function set(value) {
                  // we ignore the value if the stream
                  // has not been initialized yet
                  if (!this._writableState) {
                    return
                  } // backward compatibility, the user is explicitly
                  // managing destroyed

                  this._writableState.destroyed = value
                },
              })
              Writable.prototype.destroy = destroyImpl.destroy
              Writable.prototype._undestroy = destroyImpl.undestroy

              Writable.prototype._destroy = function (err, cb) {
                cb(err)
              }
            }.call(this))
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ))
        },
        {
          '../errors': 29,
          './_stream_duplex': 30,
          './internal/streams/destroy': 37,
          './internal/streams/state': 41,
          './internal/streams/stream': 42,
          _process: 45,
          buffer: 18,
          inherits: 21,
          'util-deprecate': 60,
        },
      ],
      35: [
        function (require, module, exports) {
          ;(function (process) {
            ;(function () {
              'use strict'

              var _Object$setPrototypeO

              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true,
                  })
                } else {
                  obj[key] = value
                }
                return obj
              }

              var finished = require('./end-of-stream')

              var kLastResolve = Symbol('lastResolve')
              var kLastReject = Symbol('lastReject')
              var kError = Symbol('error')
              var kEnded = Symbol('ended')
              var kLastPromise = Symbol('lastPromise')
              var kHandlePromise = Symbol('handlePromise')
              var kStream = Symbol('stream')

              function createIterResult(value, done) {
                return {
                  value: value,
                  done: done,
                }
              }

              function readAndResolve(iter) {
                var resolve = iter[kLastResolve]

                if (resolve !== null) {
                  var data = iter[kStream].read() // we defer if data is null
                  // we can be expecting either 'end' or
                  // 'error'

                  if (data !== null) {
                    iter[kLastPromise] = null
                    iter[kLastResolve] = null
                    iter[kLastReject] = null
                    resolve(createIterResult(data, false))
                  }
                }
              }

              function onReadable(iter) {
                // we wait for the next tick, because it might
                // emit an error with process.nextTick
                process.nextTick(readAndResolve, iter)
              }

              function wrapForNext(lastPromise, iter) {
                return function (resolve, reject) {
                  lastPromise.then(function () {
                    if (iter[kEnded]) {
                      resolve(createIterResult(undefined, true))
                      return
                    }

                    iter[kHandlePromise](resolve, reject)
                  }, reject)
                }
              }

              var AsyncIteratorPrototype = Object.getPrototypeOf(function () {})
              var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf(
                ((_Object$setPrototypeO = {
                  get stream() {
                    return this[kStream]
                  },

                  next: function next() {
                    var _this = this

                    // if we have detected an error in the meanwhile
                    // reject straight away
                    var error = this[kError]

                    if (error !== null) {
                      return Promise.reject(error)
                    }

                    if (this[kEnded]) {
                      return Promise.resolve(createIterResult(undefined, true))
                    }

                    if (this[kStream].destroyed) {
                      // We need to defer via nextTick because if .destroy(err) is
                      // called, the error will be emitted via nextTick, and
                      // we cannot guarantee that there is no error lingering around
                      // waiting to be emitted.
                      return new Promise(function (resolve, reject) {
                        process.nextTick(function () {
                          if (_this[kError]) {
                            reject(_this[kError])
                          } else {
                            resolve(createIterResult(undefined, true))
                          }
                        })
                      })
                    } // if we have multiple next() calls
                    // we will wait for the previous Promise to finish
                    // this logic is optimized to support for await loops,
                    // where next() is only called once at a time

                    var lastPromise = this[kLastPromise]
                    var promise

                    if (lastPromise) {
                      promise = new Promise(wrapForNext(lastPromise, this))
                    } else {
                      // fast path needed to support multiple this.push()
                      // without triggering the next() queue
                      var data = this[kStream].read()

                      if (data !== null) {
                        return Promise.resolve(createIterResult(data, false))
                      }

                      promise = new Promise(this[kHandlePromise])
                    }

                    this[kLastPromise] = promise
                    return promise
                  },
                }),
                _defineProperty(
                  _Object$setPrototypeO,
                  Symbol.asyncIterator,
                  function () {
                    return this
                  }
                ),
                _defineProperty(
                  _Object$setPrototypeO,
                  'return',
                  function _return() {
                    var _this2 = this

                    // destroy(err, cb) is a private API
                    // we can guarantee we have that here, because we control the
                    // Readable class this is attached to
                    return new Promise(function (resolve, reject) {
                      _this2[kStream].destroy(null, function (err) {
                        if (err) {
                          reject(err)
                          return
                        }

                        resolve(createIterResult(undefined, true))
                      })
                    })
                  }
                ),
                _Object$setPrototypeO),
                AsyncIteratorPrototype
              )

              var createReadableStreamAsyncIterator =
                function createReadableStreamAsyncIterator(stream) {
                  var _Object$create

                  var iterator = Object.create(
                    ReadableStreamAsyncIteratorPrototype,
                    ((_Object$create = {}),
                    _defineProperty(_Object$create, kStream, {
                      value: stream,
                      writable: true,
                    }),
                    _defineProperty(_Object$create, kLastResolve, {
                      value: null,
                      writable: true,
                    }),
                    _defineProperty(_Object$create, kLastReject, {
                      value: null,
                      writable: true,
                    }),
                    _defineProperty(_Object$create, kError, {
                      value: null,
                      writable: true,
                    }),
                    _defineProperty(_Object$create, kEnded, {
                      value: stream._readableState.endEmitted,
                      writable: true,
                    }),
                    _defineProperty(_Object$create, kHandlePromise, {
                      value: function value(resolve, reject) {
                        var data = iterator[kStream].read()

                        if (data) {
                          iterator[kLastPromise] = null
                          iterator[kLastResolve] = null
                          iterator[kLastReject] = null
                          resolve(createIterResult(data, false))
                        } else {
                          iterator[kLastResolve] = resolve
                          iterator[kLastReject] = reject
                        }
                      },
                      writable: true,
                    }),
                    _Object$create)
                  )
                  iterator[kLastPromise] = null
                  finished(stream, function (err) {
                    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
                      var reject = iterator[kLastReject] // reject if we are waiting for data in the Promise
                      // returned by next() and store the error

                      if (reject !== null) {
                        iterator[kLastPromise] = null
                        iterator[kLastResolve] = null
                        iterator[kLastReject] = null
                        reject(err)
                      }

                      iterator[kError] = err
                      return
                    }

                    var resolve = iterator[kLastResolve]

                    if (resolve !== null) {
                      iterator[kLastPromise] = null
                      iterator[kLastResolve] = null
                      iterator[kLastReject] = null
                      resolve(createIterResult(undefined, true))
                    }

                    iterator[kEnded] = true
                  })
                  stream.on('readable', onReadable.bind(null, iterator))
                  return iterator
                }

              module.exports = createReadableStreamAsyncIterator
            }.call(this))
          }.call(this, require('_process')))
        },
        { './end-of-stream': 38, _process: 45 },
      ],
      36: [
        function (require, module, exports) {
          'use strict'

          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object)
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object)
              if (enumerableOnly)
                symbols = symbols.filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable
                })
              keys.push.apply(keys, symbols)
            }
            return keys
          }

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {}
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function (key) {
                  _defineProperty(target, key, source[key])
                })
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(
                  target,
                  Object.getOwnPropertyDescriptors(source)
                )
              } else {
                ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(source, key)
                  )
                })
              }
            }
            return target
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true,
              })
            } else {
              obj[key] = value
            }
            return obj
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function')
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i]
              descriptor.enumerable = descriptor.enumerable || false
              descriptor.configurable = true
              if ('value' in descriptor) descriptor.writable = true
              Object.defineProperty(target, descriptor.key, descriptor)
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps)
            if (staticProps) _defineProperties(Constructor, staticProps)
            return Constructor
          }

          var _require = require('buffer'),
            Buffer = _require.Buffer

          var _require2 = require('util'),
            inspect = _require2.inspect

          var custom = (inspect && inspect.custom) || 'inspect'

          function copyBuffer(src, target, offset) {
            Buffer.prototype.copy.call(src, target, offset)
          }

          module.exports =
            /*#__PURE__*/
            (function () {
              function BufferList() {
                _classCallCheck(this, BufferList)

                this.head = null
                this.tail = null
                this.length = 0
              }

              _createClass(BufferList, [
                {
                  key: 'push',
                  value: function push(v) {
                    var entry = {
                      data: v,
                      next: null,
                    }
                    if (this.length > 0) this.tail.next = entry
                    else this.head = entry
                    this.tail = entry
                    ++this.length
                  },
                },
                {
                  key: 'unshift',
                  value: function unshift(v) {
                    var entry = {
                      data: v,
                      next: this.head,
                    }
                    if (this.length === 0) this.tail = entry
                    this.head = entry
                    ++this.length
                  },
                },
                {
                  key: 'shift',
                  value: function shift() {
                    if (this.length === 0) return
                    var ret = this.head.data
                    if (this.length === 1) this.head = this.tail = null
                    else this.head = this.head.next
                    --this.length
                    return ret
                  },
                },
                {
                  key: 'clear',
                  value: function clear() {
                    this.head = this.tail = null
                    this.length = 0
                  },
                },
                {
                  key: 'join',
                  value: function join(s) {
                    if (this.length === 0) return ''
                    var p = this.head
                    var ret = '' + p.data

                    while ((p = p.next)) {
                      ret += s + p.data
                    }

                    return ret
                  },
                },
                {
                  key: 'concat',
                  value: function concat(n) {
                    if (this.length === 0) return Buffer.alloc(0)
                    var ret = Buffer.allocUnsafe(n >>> 0)
                    var p = this.head
                    var i = 0

                    while (p) {
                      copyBuffer(p.data, ret, i)
                      i += p.data.length
                      p = p.next
                    }

                    return ret
                  }, // Consumes a specified amount of bytes or characters from the buffered data.
                },
                {
                  key: 'consume',
                  value: function consume(n, hasStrings) {
                    var ret

                    if (n < this.head.data.length) {
                      // `slice` is the same for buffers and strings.
                      ret = this.head.data.slice(0, n)
                      this.head.data = this.head.data.slice(n)
                    } else if (n === this.head.data.length) {
                      // First chunk is a perfect match.
                      ret = this.shift()
                    } else {
                      // Result spans more than one buffer.
                      ret = hasStrings ? this._getString(n) : this._getBuffer(n)
                    }

                    return ret
                  },
                },
                {
                  key: 'first',
                  value: function first() {
                    return this.head.data
                  }, // Consumes a specified amount of characters from the buffered data.
                },
                {
                  key: '_getString',
                  value: function _getString(n) {
                    var p = this.head
                    var c = 1
                    var ret = p.data
                    n -= ret.length

                    while ((p = p.next)) {
                      var str = p.data
                      var nb = n > str.length ? str.length : n
                      if (nb === str.length) ret += str
                      else ret += str.slice(0, n)
                      n -= nb

                      if (n === 0) {
                        if (nb === str.length) {
                          ++c
                          if (p.next) this.head = p.next
                          else this.head = this.tail = null
                        } else {
                          this.head = p
                          p.data = str.slice(nb)
                        }

                        break
                      }

                      ++c
                    }

                    this.length -= c
                    return ret
                  }, // Consumes a specified amount of bytes from the buffered data.
                },
                {
                  key: '_getBuffer',
                  value: function _getBuffer(n) {
                    var ret = Buffer.allocUnsafe(n)
                    var p = this.head
                    var c = 1
                    p.data.copy(ret)
                    n -= p.data.length

                    while ((p = p.next)) {
                      var buf = p.data
                      var nb = n > buf.length ? buf.length : n
                      buf.copy(ret, ret.length - n, 0, nb)
                      n -= nb

                      if (n === 0) {
                        if (nb === buf.length) {
                          ++c
                          if (p.next) this.head = p.next
                          else this.head = this.tail = null
                        } else {
                          this.head = p
                          p.data = buf.slice(nb)
                        }

                        break
                      }

                      ++c
                    }

                    this.length -= c
                    return ret
                  }, // Make sure the linked list only shows the minimal necessary information.
                },
                {
                  key: custom,
                  value: function value(_, options) {
                    return inspect(
                      this,
                      _objectSpread({}, options, {
                        // Only inspect one level.
                        depth: 0,
                        // It should not recurse.
                        customInspect: false,
                      })
                    )
                  },
                },
              ])

              return BufferList
            })()
        },
        { buffer: 18, util: 17 },
      ],
      37: [
        function (require, module, exports) {
          ;(function (process) {
            ;(function () {
              'use strict' // undocumented cb() API, needed for core, not for public API

              function destroy(err, cb) {
                var _this = this

                var readableDestroyed =
                  this._readableState && this._readableState.destroyed
                var writableDestroyed =
                  this._writableState && this._writableState.destroyed

                if (readableDestroyed || writableDestroyed) {
                  if (cb) {
                    cb(err)
                  } else if (err) {
                    if (!this._writableState) {
                      process.nextTick(emitErrorNT, this, err)
                    } else if (!this._writableState.errorEmitted) {
                      this._writableState.errorEmitted = true
                      process.nextTick(emitErrorNT, this, err)
                    }
                  }

                  return this
                } // we set destroyed to true before firing error callbacks in order
                // to make it re-entrance safe in case destroy() is called within callbacks

                if (this._readableState) {
                  this._readableState.destroyed = true
                } // if this is a duplex stream mark the writable part as destroyed as well

                if (this._writableState) {
                  this._writableState.destroyed = true
                }

                this._destroy(err || null, function (err) {
                  if (!cb && err) {
                    if (!_this._writableState) {
                      process.nextTick(emitErrorAndCloseNT, _this, err)
                    } else if (!_this._writableState.errorEmitted) {
                      _this._writableState.errorEmitted = true
                      process.nextTick(emitErrorAndCloseNT, _this, err)
                    } else {
                      process.nextTick(emitCloseNT, _this)
                    }
                  } else if (cb) {
                    process.nextTick(emitCloseNT, _this)
                    cb(err)
                  } else {
                    process.nextTick(emitCloseNT, _this)
                  }
                })

                return this
              }

              function emitErrorAndCloseNT(self, err) {
                emitErrorNT(self, err)
                emitCloseNT(self)
              }

              function emitCloseNT(self) {
                if (self._writableState && !self._writableState.emitClose)
                  return
                if (self._readableState && !self._readableState.emitClose)
                  return
                self.emit('close')
              }

              function undestroy() {
                if (this._readableState) {
                  this._readableState.destroyed = false
                  this._readableState.reading = false
                  this._readableState.ended = false
                  this._readableState.endEmitted = false
                }

                if (this._writableState) {
                  this._writableState.destroyed = false
                  this._writableState.ended = false
                  this._writableState.ending = false
                  this._writableState.finalCalled = false
                  this._writableState.prefinished = false
                  this._writableState.finished = false
                  this._writableState.errorEmitted = false
                }
              }

              function emitErrorNT(self, err) {
                self.emit('error', err)
              }

              function errorOrDestroy(stream, err) {
                // We have tests that rely on errors being emitted
                // in the same tick, so changing this is semver major.
                // For now when you opt-in to autoDestroy we allow
                // the error to be emitted nextTick. In a future
                // semver major update we should change the default to this.
                var rState = stream._readableState
                var wState = stream._writableState
                if (
                  (rState && rState.autoDestroy) ||
                  (wState && wState.autoDestroy)
                )
                  stream.destroy(err)
                else stream.emit('error', err)
              }

              module.exports = {
                destroy: destroy,
                undestroy: undestroy,
                errorOrDestroy: errorOrDestroy,
              }
            }.call(this))
          }.call(this, require('_process')))
        },
        { _process: 45 },
      ],
      38: [
        function (require, module, exports) {
          // Ported from https://github.com/mafintosh/end-of-stream with
          // permission from the author, Mathias Buus (@mafintosh).
          'use strict'

          var ERR_STREAM_PREMATURE_CLOSE =
            require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE

          function once(callback) {
            var called = false
            return function () {
              if (called) return
              called = true

              for (
                var _len = arguments.length, args = new Array(_len), _key = 0;
                _key < _len;
                _key++
              ) {
                args[_key] = arguments[_key]
              }

              callback.apply(this, args)
            }
          }

          function noop() {}

          function isRequest(stream) {
            return stream.setHeader && typeof stream.abort === 'function'
          }

          function eos(stream, opts, callback) {
            if (typeof opts === 'function') return eos(stream, null, opts)
            if (!opts) opts = {}
            callback = once(callback || noop)
            var readable =
              opts.readable || (opts.readable !== false && stream.readable)
            var writable =
              opts.writable || (opts.writable !== false && stream.writable)

            var onlegacyfinish = function onlegacyfinish() {
              if (!stream.writable) onfinish()
            }

            var writableEnded =
              stream._writableState && stream._writableState.finished

            var onfinish = function onfinish() {
              writable = false
              writableEnded = true
              if (!readable) callback.call(stream)
            }

            var readableEnded =
              stream._readableState && stream._readableState.endEmitted

            var onend = function onend() {
              readable = false
              readableEnded = true
              if (!writable) callback.call(stream)
            }

            var onerror = function onerror(err) {
              callback.call(stream, err)
            }

            var onclose = function onclose() {
              var err

              if (readable && !readableEnded) {
                if (!stream._readableState || !stream._readableState.ended)
                  err = new ERR_STREAM_PREMATURE_CLOSE()
                return callback.call(stream, err)
              }

              if (writable && !writableEnded) {
                if (!stream._writableState || !stream._writableState.ended)
                  err = new ERR_STREAM_PREMATURE_CLOSE()
                return callback.call(stream, err)
              }
            }

            var onrequest = function onrequest() {
              stream.req.on('finish', onfinish)
            }

            if (isRequest(stream)) {
              stream.on('complete', onfinish)
              stream.on('abort', onclose)
              if (stream.req) onrequest()
              else stream.on('request', onrequest)
            } else if (writable && !stream._writableState) {
              // legacy streams
              stream.on('end', onlegacyfinish)
              stream.on('close', onlegacyfinish)
            }

            stream.on('end', onend)
            stream.on('finish', onfinish)
            if (opts.error !== false) stream.on('error', onerror)
            stream.on('close', onclose)
            return function () {
              stream.removeListener('complete', onfinish)
              stream.removeListener('abort', onclose)
              stream.removeListener('request', onrequest)
              if (stream.req) stream.req.removeListener('finish', onfinish)
              stream.removeListener('end', onlegacyfinish)
              stream.removeListener('close', onlegacyfinish)
              stream.removeListener('finish', onfinish)
              stream.removeListener('end', onend)
              stream.removeListener('error', onerror)
              stream.removeListener('close', onclose)
            }
          }

          module.exports = eos
        },
        { '../../../errors': 29 },
      ],
      39: [
        function (require, module, exports) {
          module.exports = function () {
            throw new Error('Readable.from is not available in the browser')
          }
        },
        {},
      ],
      40: [
        function (require, module, exports) {
          // Ported from https://github.com/mafintosh/pump with
          // permission from the author, Mathias Buus (@mafintosh).
          'use strict'

          var eos

          function once(callback) {
            var called = false
            return function () {
              if (called) return
              called = true
              callback.apply(void 0, arguments)
            }
          }

          var _require$codes = require('../../../errors').codes,
            ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
            ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED

          function noop(err) {
            // Rethrow the error if it exists to avoid swallowing it
            if (err) throw err
          }

          function isRequest(stream) {
            return stream.setHeader && typeof stream.abort === 'function'
          }

          function destroyer(stream, reading, writing, callback) {
            callback = once(callback)
            var closed = false
            stream.on('close', function () {
              closed = true
            })
            if (eos === undefined) eos = require('./end-of-stream')
            eos(
              stream,
              {
                readable: reading,
                writable: writing,
              },
              function (err) {
                if (err) return callback(err)
                closed = true
                callback()
              }
            )
            var destroyed = false
            return function (err) {
              if (closed) return
              if (destroyed) return
              destroyed = true // request.destroy just do .end - .abort is what we want

              if (isRequest(stream)) return stream.abort()
              if (typeof stream.destroy === 'function') return stream.destroy()
              callback(err || new ERR_STREAM_DESTROYED('pipe'))
            }
          }

          function call(fn) {
            fn()
          }

          function pipe(from, to) {
            return from.pipe(to)
          }

          function popCallback(streams) {
            if (!streams.length) return noop
            if (typeof streams[streams.length - 1] !== 'function') return noop
            return streams.pop()
          }

          function pipeline() {
            for (
              var _len = arguments.length, streams = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              streams[_key] = arguments[_key]
            }

            var callback = popCallback(streams)
            if (Array.isArray(streams[0])) streams = streams[0]

            if (streams.length < 2) {
              throw new ERR_MISSING_ARGS('streams')
            }

            var error
            var destroys = streams.map(function (stream, i) {
              var reading = i < streams.length - 1
              var writing = i > 0
              return destroyer(stream, reading, writing, function (err) {
                if (!error) error = err
                if (err) destroys.forEach(call)
                if (reading) return
                destroys.forEach(call)
                callback(error)
              })
            })
            return streams.reduce(pipe)
          }

          module.exports = pipeline
        },
        { '../../../errors': 29, './end-of-stream': 38 },
      ],
      41: [
        function (require, module, exports) {
          'use strict'

          var ERR_INVALID_OPT_VALUE =
            require('../../../errors').codes.ERR_INVALID_OPT_VALUE

          function highWaterMarkFrom(options, isDuplex, duplexKey) {
            return options.highWaterMark != null
              ? options.highWaterMark
              : isDuplex
              ? options[duplexKey]
              : null
          }

          function getHighWaterMark(state, options, duplexKey, isDuplex) {
            var hwm = highWaterMarkFrom(options, isDuplex, duplexKey)

            if (hwm != null) {
              if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
                var name = isDuplex ? duplexKey : 'highWaterMark'
                throw new ERR_INVALID_OPT_VALUE(name, hwm)
              }

              return Math.floor(hwm)
            } // Default value

            return state.objectMode ? 16 : 16 * 1024
          }

          module.exports = {
            getHighWaterMark: getHighWaterMark,
          }
        },
        { '../../../errors': 29 },
      ],
      42: [
        function (require, module, exports) {
          module.exports = require('events').EventEmitter
        },
        { events: 19 },
      ],
      43: [
        function (require, module, exports) {
          exports = module.exports = require('./lib/_stream_readable.js')
          exports.Stream = exports
          exports.Readable = exports
          exports.Writable = require('./lib/_stream_writable.js')
          exports.Duplex = require('./lib/_stream_duplex.js')
          exports.Transform = require('./lib/_stream_transform.js')
          exports.PassThrough = require('./lib/_stream_passthrough.js')
          exports.finished = require('./lib/internal/streams/end-of-stream.js')
          exports.pipeline = require('./lib/internal/streams/pipeline.js')
        },
        {
          './lib/_stream_duplex.js': 30,
          './lib/_stream_passthrough.js': 31,
          './lib/_stream_readable.js': 32,
          './lib/_stream_transform.js': 33,
          './lib/_stream_writable.js': 34,
          './lib/internal/streams/end-of-stream.js': 38,
          './lib/internal/streams/pipeline.js': 40,
        },
      ],
      44: [
        function (require, module, exports) {
          assert.notEqual = notEqual
          assert.notOk = notOk
          assert.equal = equal
          assert.ok = assert

          module.exports = assert

          function equal(a, b, m) {
            assert(a == b, m) // eslint-disable-line eqeqeq
          }

          function notEqual(a, b, m) {
            assert(a != b, m) // eslint-disable-line eqeqeq
          }

          function notOk(t, m) {
            assert(!t, m)
          }

          function assert(t, m) {
            if (!t) throw new Error(m || 'AssertionError')
          }
        },
        {},
      ],
      45: [
        function (require, module, exports) {
          // shim for using process in browser
          var process = (module.exports = {})

          // cached from whatever global is present so that test runners that stub it
          // don't break things.  But we need to wrap it in a try catch in case it is
          // wrapped in strict mode code which doesn't define any globals.  It's inside a
          // function because try/catches deoptimize in certain engines.

          var cachedSetTimeout
          var cachedClearTimeout

          function defaultSetTimout() {
            throw new Error('setTimeout has not been defined')
          }
          function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined')
          }
          ;(function () {
            try {
              if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout
              } else {
                cachedSetTimeout = defaultSetTimout
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout
            }
            try {
              if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout
              } else {
                cachedClearTimeout = defaultClearTimeout
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout
            }
          })()
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              //normal enviroments in sane situations
              return setTimeout(fun, 0)
            }
            // if setTimeout wasn't available but was latter defined
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout
              return setTimeout(fun, 0)
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedSetTimeout(fun, 0)
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0)
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0)
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              //normal enviroments in sane situations
              return clearTimeout(marker)
            }
            // if clearTimeout wasn't available but was latter defined
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout
              return clearTimeout(marker)
            }
            try {
              // when when somebody has screwed with setTimeout but no I.E. maddness
              return cachedClearTimeout(marker)
            } catch (e) {
              try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker)
              } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker)
              }
            }
          }
          var queue = []
          var draining = false
          var currentQueue
          var queueIndex = -1

          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return
            }
            draining = false
            if (currentQueue.length) {
              queue = currentQueue.concat(queue)
            } else {
              queueIndex = -1
            }
            if (queue.length) {
              drainQueue()
            }
          }

          function drainQueue() {
            if (draining) {
              return
            }
            var timeout = runTimeout(cleanUpNextTick)
            draining = true

            var len = queue.length
            while (len) {
              currentQueue = queue
              queue = []
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run()
                }
              }
              queueIndex = -1
              len = queue.length
            }
            currentQueue = null
            draining = false
            runClearTimeout(timeout)
          }

          process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1)
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i]
              }
            }
            queue.push(new Item(fun, args))
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue)
            }
          }

          // v8 likes predictible objects
          function Item(fun, array) {
            this.fun = fun
            this.array = array
          }
          Item.prototype.run = function () {
            this.fun.apply(null, this.array)
          }
          process.title = 'browser'
          process.browser = true
          process.env = {}
          process.argv = []
          process.version = '' // empty string to avoid regexp issues
          process.versions = {}

          function noop() {}

          process.on = noop
          process.addListener = noop
          process.once = noop
          process.off = noop
          process.removeListener = noop
          process.removeAllListeners = noop
          process.emit = noop
          process.prependListener = noop
          process.prependOnceListener = noop

          process.listeners = function (name) {
            return []
          }

          process.binding = function (name) {
            throw new Error('process.binding is not supported')
          }

          process.cwd = function () {
            return '/'
          }
          process.chdir = function (dir) {
            throw new Error('process.chdir is not supported')
          }
          process.umask = function () {
            return 0
          }
        },
        {},
      ],
      46: [
        function (require, module, exports) {
          // minimal library entry point.

          'use strict'
          module.exports = require('./src/index-minimal')
        },
        { './src/index-minimal': 47 },
      ],
      47: [
        function (require, module, exports) {
          'use strict'
          var protobuf = exports

          /**
           * Build type, one of `"full"`, `"light"` or `"minimal"`.
           * @name build
           * @type {string}
           * @const
           */
          protobuf.build = 'minimal'

          // Serialization
          protobuf.Writer = require('./writer')
          protobuf.BufferWriter = require('./writer_buffer')
          protobuf.Reader = require('./reader')
          protobuf.BufferReader = require('./reader_buffer')

          // Utility
          protobuf.util = require('./util/minimal')
          protobuf.rpc = require('./rpc')
          protobuf.roots = require('./roots')
          protobuf.configure = configure

          /* istanbul ignore next */
          /**
           * Reconfigures the library according to the environment.
           * @returns {undefined}
           */
          function configure() {
            protobuf.util._configure()
            protobuf.Writer._configure(protobuf.BufferWriter)
            protobuf.Reader._configure(protobuf.BufferReader)
          }

          // Set up buffer utility according to the environment
          configure()
        },
        {
          './reader': 48,
          './reader_buffer': 49,
          './roots': 50,
          './rpc': 51,
          './util/minimal': 54,
          './writer': 55,
          './writer_buffer': 56,
        },
      ],
      48: [
        function (require, module, exports) {
          'use strict'
          module.exports = Reader

          var util = require('./util/minimal')

          var BufferReader // cyclic

          var LongBits = util.LongBits,
            utf8 = util.utf8

          /* istanbul ignore next */
          function indexOutOfRange(reader, writeLength) {
            return RangeError(
              'index out of range: ' +
                reader.pos +
                ' + ' +
                (writeLength || 1) +
                ' > ' +
                reader.len
            )
          }

          /**
           * Constructs a new reader instance using the specified buffer.
           * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
           * @constructor
           * @param {Uint8Array} buffer Buffer to read from
           */
          function Reader(buffer) {
            /**
             * Read buffer.
             * @type {Uint8Array}
             */
            this.buf = buffer

            /**
             * Read buffer position.
             * @type {number}
             */
            this.pos = 0

            /**
             * Read buffer length.
             * @type {number}
             */
            this.len = buffer.length
          }

          var create_array =
            typeof Uint8Array !== 'undefined'
              ? function create_typed_array(buffer) {
                  if (buffer instanceof Uint8Array || Array.isArray(buffer))
                    return new Reader(buffer)
                  throw Error('illegal buffer')
                }
              : /* istanbul ignore next */
                function create_array(buffer) {
                  if (Array.isArray(buffer)) return new Reader(buffer)
                  throw Error('illegal buffer')
                }

          var create = function create() {
            return util.Buffer
              ? function create_buffer_setup(buffer) {
                  return (Reader.create = function create_buffer(buffer) {
                    return util.Buffer.isBuffer(buffer)
                      ? new BufferReader(buffer)
                      : /* istanbul ignore next */
                        create_array(buffer)
                  })(buffer)
                }
              : /* istanbul ignore next */
                create_array
          }

          /**
           * Creates a new reader using the specified buffer.
           * @function
           * @param {Uint8Array|Buffer} buffer Buffer to read from
           * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
           * @throws {Error} If `buffer` is not a valid buffer
           */
          Reader.create = create()

          Reader.prototype._slice =
            util.Array.prototype.subarray ||
            /* istanbul ignore next */ util.Array.prototype.slice

          /**
           * Reads a varint as an unsigned 32 bit value.
           * @function
           * @returns {number} Value read
           */
          Reader.prototype.uint32 = (function read_uint32_setup() {
            var value = 4294967295 // optimizer type-hint, tends to deopt otherwise (?!)
            return function read_uint32() {
              value = (this.buf[this.pos] & 127) >>> 0
              if (this.buf[this.pos++] < 128) return value
              value = (value | ((this.buf[this.pos] & 127) << 7)) >>> 0
              if (this.buf[this.pos++] < 128) return value
              value = (value | ((this.buf[this.pos] & 127) << 14)) >>> 0
              if (this.buf[this.pos++] < 128) return value
              value = (value | ((this.buf[this.pos] & 127) << 21)) >>> 0
              if (this.buf[this.pos++] < 128) return value
              value = (value | ((this.buf[this.pos] & 15) << 28)) >>> 0
              if (this.buf[this.pos++] < 128) return value

              /* istanbul ignore if */
              if ((this.pos += 5) > this.len) {
                this.pos = this.len
                throw indexOutOfRange(this, 10)
              }
              return value
            }
          })()

          /**
           * Reads a varint as a signed 32 bit value.
           * @returns {number} Value read
           */
          Reader.prototype.int32 = function read_int32() {
            return this.uint32() | 0
          }

          /**
           * Reads a zig-zag encoded varint as a signed 32 bit value.
           * @returns {number} Value read
           */
          Reader.prototype.sint32 = function read_sint32() {
            var value = this.uint32()
            return ((value >>> 1) ^ -(value & 1)) | 0
          }

          /* eslint-disable no-invalid-this */

          function readLongVarint() {
            // tends to deopt with local vars for octet etc.
            var bits = new LongBits(0, 0)
            var i = 0
            if (this.len - this.pos > 4) {
              // fast route (lo)
              for (; i < 4; ++i) {
                // 1st..4th
                bits.lo =
                  (bits.lo | ((this.buf[this.pos] & 127) << (i * 7))) >>> 0
                if (this.buf[this.pos++] < 128) return bits
              }
              // 5th
              bits.lo = (bits.lo | ((this.buf[this.pos] & 127) << 28)) >>> 0
              bits.hi = (bits.hi | ((this.buf[this.pos] & 127) >> 4)) >>> 0
              if (this.buf[this.pos++] < 128) return bits
              i = 0
            } else {
              for (; i < 3; ++i) {
                /* istanbul ignore if */
                if (this.pos >= this.len) throw indexOutOfRange(this)
                // 1st..3th
                bits.lo =
                  (bits.lo | ((this.buf[this.pos] & 127) << (i * 7))) >>> 0
                if (this.buf[this.pos++] < 128) return bits
              }
              // 4th
              bits.lo =
                (bits.lo | ((this.buf[this.pos++] & 127) << (i * 7))) >>> 0
              return bits
            }
            if (this.len - this.pos > 4) {
              // fast route (hi)
              for (; i < 5; ++i) {
                // 6th..10th
                bits.hi =
                  (bits.hi | ((this.buf[this.pos] & 127) << (i * 7 + 3))) >>> 0
                if (this.buf[this.pos++] < 128) return bits
              }
            } else {
              for (; i < 5; ++i) {
                /* istanbul ignore if */
                if (this.pos >= this.len) throw indexOutOfRange(this)
                // 6th..10th
                bits.hi =
                  (bits.hi | ((this.buf[this.pos] & 127) << (i * 7 + 3))) >>> 0
                if (this.buf[this.pos++] < 128) return bits
              }
            }
            /* istanbul ignore next */
            throw Error('invalid varint encoding')
          }

          /* eslint-enable no-invalid-this */

          /**
           * Reads a varint as a signed 64 bit value.
           * @name Reader#int64
           * @function
           * @returns {Long} Value read
           */

          /**
           * Reads a varint as an unsigned 64 bit value.
           * @name Reader#uint64
           * @function
           * @returns {Long} Value read
           */

          /**
           * Reads a zig-zag encoded varint as a signed 64 bit value.
           * @name Reader#sint64
           * @function
           * @returns {Long} Value read
           */

          /**
           * Reads a varint as a boolean.
           * @returns {boolean} Value read
           */
          Reader.prototype.bool = function read_bool() {
            return this.uint32() !== 0
          }

          function readFixed32_end(buf, end) {
            // note that this uses `end`, not `pos`
            return (
              (buf[end - 4] |
                (buf[end - 3] << 8) |
                (buf[end - 2] << 16) |
                (buf[end - 1] << 24)) >>>
              0
            )
          }

          /**
           * Reads fixed 32 bits as an unsigned 32 bit integer.
           * @returns {number} Value read
           */
          Reader.prototype.fixed32 = function read_fixed32() {
            /* istanbul ignore if */
            if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4)

            return readFixed32_end(this.buf, (this.pos += 4))
          }

          /**
           * Reads fixed 32 bits as a signed 32 bit integer.
           * @returns {number} Value read
           */
          Reader.prototype.sfixed32 = function read_sfixed32() {
            /* istanbul ignore if */
            if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4)

            return readFixed32_end(this.buf, (this.pos += 4)) | 0
          }

          /* eslint-disable no-invalid-this */

          function readFixed64(/* this: Reader */) {
            /* istanbul ignore if */
            if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8)

            return new LongBits(
              readFixed32_end(this.buf, (this.pos += 4)),
              readFixed32_end(this.buf, (this.pos += 4))
            )
          }

          /* eslint-enable no-invalid-this */

          /**
           * Reads fixed 64 bits.
           * @name Reader#fixed64
           * @function
           * @returns {Long} Value read
           */

          /**
           * Reads zig-zag encoded fixed 64 bits.
           * @name Reader#sfixed64
           * @function
           * @returns {Long} Value read
           */

          /**
           * Reads a float (32 bit) as a number.
           * @function
           * @returns {number} Value read
           */
          Reader.prototype.float = function read_float() {
            /* istanbul ignore if */
            if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4)

            var value = util.float.readFloatLE(this.buf, this.pos)
            this.pos += 4
            return value
          }

          /**
           * Reads a double (64 bit float) as a number.
           * @function
           * @returns {number} Value read
           */
          Reader.prototype.double = function read_double() {
            /* istanbul ignore if */
            if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4)

            var value = util.float.readDoubleLE(this.buf, this.pos)
            this.pos += 8
            return value
          }

          /**
           * Reads a sequence of bytes preceeded by its length as a varint.
           * @returns {Uint8Array} Value read
           */
          Reader.prototype.bytes = function read_bytes() {
            var length = this.uint32(),
              start = this.pos,
              end = this.pos + length

            /* istanbul ignore if */
            if (end > this.len) throw indexOutOfRange(this, length)

            this.pos += length
            if (Array.isArray(this.buf))
              // plain array
              return this.buf.slice(start, end)
            return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
              ? new this.buf.constructor(0)
              : this._slice.call(this.buf, start, end)
          }

          /**
           * Reads a string preceeded by its byte length as a varint.
           * @returns {string} Value read
           */
          Reader.prototype.string = function read_string() {
            var bytes = this.bytes()
            return utf8.read(bytes, 0, bytes.length)
          }

          /**
           * Skips the specified number of bytes if specified, otherwise skips a varint.
           * @param {number} [length] Length if known, otherwise a varint is assumed
           * @returns {Reader} `this`
           */
          Reader.prototype.skip = function skip(length) {
            if (typeof length === 'number') {
              /* istanbul ignore if */
              if (this.pos + length > this.len)
                throw indexOutOfRange(this, length)
              this.pos += length
            } else {
              do {
                /* istanbul ignore if */
                if (this.pos >= this.len) throw indexOutOfRange(this)
              } while (this.buf[this.pos++] & 128)
            }
            return this
          }

          /**
           * Skips the next element of the specified wire type.
           * @param {number} wireType Wire type received
           * @returns {Reader} `this`
           */
          Reader.prototype.skipType = function (wireType) {
            switch (wireType) {
              case 0:
                this.skip()
                break
              case 1:
                this.skip(8)
                break
              case 2:
                this.skip(this.uint32())
                break
              case 3:
                while ((wireType = this.uint32() & 7) !== 4) {
                  this.skipType(wireType)
                }
                break
              case 5:
                this.skip(4)
                break

              /* istanbul ignore next */
              default:
                throw Error(
                  'invalid wire type ' + wireType + ' at offset ' + this.pos
                )
            }
            return this
          }

          Reader._configure = function (BufferReader_) {
            BufferReader = BufferReader_
            Reader.create = create()
            BufferReader._configure()

            var fn = util.Long
              ? 'toLong'
              : /* istanbul ignore next */ 'toNumber'
            util.merge(Reader.prototype, {
              int64: function read_int64() {
                return readLongVarint.call(this)[fn](false)
              },

              uint64: function read_uint64() {
                return readLongVarint.call(this)[fn](true)
              },

              sint64: function read_sint64() {
                return readLongVarint.call(this).zzDecode()[fn](false)
              },

              fixed64: function read_fixed64() {
                return readFixed64.call(this)[fn](true)
              },

              sfixed64: function read_sfixed64() {
                return readFixed64.call(this)[fn](false)
              },
            })
          }
        },
        { './util/minimal': 54 },
      ],
      49: [
        function (require, module, exports) {
          'use strict'
          module.exports = BufferReader

          // extends Reader
          var Reader = require('./reader')
          ;(BufferReader.prototype = Object.create(
            Reader.prototype
          )).constructor = BufferReader

          var util = require('./util/minimal')

          /**
           * Constructs a new buffer reader instance.
           * @classdesc Wire format reader using node buffers.
           * @extends Reader
           * @constructor
           * @param {Buffer} buffer Buffer to read from
           */
          function BufferReader(buffer) {
            Reader.call(this, buffer)

            /**
             * Read buffer.
             * @name BufferReader#buf
             * @type {Buffer}
             */
          }

          BufferReader._configure = function () {
            /* istanbul ignore else */
            if (util.Buffer)
              BufferReader.prototype._slice = util.Buffer.prototype.slice
          }

          /**
           * @override
           */
          BufferReader.prototype.string = function read_string_buffer() {
            var len = this.uint32() // modifies pos
            return this.buf.utf8Slice
              ? this.buf.utf8Slice(
                  this.pos,
                  (this.pos = Math.min(this.pos + len, this.len))
                )
              : this.buf.toString(
                  'utf-8',
                  this.pos,
                  (this.pos = Math.min(this.pos + len, this.len))
                )
          }

          /**
           * Reads a sequence of bytes preceeded by its length as a varint.
           * @name BufferReader#bytes
           * @function
           * @returns {Buffer} Value read
           */

          BufferReader._configure()
        },
        { './reader': 48, './util/minimal': 54 },
      ],
      50: [
        function (require, module, exports) {
          'use strict'
          module.exports = {}

          /**
           * Named roots.
           * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
           * Can also be used manually to make roots available across modules.
           * @name roots
           * @type {Object.<string,Root>}
           * @example
           * // pbjs -r myroot -o compiled.js ...
           *
           * // in another module:
           * require("./compiled.js");
           *
           * // in any subsequent module:
           * var root = protobuf.roots["myroot"];
           */
        },
        {},
      ],
      51: [
        function (require, module, exports) {
          'use strict'

          /**
           * Streaming RPC helpers.
           * @namespace
           */
          var rpc = exports

          /**
           * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
           * @typedef RPCImpl
           * @type {function}
           * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
           * @param {Uint8Array} requestData Request data
           * @param {RPCImplCallback} callback Callback function
           * @returns {undefined}
           * @example
           * function rpcImpl(method, requestData, callback) {
           *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
           *         throw Error("no such method");
           *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
           *         callback(err, responseData);
           *     });
           * }
           */

          /**
           * Node-style callback as used by {@link RPCImpl}.
           * @typedef RPCImplCallback
           * @type {function}
           * @param {Error|null} error Error, if any, otherwise `null`
           * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
           * @returns {undefined}
           */

          rpc.Service = require('./rpc/service')
        },
        { './rpc/service': 52 },
      ],
      52: [
        function (require, module, exports) {
          'use strict'
          module.exports = Service

          var util = require('../util/minimal')

          // Extends EventEmitter
          ;(Service.prototype = Object.create(
            util.EventEmitter.prototype
          )).constructor = Service

          /**
           * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
           *
           * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
           * @typedef rpc.ServiceMethodCallback
           * @template TRes extends Message<TRes>
           * @type {function}
           * @param {Error|null} error Error, if any
           * @param {TRes} [response] Response message
           * @returns {undefined}
           */

          /**
           * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
           * @typedef rpc.ServiceMethod
           * @template TReq extends Message<TReq>
           * @template TRes extends Message<TRes>
           * @type {function}
           * @param {TReq|Properties<TReq>} request Request message or plain object
           * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
           * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
           */

          /**
           * Constructs a new RPC service instance.
           * @classdesc An RPC service as returned by {@link Service#create}.
           * @exports rpc.Service
           * @extends util.EventEmitter
           * @constructor
           * @param {RPCImpl} rpcImpl RPC implementation
           * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
           * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
           */
          function Service(rpcImpl, requestDelimited, responseDelimited) {
            if (typeof rpcImpl !== 'function')
              throw TypeError('rpcImpl must be a function')

            util.EventEmitter.call(this)

            /**
             * RPC implementation. Becomes `null` once the service is ended.
             * @type {RPCImpl|null}
             */
            this.rpcImpl = rpcImpl

            /**
             * Whether requests are length-delimited.
             * @type {boolean}
             */
            this.requestDelimited = Boolean(requestDelimited)

            /**
             * Whether responses are length-delimited.
             * @type {boolean}
             */
            this.responseDelimited = Boolean(responseDelimited)
          }

          /**
           * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
           * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
           * @param {Constructor<TReq>} requestCtor Request constructor
           * @param {Constructor<TRes>} responseCtor Response constructor
           * @param {TReq|Properties<TReq>} request Request message or plain object
           * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
           * @returns {undefined}
           * @template TReq extends Message<TReq>
           * @template TRes extends Message<TRes>
           */
          Service.prototype.rpcCall = function rpcCall(
            method,
            requestCtor,
            responseCtor,
            request,
            callback
          ) {
            if (!request) throw TypeError('request must be specified')

            var self = this
            if (!callback)
              return util.asPromise(
                rpcCall,
                self,
                method,
                requestCtor,
                responseCtor,
                request
              )

            if (!self.rpcImpl) {
              setTimeout(function () {
                callback(Error('already ended'))
              }, 0)
              return undefined
            }

            try {
              return self.rpcImpl(
                method,
                requestCtor[
                  self.requestDelimited ? 'encodeDelimited' : 'encode'
                ](request).finish(),
                function rpcCallback(err, response) {
                  if (err) {
                    self.emit('error', err, method)
                    return callback(err)
                  }

                  if (response === null) {
                    self.end(/* endedByRPC */ true)
                    return undefined
                  }

                  if (!(response instanceof responseCtor)) {
                    try {
                      response =
                        responseCtor[
                          self.responseDelimited ? 'decodeDelimited' : 'decode'
                        ](response)
                    } catch (err) {
                      self.emit('error', err, method)
                      return callback(err)
                    }
                  }

                  self.emit('data', response, method)
                  return callback(null, response)
                }
              )
            } catch (err) {
              self.emit('error', err, method)
              setTimeout(function () {
                callback(err)
              }, 0)
              return undefined
            }
          }

          /**
           * Ends this service and emits the `end` event.
           * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
           * @returns {rpc.Service} `this`
           */
          Service.prototype.end = function end(endedByRPC) {
            if (this.rpcImpl) {
              if (!endedByRPC)
                // signal end to rpcImpl
                this.rpcImpl(null, null, null)
              this.rpcImpl = null
              this.emit('end').off()
            }
            return this
          }
        },
        { '../util/minimal': 54 },
      ],
      53: [
        function (require, module, exports) {
          'use strict'
          module.exports = LongBits

          var util = require('../util/minimal')

          /**
           * Constructs new long bits.
           * @classdesc Helper class for working with the low and high bits of a 64 bit value.
           * @memberof util
           * @constructor
           * @param {number} lo Low 32 bits, unsigned
           * @param {number} hi High 32 bits, unsigned
           */
          function LongBits(lo, hi) {
            // note that the casts below are theoretically unnecessary as of today, but older statically
            // generated converter code might still call the ctor with signed 32bits. kept for compat.

            /**
             * Low bits.
             * @type {number}
             */
            this.lo = lo >>> 0

            /**
             * High bits.
             * @type {number}
             */
            this.hi = hi >>> 0
          }

          /**
           * Zero bits.
           * @memberof util.LongBits
           * @type {util.LongBits}
           */
          var zero = (LongBits.zero = new LongBits(0, 0))

          zero.toNumber = function () {
            return 0
          }
          zero.zzEncode = zero.zzDecode = function () {
            return this
          }
          zero.length = function () {
            return 1
          }

          /**
           * Zero hash.
           * @memberof util.LongBits
           * @type {string}
           */
          var zeroHash = (LongBits.zeroHash = '\0\0\0\0\0\0\0\0')

          /**
           * Constructs new long bits from the specified number.
           * @param {number} value Value
           * @returns {util.LongBits} Instance
           */
          LongBits.fromNumber = function fromNumber(value) {
            if (value === 0) return zero
            var sign = value < 0
            if (sign) value = -value
            var lo = value >>> 0,
              hi = ((value - lo) / 4294967296) >>> 0
            if (sign) {
              hi = ~hi >>> 0
              lo = ~lo >>> 0
              if (++lo > 4294967295) {
                lo = 0
                if (++hi > 4294967295) hi = 0
              }
            }
            return new LongBits(lo, hi)
          }

          /**
           * Constructs new long bits from a number, long or string.
           * @param {Long|number|string} value Value
           * @returns {util.LongBits} Instance
           */
          LongBits.from = function from(value) {
            if (typeof value === 'number') return LongBits.fromNumber(value)
            if (util.isString(value)) {
              /* istanbul ignore else */
              if (util.Long) value = util.Long.fromString(value)
              else return LongBits.fromNumber(parseInt(value, 10))
            }
            return value.low || value.high
              ? new LongBits(value.low >>> 0, value.high >>> 0)
              : zero
          }

          /**
           * Converts this long bits to a possibly unsafe JavaScript number.
           * @param {boolean} [unsigned=false] Whether unsigned or not
           * @returns {number} Possibly unsafe number
           */
          LongBits.prototype.toNumber = function toNumber(unsigned) {
            if (!unsigned && this.hi >>> 31) {
              var lo = (~this.lo + 1) >>> 0,
                hi = ~this.hi >>> 0
              if (!lo) hi = (hi + 1) >>> 0
              return -(lo + hi * 4294967296)
            }
            return this.lo + this.hi * 4294967296
          }

          /**
           * Converts this long bits to a long.
           * @param {boolean} [unsigned=false] Whether unsigned or not
           * @returns {Long} Long
           */
          LongBits.prototype.toLong = function toLong(unsigned) {
            return util.Long
              ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
              : /* istanbul ignore next */
                {
                  low: this.lo | 0,
                  high: this.hi | 0,
                  unsigned: Boolean(unsigned),
                }
          }

          var charCodeAt = String.prototype.charCodeAt

          /**
           * Constructs new long bits from the specified 8 characters long hash.
           * @param {string} hash Hash
           * @returns {util.LongBits} Bits
           */
          LongBits.fromHash = function fromHash(hash) {
            if (hash === zeroHash) return zero
            return new LongBits(
              (charCodeAt.call(hash, 0) |
                (charCodeAt.call(hash, 1) << 8) |
                (charCodeAt.call(hash, 2) << 16) |
                (charCodeAt.call(hash, 3) << 24)) >>>
                0,
              (charCodeAt.call(hash, 4) |
                (charCodeAt.call(hash, 5) << 8) |
                (charCodeAt.call(hash, 6) << 16) |
                (charCodeAt.call(hash, 7) << 24)) >>>
                0
            )
          }

          /**
           * Converts this long bits to a 8 characters long hash.
           * @returns {string} Hash
           */
          LongBits.prototype.toHash = function toHash() {
            return String.fromCharCode(
              this.lo & 255,
              (this.lo >>> 8) & 255,
              (this.lo >>> 16) & 255,
              this.lo >>> 24,
              this.hi & 255,
              (this.hi >>> 8) & 255,
              (this.hi >>> 16) & 255,
              this.hi >>> 24
            )
          }

          /**
           * Zig-zag encodes this long bits.
           * @returns {util.LongBits} `this`
           */
          LongBits.prototype.zzEncode = function zzEncode() {
            var mask = this.hi >> 31
            this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ mask) >>> 0
            this.lo = ((this.lo << 1) ^ mask) >>> 0
            return this
          }

          /**
           * Zig-zag decodes this long bits.
           * @returns {util.LongBits} `this`
           */
          LongBits.prototype.zzDecode = function zzDecode() {
            var mask = -(this.lo & 1)
            this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ mask) >>> 0
            this.hi = ((this.hi >>> 1) ^ mask) >>> 0
            return this
          }

          /**
           * Calculates the length of this longbits when encoded as a varint.
           * @returns {number} Length
           */
          LongBits.prototype.length = function length() {
            var part0 = this.lo,
              part1 = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
              part2 = this.hi >>> 24
            return part2 === 0
              ? part1 === 0
                ? part0 < 16384
                  ? part0 < 128
                    ? 1
                    : 2
                  : part0 < 2097152
                  ? 3
                  : 4
                : part1 < 16384
                ? part1 < 128
                  ? 5
                  : 6
                : part1 < 2097152
                ? 7
                : 8
              : part2 < 128
              ? 9
              : 10
          }
        },
        { '../util/minimal': 54 },
      ],
      54: [
        function (require, module, exports) {
          ;(function (global) {
            ;(function () {
              'use strict'
              var util = exports

              // used to return a Promise where callback is omitted
              util.asPromise = require('@protobufjs/aspromise')

              // converts to / from base64 encoded strings
              util.base64 = require('@protobufjs/base64')

              // base class of rpc.Service
              util.EventEmitter = require('@protobufjs/eventemitter')

              // float handling accross browsers
              util.float = require('@protobufjs/float')

              // requires modules optionally and hides the call from bundlers
              util.inquire = require('@protobufjs/inquire')

              // converts to / from utf8 encoded strings
              util.utf8 = require('@protobufjs/utf8')

              // provides a node-like buffer pool in the browser
              util.pool = require('@protobufjs/pool')

              // utility to work with the low and high bits of a 64 bit value
              util.LongBits = require('./longbits')

              /**
               * Whether running within node or not.
               * @memberof util
               * @type {boolean}
               */
              util.isNode = Boolean(
                typeof global !== 'undefined' &&
                  global &&
                  global.process &&
                  global.process.versions &&
                  global.process.versions.node
              )

              /**
               * Global object reference.
               * @memberof util
               * @type {Object}
               */
              util.global =
                (util.isNode && global) ||
                (typeof window !== 'undefined' && window) ||
                (typeof self !== 'undefined' && self) ||
                this // eslint-disable-line no-invalid-this

              /**
               * An immuable empty array.
               * @memberof util
               * @type {Array.<*>}
               * @const
               */
              util.emptyArray = Object.freeze
                ? Object.freeze([])
                : /* istanbul ignore next */ [] // used on prototypes

              /**
               * An immutable empty object.
               * @type {Object}
               * @const
               */
              util.emptyObject = Object.freeze
                ? Object.freeze({})
                : /* istanbul ignore next */ {} // used on prototypes

              /**
               * Tests if the specified value is an integer.
               * @function
               * @param {*} value Value to test
               * @returns {boolean} `true` if the value is an integer
               */
              util.isInteger =
                Number.isInteger ||
                /* istanbul ignore next */ function isInteger(value) {
                  return (
                    typeof value === 'number' &&
                    isFinite(value) &&
                    Math.floor(value) === value
                  )
                }

              /**
               * Tests if the specified value is a string.
               * @param {*} value Value to test
               * @returns {boolean} `true` if the value is a string
               */
              util.isString = function isString(value) {
                return typeof value === 'string' || value instanceof String
              }

              /**
               * Tests if the specified value is a non-null object.
               * @param {*} value Value to test
               * @returns {boolean} `true` if the value is a non-null object
               */
              util.isObject = function isObject(value) {
                return value && typeof value === 'object'
              }

              /**
               * Checks if a property on a message is considered to be present.
               * This is an alias of {@link util.isSet}.
               * @function
               * @param {Object} obj Plain object or message instance
               * @param {string} prop Property name
               * @returns {boolean} `true` if considered to be present, otherwise `false`
               */
              util.isset =
                /**
                 * Checks if a property on a message is considered to be present.
                 * @param {Object} obj Plain object or message instance
                 * @param {string} prop Property name
                 * @returns {boolean} `true` if considered to be present, otherwise `false`
                 */
                util.isSet = function isSet(obj, prop) {
                  var value = obj[prop]
                  if (value != null && obj.hasOwnProperty(prop))
                    // eslint-disable-line eqeqeq, no-prototype-builtins
                    return (
                      typeof value !== 'object' ||
                      (Array.isArray(value)
                        ? value.length
                        : Object.keys(value).length) > 0
                    )
                  return false
                }

              /**
               * Any compatible Buffer instance.
               * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
               * @interface Buffer
               * @extends Uint8Array
               */

              /**
               * Node's Buffer class if available.
               * @type {Constructor<Buffer>}
               */
              util.Buffer = (function () {
                try {
                  var Buffer = util.inquire('buffer').Buffer
                  // refuse to use non-node buffers if not explicitly assigned (perf reasons):
                  return Buffer.prototype.utf8Write
                    ? Buffer
                    : /* istanbul ignore next */ null
                } catch (e) {
                  /* istanbul ignore next */
                  return null
                }
              })()

              // Internal alias of or polyfull for Buffer.from.
              util._Buffer_from = null

              // Internal alias of or polyfill for Buffer.allocUnsafe.
              util._Buffer_allocUnsafe = null

              /**
               * Creates a new buffer of whatever type supported by the environment.
               * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
               * @returns {Uint8Array|Buffer} Buffer
               */
              util.newBuffer = function newBuffer(sizeOrArray) {
                /* istanbul ignore next */
                return typeof sizeOrArray === 'number'
                  ? util.Buffer
                    ? util._Buffer_allocUnsafe(sizeOrArray)
                    : new util.Array(sizeOrArray)
                  : util.Buffer
                  ? util._Buffer_from(sizeOrArray)
                  : typeof Uint8Array === 'undefined'
                  ? sizeOrArray
                  : new Uint8Array(sizeOrArray)
              }

              /**
               * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
               * @type {Constructor<Uint8Array>}
               */
              util.Array =
                typeof Uint8Array !== 'undefined'
                  ? Uint8Array /* istanbul ignore next */
                  : Array

              /**
               * Any compatible Long instance.
               * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
               * @interface Long
               * @property {number} low Low bits
               * @property {number} high High bits
               * @property {boolean} unsigned Whether unsigned or not
               */

              /**
               * Long.js's Long class if available.
               * @type {Constructor<Long>}
               */
              util.Long =
                /* istanbul ignore next */ (util.global.dcodeIO &&
                  /* istanbul ignore next */ util.global.dcodeIO.Long) ||
                /* istanbul ignore next */ util.global.Long ||
                util.inquire('long')

              /**
               * Regular expression used to verify 2 bit (`bool`) map keys.
               * @type {RegExp}
               * @const
               */
              util.key2Re = /^true|false|0|1$/

              /**
               * Regular expression used to verify 32 bit (`int32` etc.) map keys.
               * @type {RegExp}
               * @const
               */
              util.key32Re = /^-?(?:0|[1-9][0-9]*)$/

              /**
               * Regular expression used to verify 64 bit (`int64` etc.) map keys.
               * @type {RegExp}
               * @const
               */
              util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/

              /**
               * Converts a number or long to an 8 characters long hash string.
               * @param {Long|number} value Value to convert
               * @returns {string} Hash
               */
              util.longToHash = function longToHash(value) {
                return value
                  ? util.LongBits.from(value).toHash()
                  : util.LongBits.zeroHash
              }

              /**
               * Converts an 8 characters long hash string to a long or number.
               * @param {string} hash Hash
               * @param {boolean} [unsigned=false] Whether unsigned or not
               * @returns {Long|number} Original value
               */
              util.longFromHash = function longFromHash(hash, unsigned) {
                var bits = util.LongBits.fromHash(hash)
                if (util.Long)
                  return util.Long.fromBits(bits.lo, bits.hi, unsigned)
                return bits.toNumber(Boolean(unsigned))
              }

              /**
               * Merges the properties of the source object into the destination object.
               * @memberof util
               * @param {Object.<string,*>} dst Destination object
               * @param {Object.<string,*>} src Source object
               * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
               * @returns {Object.<string,*>} Destination object
               */
              function merge(dst, src, ifNotSet) {
                // used by converters
                for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
                  if (dst[keys[i]] === undefined || !ifNotSet)
                    dst[keys[i]] = src[keys[i]]
                return dst
              }

              util.merge = merge

              /**
               * Converts the first character of a string to lower case.
               * @param {string} str String to convert
               * @returns {string} Converted string
               */
              util.lcFirst = function lcFirst(str) {
                return str.charAt(0).toLowerCase() + str.substring(1)
              }

              /**
               * Creates a custom error constructor.
               * @memberof util
               * @param {string} name Error name
               * @returns {Constructor<Error>} Custom error constructor
               */
              function newError(name) {
                function CustomError(message, properties) {
                  if (!(this instanceof CustomError))
                    return new CustomError(message, properties)

                  // Error.call(this, message);
                  // ^ just returns a new error instance because the ctor can be called as a function

                  Object.defineProperty(this, 'message', {
                    get: function () {
                      return message
                    },
                  })

                  /* istanbul ignore next */
                  if (Error.captureStackTrace)
                    // node
                    Error.captureStackTrace(this, CustomError)
                  else
                    Object.defineProperty(this, 'stack', {
                      value: new Error().stack || '',
                    })

                  if (properties) merge(this, properties)
                }

                CustomError.prototype = Object.create(Error.prototype, {
                  constructor: {
                    value: CustomError,
                    writable: true,
                    enumerable: false,
                    configurable: true,
                  },
                  name: {
                    get: function get() {
                      return name
                    },
                    set: undefined,
                    enumerable: false,
                    // configurable: false would accurately preserve the behavior of
                    // the original, but I'm guessing that was not intentional.
                    // For an actual error subclass, this property would
                    // be configurable.
                    configurable: true,
                  },
                  toString: {
                    value: function value() {
                      return this.name + ': ' + this.message
                    },
                    writable: true,
                    enumerable: false,
                    configurable: true,
                  },
                })

                return CustomError
              }

              util.newError = newError

              /**
               * Constructs a new protocol error.
               * @classdesc Error subclass indicating a protocol specifc error.
               * @memberof util
               * @extends Error
               * @template T extends Message<T>
               * @constructor
               * @param {string} message Error message
               * @param {Object.<string,*>} [properties] Additional properties
               * @example
               * try {
               *     MyMessage.decode(someBuffer); // throws if required fields are missing
               * } catch (e) {
               *     if (e instanceof ProtocolError && e.instance)
               *         console.log("decoded so far: " + JSON.stringify(e.instance));
               * }
               */
              util.ProtocolError = newError('ProtocolError')

              /**
               * So far decoded message instance.
               * @name util.ProtocolError#instance
               * @type {Message<T>}
               */

              /**
               * A OneOf getter as returned by {@link util.oneOfGetter}.
               * @typedef OneOfGetter
               * @type {function}
               * @returns {string|undefined} Set field name, if any
               */

              /**
               * Builds a getter for a oneof's present field name.
               * @param {string[]} fieldNames Field names
               * @returns {OneOfGetter} Unbound getter
               */
              util.oneOfGetter = function getOneOf(fieldNames) {
                var fieldMap = {}
                for (var i = 0; i < fieldNames.length; ++i)
                  fieldMap[fieldNames[i]] = 1

                /**
                 * @returns {string|undefined} Set field name, if any
                 * @this Object
                 * @ignore
                 */
                return function () {
                  // eslint-disable-line consistent-return
                  for (
                    var keys = Object.keys(this), i = keys.length - 1;
                    i > -1;
                    --i
                  )
                    if (
                      fieldMap[keys[i]] === 1 &&
                      this[keys[i]] !== undefined &&
                      this[keys[i]] !== null
                    )
                      return keys[i]
                }
              }

              /**
               * A OneOf setter as returned by {@link util.oneOfSetter}.
               * @typedef OneOfSetter
               * @type {function}
               * @param {string|undefined} value Field name
               * @returns {undefined}
               */

              /**
               * Builds a setter for a oneof's present field name.
               * @param {string[]} fieldNames Field names
               * @returns {OneOfSetter} Unbound setter
               */
              util.oneOfSetter = function setOneOf(fieldNames) {
                /**
                 * @param {string} name Field name
                 * @returns {undefined}
                 * @this Object
                 * @ignore
                 */
                return function (name) {
                  for (var i = 0; i < fieldNames.length; ++i)
                    if (fieldNames[i] !== name) delete this[fieldNames[i]]
                }
              }

              /**
               * Default conversion options used for {@link Message#toJSON} implementations.
               *
               * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
               *
               * - Longs become strings
               * - Enums become string keys
               * - Bytes become base64 encoded strings
               * - (Sub-)Messages become plain objects
               * - Maps become plain objects with all string keys
               * - Repeated fields become arrays
               * - NaN and Infinity for float and double fields become strings
               *
               * @type {IConversionOptions}
               * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
               */
              util.toJSONOptions = {
                longs: String,
                enums: String,
                bytes: String,
                json: true,
              }

              // Sets up buffer utility according to the environment (called in index-minimal)
              util._configure = function () {
                var Buffer = util.Buffer
                /* istanbul ignore if */
                if (!Buffer) {
                  util._Buffer_from = util._Buffer_allocUnsafe = null
                  return
                }
                // because node 4.x buffers are incompatible & immutable
                // see: https://github.com/dcodeIO/protobuf.js/pull/665
                util._Buffer_from =
                  (Buffer.from !== Uint8Array.from && Buffer.from) ||
                  /* istanbul ignore next */
                  function Buffer_from(value, encoding) {
                    return new Buffer(value, encoding)
                  }
                util._Buffer_allocUnsafe =
                  Buffer.allocUnsafe ||
                  /* istanbul ignore next */
                  function Buffer_allocUnsafe(size) {
                    return new Buffer(size)
                  }
              }
            }.call(this))
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ))
        },
        {
          './longbits': 53,
          '@protobufjs/aspromise': 3,
          '@protobufjs/base64': 4,
          '@protobufjs/eventemitter': 5,
          '@protobufjs/float': 6,
          '@protobufjs/inquire': 7,
          '@protobufjs/pool': 8,
          '@protobufjs/utf8': 9,
        },
      ],
      55: [
        function (require, module, exports) {
          'use strict'
          module.exports = Writer

          var util = require('./util/minimal')

          var BufferWriter // cyclic

          var LongBits = util.LongBits,
            base64 = util.base64,
            utf8 = util.utf8

          /**
           * Constructs a new writer operation instance.
           * @classdesc Scheduled writer operation.
           * @constructor
           * @param {function(*, Uint8Array, number)} fn Function to call
           * @param {number} len Value byte length
           * @param {*} val Value to write
           * @ignore
           */
          function Op(fn, len, val) {
            /**
             * Function to call.
             * @type {function(Uint8Array, number, *)}
             */
            this.fn = fn

            /**
             * Value byte length.
             * @type {number}
             */
            this.len = len

            /**
             * Next operation.
             * @type {Writer.Op|undefined}
             */
            this.next = undefined

            /**
             * Value to write.
             * @type {*}
             */
            this.val = val // type varies
          }

          /* istanbul ignore next */
          function noop() {} // eslint-disable-line no-empty-function

          /**
           * Constructs a new writer state instance.
           * @classdesc Copied writer state.
           * @memberof Writer
           * @constructor
           * @param {Writer} writer Writer to copy state from
           * @ignore
           */
          function State(writer) {
            /**
             * Current head.
             * @type {Writer.Op}
             */
            this.head = writer.head

            /**
             * Current tail.
             * @type {Writer.Op}
             */
            this.tail = writer.tail

            /**
             * Current buffer length.
             * @type {number}
             */
            this.len = writer.len

            /**
             * Next state.
             * @type {State|null}
             */
            this.next = writer.states
          }

          /**
           * Constructs a new writer instance.
           * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
           * @constructor
           */
          function Writer() {
            /**
             * Current length.
             * @type {number}
             */
            this.len = 0

            /**
             * Operations head.
             * @type {Object}
             */
            this.head = new Op(noop, 0, 0)

            /**
             * Operations tail
             * @type {Object}
             */
            this.tail = this.head

            /**
             * Linked forked states.
             * @type {Object|null}
             */
            this.states = null

            // When a value is written, the writer calculates its byte length and puts it into a linked
            // list of operations to perform when finish() is called. This both allows us to allocate
            // buffers of the exact required size and reduces the amount of work we have to do compared
            // to first calculating over objects and then encoding over objects. In our case, the encoding
            // part is just a linked list walk calling operations with already prepared values.
          }

          var create = function create() {
            return util.Buffer
              ? function create_buffer_setup() {
                  return (Writer.create = function create_buffer() {
                    return new BufferWriter()
                  })()
                }
              : /* istanbul ignore next */
                function create_array() {
                  return new Writer()
                }
          }

          /**
           * Creates a new writer.
           * @function
           * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
           */
          Writer.create = create()

          /**
           * Allocates a buffer of the specified size.
           * @param {number} size Buffer size
           * @returns {Uint8Array} Buffer
           */
          Writer.alloc = function alloc(size) {
            return new util.Array(size)
          }

          // Use Uint8Array buffer pool in the browser, just like node does with buffers
          /* istanbul ignore else */
          if (util.Array !== Array)
            Writer.alloc = util.pool(
              Writer.alloc,
              util.Array.prototype.subarray
            )

          /**
           * Pushes a new operation to the queue.
           * @param {function(Uint8Array, number, *)} fn Function to call
           * @param {number} len Value byte length
           * @param {number} val Value to write
           * @returns {Writer} `this`
           * @private
           */
          Writer.prototype._push = function push(fn, len, val) {
            this.tail = this.tail.next = new Op(fn, len, val)
            this.len += len
            return this
          }

          function writeByte(val, buf, pos) {
            buf[pos] = val & 255
          }

          function writeVarint32(val, buf, pos) {
            while (val > 127) {
              buf[pos++] = (val & 127) | 128
              val >>>= 7
            }
            buf[pos] = val
          }

          /**
           * Constructs a new varint writer operation instance.
           * @classdesc Scheduled varint writer operation.
           * @extends Op
           * @constructor
           * @param {number} len Value byte length
           * @param {number} val Value to write
           * @ignore
           */
          function VarintOp(len, val) {
            this.len = len
            this.next = undefined
            this.val = val
          }

          VarintOp.prototype = Object.create(Op.prototype)
          VarintOp.prototype.fn = writeVarint32

          /**
           * Writes an unsigned 32 bit value as a varint.
           * @param {number} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.uint32 = function write_uint32(value) {
            // here, the call to this.push has been inlined and a varint specific Op subclass is used.
            // uint32 is by far the most frequently used operation and benefits significantly from this.
            this.len += (this.tail = this.tail.next =
              new VarintOp(
                (value = value >>> 0) < 128
                  ? 1
                  : value < 16384
                  ? 2
                  : value < 2097152
                  ? 3
                  : value < 268435456
                  ? 4
                  : 5,
                value
              )).len
            return this
          }

          /**
           * Writes a signed 32 bit value as a varint.
           * @function
           * @param {number} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.int32 = function write_int32(value) {
            return value < 0
              ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
              : this.uint32(value)
          }

          /**
           * Writes a 32 bit value as a varint, zig-zag encoded.
           * @param {number} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.sint32 = function write_sint32(value) {
            return this.uint32(((value << 1) ^ (value >> 31)) >>> 0)
          }

          function writeVarint64(val, buf, pos) {
            while (val.hi) {
              buf[pos++] = (val.lo & 127) | 128
              val.lo = ((val.lo >>> 7) | (val.hi << 25)) >>> 0
              val.hi >>>= 7
            }
            while (val.lo > 127) {
              buf[pos++] = (val.lo & 127) | 128
              val.lo = val.lo >>> 7
            }
            buf[pos++] = val.lo
          }

          /**
           * Writes an unsigned 64 bit value as a varint.
           * @param {Long|number|string} value Value to write
           * @returns {Writer} `this`
           * @throws {TypeError} If `value` is a string and no long library is present.
           */
          Writer.prototype.uint64 = function write_uint64(value) {
            var bits = LongBits.from(value)
            return this._push(writeVarint64, bits.length(), bits)
          }

          /**
           * Writes a signed 64 bit value as a varint.
           * @function
           * @param {Long|number|string} value Value to write
           * @returns {Writer} `this`
           * @throws {TypeError} If `value` is a string and no long library is present.
           */
          Writer.prototype.int64 = Writer.prototype.uint64

          /**
           * Writes a signed 64 bit value as a varint, zig-zag encoded.
           * @param {Long|number|string} value Value to write
           * @returns {Writer} `this`
           * @throws {TypeError} If `value` is a string and no long library is present.
           */
          Writer.prototype.sint64 = function write_sint64(value) {
            var bits = LongBits.from(value).zzEncode()
            return this._push(writeVarint64, bits.length(), bits)
          }

          /**
           * Writes a boolish value as a varint.
           * @param {boolean} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.bool = function write_bool(value) {
            return this._push(writeByte, 1, value ? 1 : 0)
          }

          function writeFixed32(val, buf, pos) {
            buf[pos] = val & 255
            buf[pos + 1] = (val >>> 8) & 255
            buf[pos + 2] = (val >>> 16) & 255
            buf[pos + 3] = val >>> 24
          }

          /**
           * Writes an unsigned 32 bit value as fixed 32 bits.
           * @param {number} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.fixed32 = function write_fixed32(value) {
            return this._push(writeFixed32, 4, value >>> 0)
          }

          /**
           * Writes a signed 32 bit value as fixed 32 bits.
           * @function
           * @param {number} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.sfixed32 = Writer.prototype.fixed32

          /**
           * Writes an unsigned 64 bit value as fixed 64 bits.
           * @param {Long|number|string} value Value to write
           * @returns {Writer} `this`
           * @throws {TypeError} If `value` is a string and no long library is present.
           */
          Writer.prototype.fixed64 = function write_fixed64(value) {
            var bits = LongBits.from(value)
            return this._push(writeFixed32, 4, bits.lo)._push(
              writeFixed32,
              4,
              bits.hi
            )
          }

          /**
           * Writes a signed 64 bit value as fixed 64 bits.
           * @function
           * @param {Long|number|string} value Value to write
           * @returns {Writer} `this`
           * @throws {TypeError} If `value` is a string and no long library is present.
           */
          Writer.prototype.sfixed64 = Writer.prototype.fixed64

          /**
           * Writes a float (32 bit).
           * @function
           * @param {number} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.float = function write_float(value) {
            return this._push(util.float.writeFloatLE, 4, value)
          }

          /**
           * Writes a double (64 bit float).
           * @function
           * @param {number} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.double = function write_double(value) {
            return this._push(util.float.writeDoubleLE, 8, value)
          }

          var writeBytes = util.Array.prototype.set
            ? function writeBytes_set(val, buf, pos) {
                buf.set(val, pos) // also works for plain array values
              }
            : /* istanbul ignore next */
              function writeBytes_for(val, buf, pos) {
                for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i]
              }

          /**
           * Writes a sequence of bytes.
           * @param {Uint8Array|string} value Buffer or base64 encoded string to write
           * @returns {Writer} `this`
           */
          Writer.prototype.bytes = function write_bytes(value) {
            var len = value.length >>> 0
            if (!len) return this._push(writeByte, 1, 0)
            if (util.isString(value)) {
              var buf = Writer.alloc((len = base64.length(value)))
              base64.decode(value, buf, 0)
              value = buf
            }
            return this.uint32(len)._push(writeBytes, len, value)
          }

          /**
           * Writes a string.
           * @param {string} value Value to write
           * @returns {Writer} `this`
           */
          Writer.prototype.string = function write_string(value) {
            var len = utf8.length(value)
            return len
              ? this.uint32(len)._push(utf8.write, len, value)
              : this._push(writeByte, 1, 0)
          }

          /**
           * Forks this writer's state by pushing it to a stack.
           * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
           * @returns {Writer} `this`
           */
          Writer.prototype.fork = function fork() {
            this.states = new State(this)
            this.head = this.tail = new Op(noop, 0, 0)
            this.len = 0
            return this
          }

          /**
           * Resets this instance to the last state.
           * @returns {Writer} `this`
           */
          Writer.prototype.reset = function reset() {
            if (this.states) {
              this.head = this.states.head
              this.tail = this.states.tail
              this.len = this.states.len
              this.states = this.states.next
            } else {
              this.head = this.tail = new Op(noop, 0, 0)
              this.len = 0
            }
            return this
          }

          /**
           * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
           * @returns {Writer} `this`
           */
          Writer.prototype.ldelim = function ldelim() {
            var head = this.head,
              tail = this.tail,
              len = this.len
            this.reset().uint32(len)
            if (len) {
              this.tail.next = head.next // skip noop
              this.tail = tail
              this.len += len
            }
            return this
          }

          /**
           * Finishes the write operation.
           * @returns {Uint8Array} Finished buffer
           */
          Writer.prototype.finish = function finish() {
            var head = this.head.next, // skip noop
              buf = this.constructor.alloc(this.len),
              pos = 0
            while (head) {
              head.fn(head.val, buf, pos)
              pos += head.len
              head = head.next
            }
            // this.head = this.tail = null;
            return buf
          }

          Writer._configure = function (BufferWriter_) {
            BufferWriter = BufferWriter_
            Writer.create = create()
            BufferWriter._configure()
          }
        },
        { './util/minimal': 54 },
      ],
      56: [
        function (require, module, exports) {
          'use strict'
          module.exports = BufferWriter

          // extends Writer
          var Writer = require('./writer')
          ;(BufferWriter.prototype = Object.create(
            Writer.prototype
          )).constructor = BufferWriter

          var util = require('./util/minimal')

          /**
           * Constructs a new buffer writer instance.
           * @classdesc Wire format writer using node buffers.
           * @extends Writer
           * @constructor
           */
          function BufferWriter() {
            Writer.call(this)
          }

          BufferWriter._configure = function () {
            /**
             * Allocates a buffer of the specified size.
             * @function
             * @param {number} size Buffer size
             * @returns {Buffer} Buffer
             */
            BufferWriter.alloc = util._Buffer_allocUnsafe

            BufferWriter.writeBytesBuffer =
              util.Buffer &&
              util.Buffer.prototype instanceof Uint8Array &&
              util.Buffer.prototype.set.name === 'set'
                ? function writeBytesBuffer_set(val, buf, pos) {
                    buf.set(val, pos) // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                    // also works for plain array values
                  }
                : /* istanbul ignore next */
                  function writeBytesBuffer_copy(val, buf, pos) {
                    if (val.copy)
                      // Buffer values
                      val.copy(buf, pos, 0, val.length)
                    else
                      for (
                        var i = 0;
                        i < val.length; // plain array values

                      )
                        buf[pos++] = val[i++]
                  }
          }

          /**
           * @override
           */
          BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
            if (util.isString(value)) value = util._Buffer_from(value, 'base64')
            var len = value.length >>> 0
            this.uint32(len)
            if (len) this._push(BufferWriter.writeBytesBuffer, len, value)
            return this
          }

          function writeStringBuffer(val, buf, pos) {
            if (val.length < 40)
              // plain js is faster for short strings (probably due to redundant assertions)
              util.utf8.write(val, buf, pos)
            else if (buf.utf8Write) buf.utf8Write(val, pos)
            else buf.write(val, pos)
          }

          /**
           * @override
           */
          BufferWriter.prototype.string = function write_string_buffer(value) {
            var len = util.Buffer.byteLength(value)
            this.uint32(len)
            if (len) this._push(writeStringBuffer, len, value)
            return this
          }

          /**
           * Finishes the write operation.
           * @name BufferWriter#finish
           * @function
           * @returns {Buffer} Finished buffer
           */

          BufferWriter._configure()
        },
        { './util/minimal': 54, './writer': 55 },
      ],
      57: [
        function (require, module, exports) {
          ;(function (global) {
            ;(function () {
              /*! https://mths.be/punycode v1.4.1 by @mathias */
              ;(function (root) {
                /** Detect free variables */
                var freeExports =
                  typeof exports == 'object' &&
                  exports &&
                  !exports.nodeType &&
                  exports
                var freeModule =
                  typeof module == 'object' &&
                  module &&
                  !module.nodeType &&
                  module
                var freeGlobal = typeof global == 'object' && global
                if (
                  freeGlobal.global === freeGlobal ||
                  freeGlobal.window === freeGlobal ||
                  freeGlobal.self === freeGlobal
                ) {
                  root = freeGlobal
                }

                /**
                 * The `punycode` object.
                 * @name punycode
                 * @type Object
                 */
                var punycode,
                  /** Highest positive signed 32-bit float value */
                  maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
                  /** Bootstring parameters */
                  base = 36,
                  tMin = 1,
                  tMax = 26,
                  skew = 38,
                  damp = 700,
                  initialBias = 72,
                  initialN = 128, // 0x80
                  delimiter = '-', // '\x2D'
                  /** Regular expressions */
                  regexPunycode = /^xn--/,
                  regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
                  /** Error messages */
                  errors = {
                    overflow: 'Overflow: input needs wider integers to process',
                    'not-basic':
                      'Illegal input >= 0x80 (not a basic code point)',
                    'invalid-input': 'Invalid input',
                  },
                  /** Convenience shortcuts */
                  baseMinusTMin = base - tMin,
                  floor = Math.floor,
                  stringFromCharCode = String.fromCharCode,
                  /** Temporary variable */
                  key

                /*--------------------------------------------------------------------------*/

                /**
                 * A generic error utility function.
                 * @private
                 * @param {String} type The error type.
                 * @returns {Error} Throws a `RangeError` with the applicable error message.
                 */
                function error(type) {
                  throw new RangeError(errors[type])
                }

                /**
                 * A generic `Array#map` utility function.
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} callback The function that gets called for every array
                 * item.
                 * @returns {Array} A new array of values returned by the callback function.
                 */
                function map(array, fn) {
                  var length = array.length
                  var result = []
                  while (length--) {
                    result[length] = fn(array[length])
                  }
                  return result
                }

                /**
                 * A simple `Array#map`-like wrapper to work with domain name strings or email
                 * addresses.
                 * @private
                 * @param {String} domain The domain name or email address.
                 * @param {Function} callback The function that gets called for every
                 * character.
                 * @returns {Array} A new string of characters returned by the callback
                 * function.
                 */
                function mapDomain(string, fn) {
                  var parts = string.split('@')
                  var result = ''
                  if (parts.length > 1) {
                    // In email addresses, only the domain name should be punycoded. Leave
                    // the local part (i.e. everything up to `@`) intact.
                    result = parts[0] + '@'
                    string = parts[1]
                  }
                  // Avoid `split(regex)` for IE8 compatibility. See #17.
                  string = string.replace(regexSeparators, '\x2E')
                  var labels = string.split('.')
                  var encoded = map(labels, fn).join('.')
                  return result + encoded
                }

                /**
                 * Creates an array containing the numeric code points of each Unicode
                 * character in the string. While JavaScript uses UCS-2 internally,
                 * this function will convert a pair of surrogate halves (each of which
                 * UCS-2 exposes as separate characters) into a single code point,
                 * matching UTF-16.
                 * @see `punycode.ucs2.encode`
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode.ucs2
                 * @name decode
                 * @param {String} string The Unicode input string (UCS-2).
                 * @returns {Array} The new array of code points.
                 */
                function ucs2decode(string) {
                  var output = [],
                    counter = 0,
                    length = string.length,
                    value,
                    extra
                  while (counter < length) {
                    value = string.charCodeAt(counter++)
                    if (
                      value >= 0xd800 &&
                      value <= 0xdbff &&
                      counter < length
                    ) {
                      // high surrogate, and there is a next character
                      extra = string.charCodeAt(counter++)
                      if ((extra & 0xfc00) == 0xdc00) {
                        // low surrogate
                        output.push(
                          ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000
                        )
                      } else {
                        // unmatched surrogate; only append this code unit, in case the next
                        // code unit is the high surrogate of a surrogate pair
                        output.push(value)
                        counter--
                      }
                    } else {
                      output.push(value)
                    }
                  }
                  return output
                }

                /**
                 * Creates a string based on an array of numeric code points.
                 * @see `punycode.ucs2.decode`
                 * @memberOf punycode.ucs2
                 * @name encode
                 * @param {Array} codePoints The array of numeric code points.
                 * @returns {String} The new Unicode string (UCS-2).
                 */
                function ucs2encode(array) {
                  return map(array, function (value) {
                    var output = ''
                    if (value > 0xffff) {
                      value -= 0x10000
                      output += stringFromCharCode(
                        ((value >>> 10) & 0x3ff) | 0xd800
                      )
                      value = 0xdc00 | (value & 0x3ff)
                    }
                    output += stringFromCharCode(value)
                    return output
                  }).join('')
                }

                /**
                 * Converts a basic code point into a digit/integer.
                 * @see `digitToBasic()`
                 * @private
                 * @param {Number} codePoint The basic numeric code point value.
                 * @returns {Number} The numeric value of a basic code point (for use in
                 * representing integers) in the range `0` to `base - 1`, or `base` if
                 * the code point does not represent a value.
                 */
                function basicToDigit(codePoint) {
                  if (codePoint - 48 < 10) {
                    return codePoint - 22
                  }
                  if (codePoint - 65 < 26) {
                    return codePoint - 65
                  }
                  if (codePoint - 97 < 26) {
                    return codePoint - 97
                  }
                  return base
                }

                /**
                 * Converts a digit/integer into a basic code point.
                 * @see `basicToDigit()`
                 * @private
                 * @param {Number} digit The numeric value of a basic code point.
                 * @returns {Number} The basic code point whose value (when used for
                 * representing integers) is `digit`, which needs to be in the range
                 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                 * used; else, the lowercase form is used. The behavior is undefined
                 * if `flag` is non-zero and `digit` has no uppercase form.
                 */
                function digitToBasic(digit, flag) {
                  //  0..25 map to ASCII a..z or A..Z
                  // 26..35 map to ASCII 0..9
                  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5)
                }

                /**
                 * Bias adaptation function as per section 3.4 of RFC 3492.
                 * https://tools.ietf.org/html/rfc3492#section-3.4
                 * @private
                 */
                function adapt(delta, numPoints, firstTime) {
                  var k = 0
                  delta = firstTime ? floor(delta / damp) : delta >> 1
                  delta += floor(delta / numPoints)
                  for (
                    ;
                    /* no initialization */ delta > (baseMinusTMin * tMax) >> 1;
                    k += base
                  ) {
                    delta = floor(delta / baseMinusTMin)
                  }
                  return floor(
                    k + ((baseMinusTMin + 1) * delta) / (delta + skew)
                  )
                }

                /**
                 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                 * symbols.
                 * @memberOf punycode
                 * @param {String} input The Punycode string of ASCII-only symbols.
                 * @returns {String} The resulting string of Unicode symbols.
                 */
                function decode(input) {
                  // Don't use UCS-2
                  var output = [],
                    inputLength = input.length,
                    out,
                    i = 0,
                    n = initialN,
                    bias = initialBias,
                    basic,
                    j,
                    index,
                    oldi,
                    w,
                    k,
                    digit,
                    t,
                    /** Cached calculation results */
                    baseMinusT

                  // Handle the basic code points: let `basic` be the number of input code
                  // points before the last delimiter, or `0` if there is none, then copy
                  // the first basic code points to the output.

                  basic = input.lastIndexOf(delimiter)
                  if (basic < 0) {
                    basic = 0
                  }

                  for (j = 0; j < basic; ++j) {
                    // if it's not a basic code point
                    if (input.charCodeAt(j) >= 0x80) {
                      error('not-basic')
                    }
                    output.push(input.charCodeAt(j))
                  }

                  // Main decoding loop: start just after the last delimiter if any basic code
                  // points were copied; start at the beginning otherwise.

                  for (
                    index = basic > 0 ? basic + 1 : 0;
                    index < inputLength /* no final expression */;

                  ) {
                    // `index` is the index of the next character to be consumed.
                    // Decode a generalized variable-length integer into `delta`,
                    // which gets added to `i`. The overflow checking is easier
                    // if we increase `i` as we go, then subtract off its starting
                    // value at the end to obtain `delta`.
                    for (
                      oldi = i, w = 1, k = base /* no condition */;
                      ;
                      k += base
                    ) {
                      if (index >= inputLength) {
                        error('invalid-input')
                      }

                      digit = basicToDigit(input.charCodeAt(index++))

                      if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error('overflow')
                      }

                      i += digit * w
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias

                      if (digit < t) {
                        break
                      }

                      baseMinusT = base - t
                      if (w > floor(maxInt / baseMinusT)) {
                        error('overflow')
                      }

                      w *= baseMinusT
                    }

                    out = output.length + 1
                    bias = adapt(i - oldi, out, oldi == 0)

                    // `i` was supposed to wrap around from `out` to `0`,
                    // incrementing `n` each time, so we'll fix that now:
                    if (floor(i / out) > maxInt - n) {
                      error('overflow')
                    }

                    n += floor(i / out)
                    i %= out

                    // Insert `n` at position `i` of the output
                    output.splice(i++, 0, n)
                  }

                  return ucs2encode(output)
                }

                /**
                 * Converts a string of Unicode symbols (e.g. a domain name label) to a
                 * Punycode string of ASCII-only symbols.
                 * @memberOf punycode
                 * @param {String} input The string of Unicode symbols.
                 * @returns {String} The resulting Punycode string of ASCII-only symbols.
                 */
                function encode(input) {
                  var n,
                    delta,
                    handledCPCount,
                    basicLength,
                    bias,
                    j,
                    m,
                    q,
                    k,
                    t,
                    currentValue,
                    output = [],
                    /** `inputLength` will hold the number of code points in `input`. */
                    inputLength,
                    /** Cached calculation results */
                    handledCPCountPlusOne,
                    baseMinusT,
                    qMinusT

                  // Convert the input in UCS-2 to Unicode
                  input = ucs2decode(input)

                  // Cache the length
                  inputLength = input.length

                  // Initialize the state
                  n = initialN
                  delta = 0
                  bias = initialBias

                  // Handle the basic code points
                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j]
                    if (currentValue < 0x80) {
                      output.push(stringFromCharCode(currentValue))
                    }
                  }

                  handledCPCount = basicLength = output.length

                  // `handledCPCount` is the number of code points that have been handled;
                  // `basicLength` is the number of basic code points.

                  // Finish the basic string - if it is not empty - with a delimiter
                  if (basicLength) {
                    output.push(delimiter)
                  }

                  // Main encoding loop:
                  while (handledCPCount < inputLength) {
                    // All non-basic code points < n have been handled already. Find the next
                    // larger one:
                    for (m = maxInt, j = 0; j < inputLength; ++j) {
                      currentValue = input[j]
                      if (currentValue >= n && currentValue < m) {
                        m = currentValue
                      }
                    }

                    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                    // but guard against overflow
                    handledCPCountPlusOne = handledCPCount + 1
                    if (
                      m - n >
                      floor((maxInt - delta) / handledCPCountPlusOne)
                    ) {
                      error('overflow')
                    }

                    delta += (m - n) * handledCPCountPlusOne
                    n = m

                    for (j = 0; j < inputLength; ++j) {
                      currentValue = input[j]

                      if (currentValue < n && ++delta > maxInt) {
                        error('overflow')
                      }

                      if (currentValue == n) {
                        // Represent delta as a generalized variable-length integer
                        for (
                          q = delta, k = base /* no condition */;
                          ;
                          k += base
                        ) {
                          t =
                            k <= bias
                              ? tMin
                              : k >= bias + tMax
                              ? tMax
                              : k - bias
                          if (q < t) {
                            break
                          }
                          qMinusT = q - t
                          baseMinusT = base - t
                          output.push(
                            stringFromCharCode(
                              digitToBasic(t + (qMinusT % baseMinusT), 0)
                            )
                          )
                          q = floor(qMinusT / baseMinusT)
                        }

                        output.push(stringFromCharCode(digitToBasic(q, 0)))
                        bias = adapt(
                          delta,
                          handledCPCountPlusOne,
                          handledCPCount == basicLength
                        )
                        delta = 0
                        ++handledCPCount
                      }
                    }

                    ++delta
                    ++n
                  }
                  return output.join('')
                }

                /**
                 * Converts a Punycode string representing a domain name or an email address
                 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                 * it doesn't matter if you call it on a string that has already been
                 * converted to Unicode.
                 * @memberOf punycode
                 * @param {String} input The Punycoded domain name or email address to
                 * convert to Unicode.
                 * @returns {String} The Unicode representation of the given Punycode
                 * string.
                 */
                function toUnicode(input) {
                  return mapDomain(input, function (string) {
                    return regexPunycode.test(string)
                      ? decode(string.slice(4).toLowerCase())
                      : string
                  })
                }

                /**
                 * Converts a Unicode string representing a domain name or an email address to
                 * Punycode. Only the non-ASCII parts of the domain name will be converted,
                 * i.e. it doesn't matter if you call it with a domain that's already in
                 * ASCII.
                 * @memberOf punycode
                 * @param {String} input The domain name or email address to convert, as a
                 * Unicode string.
                 * @returns {String} The Punycode representation of the given domain name or
                 * email address.
                 */
                function toASCII(input) {
                  return mapDomain(input, function (string) {
                    return regexNonASCII.test(string)
                      ? 'xn--' + encode(string)
                      : string
                  })
                }

                /*--------------------------------------------------------------------------*/

                /** Define the public API */
                punycode = {
                  /**
                   * A string representing the current Punycode.js version number.
                   * @memberOf punycode
                   * @type String
                   */
                  version: '1.4.1',
                  /**
                   * An object of methods to convert from JavaScript's internal character
                   * representation (UCS-2) to Unicode code points, and back.
                   * @see <https://mathiasbynens.be/notes/javascript-encoding>
                   * @memberOf punycode
                   * @type Object
                   */
                  ucs2: {
                    decode: ucs2decode,
                    encode: ucs2encode,
                  },
                  decode: decode,
                  encode: encode,
                  toASCII: toASCII,
                  toUnicode: toUnicode,
                }

                /** Expose `punycode` */
                // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if (
                  typeof define == 'function' &&
                  typeof define.amd == 'object' &&
                  define.amd
                ) {
                  define('punycode', function () {
                    return punycode
                  })
                } else if (freeExports && freeModule) {
                  if (module.exports == freeExports) {
                    // in Node.js, io.js, or RingoJS v0.8.0+
                    freeModule.exports = punycode
                  } else {
                    // in Narwhal or RingoJS v0.7.0-
                    for (key in punycode) {
                      punycode.hasOwnProperty(key) &&
                        (freeExports[key] = punycode[key])
                    }
                  }
                } else {
                  // in Rhino or a web browser
                  root.punycode = punycode
                }
              })(this)
            }.call(this))
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ))
        },
        {},
      ],
      58: [
        function (require, module, exports) {
          /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
          /* eslint-disable node/no-deprecated-api */
          var buffer = require('buffer')
          var Buffer = buffer.Buffer

          // alternative to using Object.keys for old browsers
          function copyProps(src, dst) {
            for (var key in src) {
              dst[key] = src[key]
            }
          }
          if (
            Buffer.from &&
            Buffer.alloc &&
            Buffer.allocUnsafe &&
            Buffer.allocUnsafeSlow
          ) {
            module.exports = buffer
          } else {
            // Copy properties from require('buffer')
            copyProps(buffer, exports)
            exports.Buffer = SafeBuffer
          }

          function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length)
          }

          SafeBuffer.prototype = Object.create(Buffer.prototype)

          // Copy static methods from Buffer
          copyProps(Buffer, SafeBuffer)

          SafeBuffer.from = function (arg, encodingOrOffset, length) {
            if (typeof arg === 'number') {
              throw new TypeError('Argument must not be a number')
            }
            return Buffer(arg, encodingOrOffset, length)
          }

          SafeBuffer.alloc = function (size, fill, encoding) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number')
            }
            var buf = Buffer(size)
            if (fill !== undefined) {
              if (typeof encoding === 'string') {
                buf.fill(fill, encoding)
              } else {
                buf.fill(fill)
              }
            } else {
              buf.fill(0)
            }
            return buf
          }

          SafeBuffer.allocUnsafe = function (size) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number')
            }
            return Buffer(size)
          }

          SafeBuffer.allocUnsafeSlow = function (size) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number')
            }
            return buffer.SlowBuffer(size)
          }
        },
        { buffer: 18 },
      ],
      59: [
        function (require, module, exports) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          'use strict'

          /*<replacement>*/

          var Buffer = require('safe-buffer').Buffer
          /*</replacement>*/

          var isEncoding =
            Buffer.isEncoding ||
            function (encoding) {
              encoding = '' + encoding
              switch (encoding && encoding.toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                case 'raw':
                  return true
                default:
                  return false
              }
            }

          function _normalizeEncoding(enc) {
            if (!enc) return 'utf8'
            var retried
            while (true) {
              switch (enc) {
                case 'utf8':
                case 'utf-8':
                  return 'utf8'
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return 'utf16le'
                case 'latin1':
                case 'binary':
                  return 'latin1'
                case 'base64':
                case 'ascii':
                case 'hex':
                  return enc
                default: // undefined
                  if (retried) return
                  enc = ('' + enc).toLowerCase()
                  retried = true
              }
            }
          }

          // Do not cache `Buffer.isEncoding` when checking encoding names as some
          // modules monkey-patch it to support additional encodings
          function normalizeEncoding(enc) {
            var nenc = _normalizeEncoding(enc)
            if (
              typeof nenc !== 'string' &&
              (Buffer.isEncoding === isEncoding || !isEncoding(enc))
            )
              throw new Error('Unknown encoding: ' + enc)
            return nenc || enc
          }

          // StringDecoder provides an interface for efficiently splitting a series of
          // buffers into a series of JS strings without breaking apart multi-byte
          // characters.
          exports.StringDecoder = StringDecoder
          function StringDecoder(encoding) {
            this.encoding = normalizeEncoding(encoding)
            var nb
            switch (this.encoding) {
              case 'utf16le':
                this.text = utf16Text
                this.end = utf16End
                nb = 4
                break
              case 'utf8':
                this.fillLast = utf8FillLast
                nb = 4
                break
              case 'base64':
                this.text = base64Text
                this.end = base64End
                nb = 3
                break
              default:
                this.write = simpleWrite
                this.end = simpleEnd
                return
            }
            this.lastNeed = 0
            this.lastTotal = 0
            this.lastChar = Buffer.allocUnsafe(nb)
          }

          StringDecoder.prototype.write = function (buf) {
            if (buf.length === 0) return ''
            var r
            var i
            if (this.lastNeed) {
              r = this.fillLast(buf)
              if (r === undefined) return ''
              i = this.lastNeed
              this.lastNeed = 0
            } else {
              i = 0
            }
            if (i < buf.length)
              return r ? r + this.text(buf, i) : this.text(buf, i)
            return r || ''
          }

          StringDecoder.prototype.end = utf8End

          // Returns only complete characters in a Buffer
          StringDecoder.prototype.text = utf8Text

          // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
          StringDecoder.prototype.fillLast = function (buf) {
            if (this.lastNeed <= buf.length) {
              buf.copy(
                this.lastChar,
                this.lastTotal - this.lastNeed,
                0,
                this.lastNeed
              )
              return this.lastChar.toString(this.encoding, 0, this.lastTotal)
            }
            buf.copy(
              this.lastChar,
              this.lastTotal - this.lastNeed,
              0,
              buf.length
            )
            this.lastNeed -= buf.length
          }

          // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
          // continuation byte. If an invalid byte is detected, -2 is returned.
          function utf8CheckByte(byte) {
            if (byte <= 0x7f) return 0
            else if (byte >> 5 === 0x06) return 2
            else if (byte >> 4 === 0x0e) return 3
            else if (byte >> 3 === 0x1e) return 4
            return byte >> 6 === 0x02 ? -1 : -2
          }

          // Checks at most 3 bytes at the end of a Buffer in order to detect an
          // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
          // needed to complete the UTF-8 character (if applicable) are returned.
          function utf8CheckIncomplete(self, buf, i) {
            var j = buf.length - 1
            if (j < i) return 0
            var nb = utf8CheckByte(buf[j])
            if (nb >= 0) {
              if (nb > 0) self.lastNeed = nb - 1
              return nb
            }
            if (--j < i || nb === -2) return 0
            nb = utf8CheckByte(buf[j])
            if (nb >= 0) {
              if (nb > 0) self.lastNeed = nb - 2
              return nb
            }
            if (--j < i || nb === -2) return 0
            nb = utf8CheckByte(buf[j])
            if (nb >= 0) {
              if (nb > 0) {
                if (nb === 2) nb = 0
                else self.lastNeed = nb - 3
              }
              return nb
            }
            return 0
          }

          // Validates as many continuation bytes for a multi-byte UTF-8 character as
          // needed or are available. If we see a non-continuation byte where we expect
          // one, we "replace" the validated continuation bytes we've seen so far with
          // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
          // behavior. The continuation byte check is included three times in the case
          // where all of the continuation bytes for a character exist in the same buffer.
          // It is also done this way as a slight performance increase instead of using a
          // loop.
          function utf8CheckExtraBytes(self, buf, p) {
            if ((buf[0] & 0xc0) !== 0x80) {
              self.lastNeed = 0
              return '\ufffd'
            }
            if (self.lastNeed > 1 && buf.length > 1) {
              if ((buf[1] & 0xc0) !== 0x80) {
                self.lastNeed = 1
                return '\ufffd'
              }
              if (self.lastNeed > 2 && buf.length > 2) {
                if ((buf[2] & 0xc0) !== 0x80) {
                  self.lastNeed = 2
                  return '\ufffd'
                }
              }
            }
          }

          // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
          function utf8FillLast(buf) {
            var p = this.lastTotal - this.lastNeed
            var r = utf8CheckExtraBytes(this, buf, p)
            if (r !== undefined) return r
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, p, 0, this.lastNeed)
              return this.lastChar.toString(this.encoding, 0, this.lastTotal)
            }
            buf.copy(this.lastChar, p, 0, buf.length)
            this.lastNeed -= buf.length
          }

          // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
          // partial character, the character's bytes are buffered until the required
          // number of bytes are available.
          function utf8Text(buf, i) {
            var total = utf8CheckIncomplete(this, buf, i)
            if (!this.lastNeed) return buf.toString('utf8', i)
            this.lastTotal = total
            var end = buf.length - (total - this.lastNeed)
            buf.copy(this.lastChar, 0, end)
            return buf.toString('utf8', i, end)
          }

          // For UTF-8, a replacement character is added when ending on a partial
          // character.
          function utf8End(buf) {
            var r = buf && buf.length ? this.write(buf) : ''
            if (this.lastNeed) return r + '\ufffd'
            return r
          }

          // UTF-16LE typically needs two bytes per character, but even if we have an even
          // number of bytes available, we need to check if we end on a leading/high
          // surrogate. In that case, we need to wait for the next two bytes in order to
          // decode the last character properly.
          function utf16Text(buf, i) {
            if ((buf.length - i) % 2 === 0) {
              var r = buf.toString('utf16le', i)
              if (r) {
                var c = r.charCodeAt(r.length - 1)
                if (c >= 0xd800 && c <= 0xdbff) {
                  this.lastNeed = 2
                  this.lastTotal = 4
                  this.lastChar[0] = buf[buf.length - 2]
                  this.lastChar[1] = buf[buf.length - 1]
                  return r.slice(0, -1)
                }
              }
              return r
            }
            this.lastNeed = 1
            this.lastTotal = 2
            this.lastChar[0] = buf[buf.length - 1]
            return buf.toString('utf16le', i, buf.length - 1)
          }

          // For UTF-16LE we do not explicitly append special replacement characters if we
          // end on a partial character, we simply let v8 handle that.
          function utf16End(buf) {
            var r = buf && buf.length ? this.write(buf) : ''
            if (this.lastNeed) {
              var end = this.lastTotal - this.lastNeed
              return r + this.lastChar.toString('utf16le', 0, end)
            }
            return r
          }

          function base64Text(buf, i) {
            var n = (buf.length - i) % 3
            if (n === 0) return buf.toString('base64', i)
            this.lastNeed = 3 - n
            this.lastTotal = 3
            if (n === 1) {
              this.lastChar[0] = buf[buf.length - 1]
            } else {
              this.lastChar[0] = buf[buf.length - 2]
              this.lastChar[1] = buf[buf.length - 1]
            }
            return buf.toString('base64', i, buf.length - n)
          }

          function base64End(buf) {
            var r = buf && buf.length ? this.write(buf) : ''
            if (this.lastNeed)
              return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed)
            return r
          }

          // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
          function simpleWrite(buf) {
            return buf.toString(this.encoding)
          }

          function simpleEnd(buf) {
            return buf && buf.length ? this.write(buf) : ''
          }
        },
        { 'safe-buffer': 58 },
      ],
      60: [
        function (require, module, exports) {
          ;(function (global) {
            ;(function () {
              /**
               * Module exports.
               */

              module.exports = deprecate

              /**
               * Mark that a method should not be used.
               * Returns a modified function which warns once by default.
               *
               * If `localStorage.noDeprecation = true` is set, then it is a no-op.
               *
               * If `localStorage.throwDeprecation = true` is set, then deprecated functions
               * will throw an Error when invoked.
               *
               * If `localStorage.traceDeprecation = true` is set, then deprecated functions
               * will invoke `console.trace()` instead of `console.error()`.
               *
               * @param {Function} fn - the function to deprecate
               * @param {String} msg - the string to print to the console when `fn` is invoked
               * @returns {Function} a new "deprecated" version of `fn`
               * @api public
               */

              function deprecate(fn, msg) {
                if (config('noDeprecation')) {
                  return fn
                }

                var warned = false
                function deprecated() {
                  if (!warned) {
                    if (config('throwDeprecation')) {
                      throw new Error(msg)
                    } else if (config('traceDeprecation')) {
                      console.trace(msg)
                    } else {
                      console.warn(msg)
                    }
                    warned = true
                  }
                  return fn.apply(this, arguments)
                }

                return deprecated
              }

              /**
               * Checks `localStorage` for boolean values for the given `name`.
               *
               * @param {String} name
               * @returns {Boolean}
               * @api private
               */

              function config(name) {
                // accessing global.localStorage can trigger a DOMException in sandboxed iframes
                try {
                  if (!global.localStorage) return false
                } catch (_) {
                  return false
                }
                var val = global.localStorage[name]
                if (null == val) return false
                return String(val).toLowerCase() === 'true'
              }
            }.call(this))
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ))
        },
        {},
      ],
      61: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.Account = void 0
          const address_1 = require('./address')
          /**
           * An abstraction representing an account (user or Smart Contract) on the Network.
           */
          class Account {
            /**
             * Creates an account object from an address
             */
            constructor(address) {
              /**
               * The address of the account.
               */
              this.address = new address_1.Address()
              /**
               * The nonce of the account (the account sequence number).
               */
              this.nonce = 0
              /**
               * The balance of the account.
               */
              this.balance = '0'
              this.address = address
            }
            /**
             * Updates account properties (such as nonce, balance).
             */
            update(obj) {
              this.nonce = obj.nonce
              this.balance = obj.balance
            }
            /**
             * Increments (locally) the nonce (the account sequence number).
             */
            incrementNonce() {
              this.nonce = this.nonce.valueOf() + 1
            }
            /**
             * Gets then increments (locally) the nonce (the account sequence number).
             */
            getNonceThenIncrement() {
              let nonce = this.nonce
              this.nonce = this.nonce.valueOf() + 1
              return nonce
            }
            /**
             * Converts the account to a pretty, plain JavaScript object.
             */
            toJSON() {
              return {
                address: this.address.bech32(),
                nonce: this.nonce.valueOf(),
                balance: this.balance.toString(),
              }
            }
          }
          exports.Account = Account
        },
        { './address': 62 },
      ],
      62: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      Object.defineProperty(o, k2, {
                        enumerable: true,
                        get: function () {
                          return m[k]
                        },
                      })
                    }
                  : function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      o[k2] = m[k]
                    })
              var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function (o, v) {
                      Object.defineProperty(o, 'default', {
                        enumerable: true,
                        value: v,
                      })
                    }
                  : function (o, v) {
                      o['default'] = v
                    })
              var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                  if (mod && mod.__esModule) return mod
                  var result = {}
                  if (mod != null)
                    for (var k in mod)
                      if (
                        k !== 'default' &&
                        Object.prototype.hasOwnProperty.call(mod, k)
                      )
                        __createBinding(result, mod, k)
                  __setModuleDefault(result, mod)
                  return result
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.Address = void 0
              const bech32 = __importStar(require('bech32'))
              const errors = __importStar(require('./errors'))
              /**
               * The human-readable-part of the bech32 addresses.
               */
              const HRP = 'erd'
              /**
               * The length (in bytes) of a public key (from which a bech32 address can be obtained).
               */
              const PUBKEY_LENGTH = 32
              const SMART_CONTRACT_HEX_PUBKEY_PREFIX = '0'.repeat(16)
              /**
               * An Address, as an immutable object.
               */
              class Address {
                /**
                 * Creates an address object, given a raw string (whether a hex pubkey or a Bech32 address), a sequence of bytes, or another Address object.
                 */
                constructor(value) {
                  // We keep a hex-encoded string as the "backing" value
                  this.valueHex = ''
                  if (!value) {
                    return
                  }
                  if (value instanceof Address) {
                    return Address.fromAddress(value)
                  }
                  if (value instanceof Buffer) {
                    return Address.fromBuffer(value)
                  }
                  if (typeof value === 'string') {
                    return Address.fromString(value)
                  }
                  throw new errors.ErrAddressCannotCreate(value)
                }
                /**
                 * Creates an address object from another address object
                 */
                static fromAddress(address) {
                  return Address.fromValidHex(address.valueHex)
                }
                static fromValidHex(value) {
                  let result = new Address()
                  result.valueHex = value
                  return result
                }
                /**
                 * Creates an address object from a Buffer
                 */
                static fromBuffer(buffer) {
                  if (buffer.length != PUBKEY_LENGTH) {
                    throw new errors.ErrAddressCannotCreate(buffer)
                  }
                  return Address.fromValidHex(buffer.toString('hex'))
                }
                /**
                 * Creates an address object from a string (hex or bech32)
                 */
                static fromString(value) {
                  if (Address.isValidHex(value)) {
                    return Address.fromValidHex(value)
                  }
                  return Address.fromBech32(value)
                }
                static isValidHex(value) {
                  return Buffer.from(value, 'hex').length == PUBKEY_LENGTH
                }
                /**
                 * Creates an address object from a hex-encoded string
                 */
                static fromHex(value) {
                  if (!Address.isValidHex(value)) {
                    throw new errors.ErrAddressCannotCreate(value)
                  }
                  return Address.fromValidHex(value)
                }
                /**
                 * Creates an empty address object
                 */
                static empty() {
                  return new Address()
                }
                /**
                 * Creates an address object from a bech32-encoded string
                 */
                static fromBech32(value) {
                  let decoded
                  try {
                    decoded = bech32.decode(value)
                  } catch (err) {
                    throw new errors.ErrAddressCannotCreate(value, err)
                  }
                  let prefix = decoded.prefix
                  if (prefix != HRP) {
                    throw new errors.ErrAddressBadHrp(HRP, prefix)
                  }
                  let pubkey = Buffer.from(bech32.fromWords(decoded.words))
                  if (pubkey.length != PUBKEY_LENGTH) {
                    throw new errors.ErrAddressCannotCreate(value)
                  }
                  return Address.fromValidHex(pubkey.toString('hex'))
                }
                /**
                 * Performs address validation without throwing errors
                 */
                static isValid(value) {
                  const decoded = bech32.decodeUnsafe(value)
                  const prefix =
                    decoded === null || decoded === void 0
                      ? void 0
                      : decoded.prefix
                  const pubkey = decoded
                    ? Buffer.from(bech32.fromWords(decoded.words))
                    : undefined
                  if (
                    prefix !== HRP ||
                    (pubkey === null || pubkey === void 0
                      ? void 0
                      : pubkey.length) !== PUBKEY_LENGTH
                  ) {
                    return false
                  }
                  return true
                }
                /**
                 * Returns the hex representation of the address (pubkey)
                 */
                hex() {
                  if (this.isEmpty()) {
                    return ''
                  }
                  return this.valueHex
                }
                /**
                 * Returns the bech32 representation of the address
                 */
                bech32() {
                  if (this.isEmpty()) {
                    return ''
                  }
                  let words = bech32.toWords(this.pubkey())
                  let address = bech32.encode(HRP, words)
                  return address
                }
                /**
                 * Returns the pubkey as raw bytes (buffer)
                 */
                pubkey() {
                  if (this.isEmpty()) {
                    return Buffer.from([])
                  }
                  return Buffer.from(this.valueHex, 'hex')
                }
                /**
                 * Returns whether the address is empty.
                 */
                isEmpty() {
                  return !this.valueHex
                }
                /**
                 * Compares the address to another address
                 */
                equals(other) {
                  if (!other) {
                    return false
                  }
                  return this.valueHex == other.valueHex
                }
                /**
                 * Returns the bech32 representation of the address
                 */
                toString() {
                  return this.bech32()
                }
                /**
                 * Converts the address to a pretty, plain JavaScript object.
                 */
                toJSON() {
                  return {
                    bech32: this.bech32(),
                    pubkey: this.hex(),
                  }
                }
                /**
                 * Creates the Zero address (the one that should be used when deploying smart contracts)
                 */
                static Zero() {
                  return new Address('0'.repeat(64))
                }
                isContractAddress() {
                  return this.hex().startsWith(SMART_CONTRACT_HEX_PUBKEY_PREFIX)
                }
              }
              exports.Address = Address
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { './errors': 66, bech32: 12, buffer: 18 },
      ],
      63: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.AsyncTimer = void 0
          const errors = __importStar(require('./errors'))
          const errors_1 = require('./errors')
          const logger_1 = require('./logger')
          /*
           * AsyncTimer is an async-friendly abstraction that wraps JavaScript's setTimeout() and clearTimeout().
           */
          class AsyncTimer {
            /**
             * Creates an AsyncTimer.
             */
            constructor(name) {
              this.timeoutHandle = null
              this.rejectionFunc = null
              this.name = name
              this.correlationTag = 0
            }
            /**
             * Starts the timer.
             * @param timeout The time (in milliseconds) to wait until resolving the promise.
             */
            start(timeout) {
              if (this.timeoutHandle) {
                throw new errors.ErrAsyncTimerAlreadyRunning()
              }
              this.correlationTag++
              logger_1.Logger.trace(
                `AsyncTimer[${this.name}'${this.correlationTag}].start()`
              )
              return new Promise((resolve, reject) => {
                this.rejectionFunc = reject
                let timeoutCallback = () => {
                  this.rejectionFunc = null
                  this.stop()
                  resolve()
                }
                this.timeoutHandle = setTimeout(timeoutCallback, timeout)
              })
            }
            /**
             * Aborts the timer: rejects the promise (if any) and stops the timer.
             */
            abort() {
              logger_1.Logger.trace(
                `AsyncTimer[${this.name}'${this.correlationTag}].abort()`
              )
              if (this.rejectionFunc) {
                this.rejectionFunc(new errors_1.ErrAsyncTimerAborted())
                this.rejectionFunc = null
              }
              this.stop()
            }
            /**
             * Stops the timer.
             */
            stop() {
              if (this.isStopped()) {
                return
              }
              logger_1.Logger.trace(
                `AsyncTimer[${this.name}'${this.correlationTag}].stop()`
              )
              if (this.timeoutHandle) {
                clearTimeout(this.timeoutHandle)
                this.timeoutHandle = null
              }
            }
            /**
             * Returns whether the timer is stopped.
             */
            isStopped() {
              return this.timeoutHandle ? false : true
            }
          }
          exports.AsyncTimer = AsyncTimer
        },
        { './errors': 66, './logger': 73 },
      ],
      64: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.Compatibility = void 0
          const address_1 = require('./address')
          /**
           * For internal use only.
           */
          class Compatibility {
            /**
             * For internal use only.
             */
            static guardAddressIsSetAndNonZero(address, context, resolution) {
              if (!this.areWarningsEnabled) {
                return
              }
              if (!address || address.bech32() == '') {
                console.warn(
                  `${context}: address should be set; ${resolution}. In the future, this will throw an exception instead of emitting a WARN.`
                )
              } else if (
                address.bech32() == address_1.Address.Zero().bech32()
              ) {
                console.warn(
                  `${context}: address should not be the 'zero' address (also known as the 'contracts deployment address'); ${resolution}. In the future, this will throw an exception instead of emitting a WARN.`
                )
              }
            }
          }
          exports.Compatibility = Compatibility
          Compatibility.areWarningsEnabled = true
        },
        { './address': 62 },
      ],
      65: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ARGUMENTS_SEPARATOR =
            exports.ESDT_TRANSFER_VALUE =
            exports.MULTI_ESDTNFT_TRANSFER_FUNCTION_NAME =
            exports.ESDTNFT_TRANSFER_FUNCTION_NAME =
            exports.ESDT_TRANSFER_FUNCTION_NAME =
            exports.ESDT_TRANSFER_GAS_LIMIT =
            exports.TRANSACTION_VERSION_WITH_OPTIONS =
            exports.TRANSACTION_VERSION_DEFAULT =
            exports.TRANSACTION_OPTIONS_TX_GUARDED =
            exports.TRANSACTION_OPTIONS_TX_HASH_SIGN =
            exports.TRANSACTION_OPTIONS_DEFAULT =
            exports.TRANSACTION_MIN_GAS_PRICE =
              void 0
          exports.TRANSACTION_MIN_GAS_PRICE = 1000000000
          exports.TRANSACTION_OPTIONS_DEFAULT = 0
          exports.TRANSACTION_OPTIONS_TX_HASH_SIGN = 0b0001
          exports.TRANSACTION_OPTIONS_TX_GUARDED = 0b0010
          exports.TRANSACTION_VERSION_DEFAULT = 1
          exports.TRANSACTION_VERSION_WITH_OPTIONS = 2
          exports.ESDT_TRANSFER_GAS_LIMIT = 500000
          exports.ESDT_TRANSFER_FUNCTION_NAME = 'ESDTTransfer'
          exports.ESDTNFT_TRANSFER_FUNCTION_NAME = 'ESDTNFTTransfer'
          exports.MULTI_ESDTNFT_TRANSFER_FUNCTION_NAME = 'MultiESDTNFTTransfer'
          exports.ESDT_TRANSFER_VALUE = '0'
          exports.ARGUMENTS_SEPARATOR = '@'
        },
        {},
      ],
      66: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ErrIsCompletedFieldIsMissingOnTransaction =
            exports.ErrGasLimitShouldBe0ForInnerTransaction =
            exports.ErrInvalidRelayedV2BuilderArguments =
            exports.ErrInvalidRelayedV1BuilderArguments =
            exports.ErrNotImplemented =
            exports.ErrContractInteraction =
            exports.ErrCodec =
            exports.ErrCannotParseTransactionOutcome =
            exports.ErrCannotParseContractResults =
            exports.ErrMissingFieldOnEnum =
            exports.ErrMissingFieldOnStruct =
            exports.ErrTypingSystem =
            exports.ErrMock =
            exports.ErrContractHasNoAddress =
            exports.ErrContract =
            exports.ErrExpectedTransactionEventsNotFound =
            exports.ErrExpectedTransactionStatusNotReached =
            exports.ErrTransactionWatcherTimeout =
            exports.ErrAsyncTimerAborted =
            exports.ErrAsyncTimerAlreadyRunning =
            exports.ErrInvalidFunctionName =
            exports.ErrSignatureCannotCreate =
            exports.ErrTransactionOptionsInvalid =
            exports.ErrTransactionVersionInvalid =
            exports.ErrNonceInvalid =
            exports.ErrNotEnoughGas =
            exports.ErrAddressEmpty =
            exports.ErrAddressBadHrp =
            exports.ErrAddressCannotCreate =
            exports.ErrUnexpectedCondition =
            exports.ErrInvariantFailed =
            exports.ErrBadType =
            exports.ErrUnsupportedOperation =
            exports.ErrInvalidArgument =
            exports.Err =
              void 0
          /**
           * The base class for exceptions (errors).
           */
          class Err extends Error {
            constructor(message, inner) {
              super(message)
              this.inner = undefined
              this.inner = inner
            }
            /**
             * Returns a pretty, friendly summary for the error or for the chain of errros (if appropriate).
             */
            summary() {
              let result = []
              result.push({ name: this.name, message: this.message })
              let inner = this.inner
              while (inner) {
                result.push({ name: inner.name, message: inner.message })
                inner = inner.inner
              }
              return result
            }
          }
          exports.Err = Err
          /**
           * Signals invalid arguments for a function, for an operation.
           */
          class ErrInvalidArgument extends Err {
            constructor(message, inner) {
              super(`Invalid argument: ${message}`, inner)
            }
          }
          exports.ErrInvalidArgument = ErrInvalidArgument
          /**
           * Signals an unsupported operation.
           */
          class ErrUnsupportedOperation extends Err {
            constructor(operation, reason = 'not specified') {
              super(`Operation "${operation}" not supported. Reason: ${reason}`)
            }
          }
          exports.ErrUnsupportedOperation = ErrUnsupportedOperation
          /**
           * Signals the provisioning of objects of unexpected (bad) types.
           */
          class ErrBadType extends Err {
            constructor(name, type, value) {
              super(`Bad type of "${name}": ${value}. Expected type: ${type}`)
            }
          }
          exports.ErrBadType = ErrBadType
          /**
           * Signals that an invariant failed.
           */
          class ErrInvariantFailed extends Err {
            constructor(message) {
              super(`Invariant failed: [${message}]`)
            }
          }
          exports.ErrInvariantFailed = ErrInvariantFailed
          /**
           * Signals an unexpected condition.
           */
          class ErrUnexpectedCondition extends Err {
            constructor(message) {
              super(`Unexpected condition: [${message}]`)
            }
          }
          exports.ErrUnexpectedCondition = ErrUnexpectedCondition
          /**
           * Signals issues with {@link Address} instantiation.
           */
          class ErrAddressCannotCreate extends Err {
            constructor(input, inner) {
              let message = `Cannot create address from: ${input}`
              super(message, inner)
            }
          }
          exports.ErrAddressCannotCreate = ErrAddressCannotCreate
          /**
           * Signals issues with the HRP of an {@link Address}.
           */
          class ErrAddressBadHrp extends Err {
            constructor(expected, got) {
              super(`Wrong address HRP. Expected: ${expected}, got ${got}`)
            }
          }
          exports.ErrAddressBadHrp = ErrAddressBadHrp
          /**
           * Signals the presence of an empty / invalid address.
           */
          class ErrAddressEmpty extends Err {
            constructor() {
              super(`Address is empty`)
            }
          }
          exports.ErrAddressEmpty = ErrAddressEmpty
          /**
           * Signals an invalid value for {@link GasLimit} objects.
           */
          class ErrNotEnoughGas extends Err {
            constructor(value) {
              super(`Not enough gas provided: ${value}`)
            }
          }
          exports.ErrNotEnoughGas = ErrNotEnoughGas
          /**
           * Signals an invalid value for {@link Nonce} objects.
           */
          class ErrNonceInvalid extends Err {
            constructor(value) {
              super(`Invalid nonce: ${value}`)
            }
          }
          exports.ErrNonceInvalid = ErrNonceInvalid
          /**
           * Signals an invalid value for {@link TransactionVersion} objects.
           */
          class ErrTransactionVersionInvalid extends Err {
            constructor(value) {
              super(`Invalid transaction version: ${value}`)
            }
          }
          exports.ErrTransactionVersionInvalid = ErrTransactionVersionInvalid
          /**
           * Signals an invalid value for {@link TransactionOptions} objects.
           */
          class ErrTransactionOptionsInvalid extends Err {
            constructor(value) {
              super(`Invalid transaction options: ${value}`)
            }
          }
          exports.ErrTransactionOptionsInvalid = ErrTransactionOptionsInvalid
          /**
           * Signals an error related to signing a message (a transaction).
           */
          class ErrSignatureCannotCreate extends Err {
            constructor(input, inner) {
              let message = `Cannot create signature from: ${input}`
              super(message, inner)
            }
          }
          exports.ErrSignatureCannotCreate = ErrSignatureCannotCreate
          /**
           * Signals an invalid value for the name of a {@link ContractFunction}.
           */
          class ErrInvalidFunctionName extends Err {
            constructor() {
              super(`Invalid function name`)
            }
          }
          exports.ErrInvalidFunctionName = ErrInvalidFunctionName
          /**
           * Signals a failed operation, since the Timer is already running.
           */
          class ErrAsyncTimerAlreadyRunning extends Err {
            constructor() {
              super('Async timer already running')
            }
          }
          exports.ErrAsyncTimerAlreadyRunning = ErrAsyncTimerAlreadyRunning
          /**
           * Signals a failed operation, since the Timer has been aborted.
           */
          class ErrAsyncTimerAborted extends Err {
            constructor() {
              super('Async timer aborted')
            }
          }
          exports.ErrAsyncTimerAborted = ErrAsyncTimerAborted
          /**
           * Signals a timout for a {@link TransactionWatcher}.
           */
          class ErrTransactionWatcherTimeout extends Err {
            constructor() {
              super(`TransactionWatcher has timed out`)
            }
          }
          exports.ErrTransactionWatcherTimeout = ErrTransactionWatcherTimeout
          /**
           * Signals an issue related to waiting for a specific transaction status.
           */
          class ErrExpectedTransactionStatusNotReached extends Err {
            constructor() {
              super(`Expected transaction status not reached`)
            }
          }
          exports.ErrExpectedTransactionStatusNotReached =
            ErrExpectedTransactionStatusNotReached
          /**
           * Signals an issue related to waiting for specific transaction events.
           */
          class ErrExpectedTransactionEventsNotFound extends Err {
            constructor() {
              super(`Expected transaction events not found`)
            }
          }
          exports.ErrExpectedTransactionEventsNotFound =
            ErrExpectedTransactionEventsNotFound
          /**
           * Signals a generic error in the context of Smart Contracts.
           */
          class ErrContract extends Err {
            constructor(message) {
              super(message)
            }
          }
          exports.ErrContract = ErrContract
          class ErrContractHasNoAddress extends ErrContract {
            constructor() {
              super(`
The smart contract has no address set. Make sure you provide the address in the constructor, or call setAddress() appropriately.
If you need to recompute the address of the contract, make use of SmartContract.computeAddress() (static method). 
`)
            }
          }
          exports.ErrContractHasNoAddress = ErrContractHasNoAddress
          /**
           * Signals an error thrown by the mock-like test objects.
           */
          class ErrMock extends Err {
            constructor(message) {
              super(message)
            }
          }
          exports.ErrMock = ErrMock
          /**
           * Signals a generic type error.
           */
          class ErrTypingSystem extends Err {
            constructor(message) {
              super(message)
            }
          }
          exports.ErrTypingSystem = ErrTypingSystem
          /**
           * Signals a missing field on a struct.
           */
          class ErrMissingFieldOnStruct extends Err {
            constructor(fieldName, structName) {
              super(`field ${fieldName} does not exist on struct ${structName}`)
            }
          }
          exports.ErrMissingFieldOnStruct = ErrMissingFieldOnStruct
          /**
           * Signals a missing field on an enum.
           */
          class ErrMissingFieldOnEnum extends Err {
            constructor(fieldName, enumName) {
              super(`field ${fieldName} does not exist on enum ${enumName}`)
            }
          }
          exports.ErrMissingFieldOnEnum = ErrMissingFieldOnEnum
          /**
           * Signals an error when parsing the contract results.
           */
          class ErrCannotParseContractResults extends Err {
            constructor(details) {
              super(`cannot parse contract results: ${details}`)
            }
          }
          exports.ErrCannotParseContractResults = ErrCannotParseContractResults
          /**
           * Signals an error when parsing the outcome of a transaction (results and logs).
           */
          class ErrCannotParseTransactionOutcome extends Err {
            constructor(transactionHash, message) {
              super(
                `cannot parse outcome of transaction ${transactionHash}: ${message}`
              )
            }
          }
          exports.ErrCannotParseTransactionOutcome =
            ErrCannotParseTransactionOutcome
          /**
           * Signals a generic codec (encode / decode) error.
           */
          class ErrCodec extends Err {
            constructor(message) {
              super(message)
            }
          }
          exports.ErrCodec = ErrCodec
          /**
           * Signals a generic contract interaction error.
           */
          class ErrContractInteraction extends Err {
            constructor(message) {
              super(message)
            }
          }
          exports.ErrContractInteraction = ErrContractInteraction
          /**
           * Signals that a method is not yet implemented
           */
          class ErrNotImplemented extends Err {
            constructor() {
              super('Method not yet implemented')
            }
          }
          exports.ErrNotImplemented = ErrNotImplemented
          /**
           * Signals invalid arguments when using the relayed v1 builder
           */
          class ErrInvalidRelayedV1BuilderArguments extends Err {
            constructor() {
              super('invalid arguments for relayed v1 builder')
            }
          }
          exports.ErrInvalidRelayedV1BuilderArguments =
            ErrInvalidRelayedV1BuilderArguments
          /**
           * Signals invalid arguments when using the relayed v2 builder
           */
          class ErrInvalidRelayedV2BuilderArguments extends Err {
            constructor() {
              super('invalid arguments for relayed v2 builder')
            }
          }
          exports.ErrInvalidRelayedV2BuilderArguments =
            ErrInvalidRelayedV2BuilderArguments
          /**
           * Signals that Gas Limit isn't 0 for an inner tx when using relayed v2 builder
           */
          class ErrGasLimitShouldBe0ForInnerTransaction extends Err {
            constructor() {
              super(
                'gas limit must be 0 for the inner transaction for relayed v2'
              )
            }
          }
          exports.ErrGasLimitShouldBe0ForInnerTransaction =
            ErrGasLimitShouldBe0ForInnerTransaction
          class ErrIsCompletedFieldIsMissingOnTransaction extends Err {
            constructor() {
              super(
                "The transaction watcher requires the `isCompleted` property to be defined on the transaction object. Perhaps you've used the sdk-network-provider's `ProxyNetworkProvider.getTransaction()` and in that case you should also pass `withProcessStatus=true`."
              )
            }
          }
          exports.ErrIsCompletedFieldIsMissingOnTransaction =
            ErrIsCompletedFieldIsMissingOnTransaction
        },
        {},
      ],
      67: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.GasEstimator = exports.DefaultGasConfiguration = void 0
          /**
           * This is mirroring (on a best efforts basis) the network's gas configuration & gas schedule:
           *  - https://gateway.multiversx.com/network/config
           *  - https://github.com/multiversx/mx-chain-mainnet-config/tree/master/gasSchedules
           *  - https://github.com/multiversx/mx-chain-mainnet-config/blob/master/enableEpochs.toml#L200
           */
          exports.DefaultGasConfiguration = {
            minGasLimit: 50000,
            gasPerDataByte: 1500,
            gasCostESDTTransfer: 200000,
            gasCostESDTNFTTransfer: 200000,
            gasCostESDTNFTMultiTransfer: 200000,
          }
          // Additional gas to account for eventual increases in gas requirements (thus avoid fast-breaking changes in clients of the library).
          const ADDITIONAL_GAS_FOR_ESDT_TRANSFER = 100000
          // Additional gas to account for extra blockchain operations (e.g. data movement (between accounts) for NFTs),
          // and for eventual increases in gas requirements (thus avoid fast-breaking changes in clients of the library).
          const ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER = 800000
          class GasEstimator {
            constructor(gasConfiguration) {
              this.gasConfiguration =
                gasConfiguration || exports.DefaultGasConfiguration
            }
            forEGLDTransfer(dataLength) {
              const gasLimit =
                this.gasConfiguration.minGasLimit +
                this.gasConfiguration.gasPerDataByte * dataLength
              return gasLimit
            }
            forESDTTransfer(dataLength) {
              const gasLimit =
                this.gasConfiguration.minGasLimit +
                this.gasConfiguration.gasCostESDTTransfer +
                this.gasConfiguration.gasPerDataByte * dataLength +
                ADDITIONAL_GAS_FOR_ESDT_TRANSFER
              return gasLimit
            }
            forESDTNFTTransfer(dataLength) {
              const gasLimit =
                this.gasConfiguration.minGasLimit +
                this.gasConfiguration.gasCostESDTNFTTransfer +
                this.gasConfiguration.gasPerDataByte * dataLength +
                ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER
              return gasLimit
            }
            forMultiESDTNFTTransfer(dataLength, numTransfers) {
              const gasLimit =
                this.gasConfiguration.minGasLimit +
                (this.gasConfiguration.gasCostESDTNFTMultiTransfer +
                  ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER) *
                  numTransfers +
                this.gasConfiguration.gasPerDataByte * dataLength
              return gasLimit
            }
          }
          exports.GasEstimator = GasEstimator
        },
        {},
      ],
      68: [
        function (require, module, exports) {
          ;(function (global) {
            ;(function () {
              'use strict'
              if (!global.Buffer) {
                global.Buffer = require('buffer').Buffer
              }
            }.call(this))
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ))
        },
        { buffer: 18 },
      ],
      69: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      Object.defineProperty(o, k2, {
                        enumerable: true,
                        get: function () {
                          return m[k]
                        },
                      })
                    }
                  : function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      o[k2] = m[k]
                    })
              var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function (o, v) {
                      Object.defineProperty(o, 'default', {
                        enumerable: true,
                        value: v,
                      })
                    }
                  : function (o, v) {
                      o['default'] = v
                    })
              var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                  if (mod && mod.__esModule) return mod
                  var result = {}
                  if (mod != null)
                    for (var k in mod)
                      if (
                        k !== 'default' &&
                        Object.prototype.hasOwnProperty.call(mod, k)
                      )
                        __createBinding(result, mod, k)
                  __setModuleDefault(result, mod)
                  return result
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.Hash = void 0
              const errors = __importStar(require('./errors'))
              class Hash {
                /**
                 * Creates a new Hash object.
                 *
                 * @param hash The hash, as a Buffer or a hex-encoded string.
                 */
                constructor(hash) {
                  if (!hash) {
                    this.hash = Buffer.from([])
                  } else if (hash instanceof Buffer) {
                    this.hash = hash
                  } else if (typeof hash === 'string') {
                    this.hash = Buffer.from(hash, 'hex')
                  } else {
                    throw new errors.ErrBadType('hash', 'buffer | string', hash)
                  }
                }
                static empty() {
                  return new Hash(Buffer.from([]))
                }
                /**
                 * Returns whether the hash is empty (not computed).
                 */
                isEmpty() {
                  return this.hash.length == 0
                }
                toString() {
                  return this.hex()
                }
                hex() {
                  return this.hash.toString('hex')
                }
                valueOf() {
                  return this.hash
                }
              }
              exports.Hash = Hash
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { './errors': 66, buffer: 18 },
      ],
      70: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __exportStar =
            (this && this.__exportStar) ||
            function (m, exports) {
              for (var p in m)
                if (
                  p !== 'default' &&
                  !Object.prototype.hasOwnProperty.call(exports, p)
                )
                  __createBinding(exports, m, p)
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          require('./globals')
          __exportStar(require('./account'), exports)
          __exportStar(require('./address'), exports)
          __exportStar(require('./asyncTimer'), exports)
          __exportStar(require('./errors'), exports)
          __exportStar(require('./gasEstimator'), exports)
          __exportStar(require('./interface'), exports)
          __exportStar(require('./interfaceOfNetwork'), exports)
          __exportStar(require('./logger'), exports)
          __exportStar(require('./networkParams'), exports)
          __exportStar(require('./relayedTransactionV1Builder'), exports)
          __exportStar(require('./relayedTransactionV2Builder'), exports)
          __exportStar(require('./signableMessage'), exports)
          __exportStar(require('./smartcontracts'), exports)
          __exportStar(require('./tokenOperations'), exports)
          __exportStar(require('./tokenTransfer'), exports)
          __exportStar(require('./transaction'), exports)
          __exportStar(require('./transactionPayload'), exports)
          __exportStar(require('./transactionWatcher'), exports)
          __exportStar(require('./transferTransactionsFactory'), exports)
          __exportStar(require('./utils'), exports)
        },
        {
          './account': 61,
          './address': 62,
          './asyncTimer': 63,
          './errors': 66,
          './gasEstimator': 67,
          './globals': 68,
          './interface': 71,
          './interfaceOfNetwork': 72,
          './logger': 73,
          './networkParams': 74,
          './relayedTransactionV1Builder': 79,
          './relayedTransactionV2Builder': 80,
          './signableMessage': 81,
          './smartcontracts': 109,
          './tokenOperations': 148,
          './tokenTransfer': 152,
          './transaction': 153,
          './transactionPayload': 154,
          './transactionWatcher': 155,
          './transferTransactionsFactory': 156,
          './utils': 158,
        },
      ],
      71: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
        },
        {},
      ],
      72: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
        },
        {},
      ],
      73: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.Logger = exports.LogLevel = void 0
          var LogLevel
          ;(function (LogLevel) {
            LogLevel[(LogLevel['Trace'] = 0)] = 'Trace'
            LogLevel[(LogLevel['Debug'] = 1)] = 'Debug'
            LogLevel[(LogLevel['Info'] = 2)] = 'Info'
            LogLevel[(LogLevel['Warn'] = 3)] = 'Warn'
            LogLevel[(LogLevel['Error'] = 4)] = 'Error'
            LogLevel[(LogLevel['None'] = 5)] = 'None'
          })((LogLevel = exports.LogLevel || (exports.LogLevel = {})))
          class Logger {
            static setLevel(logLevel) {
              Logger.logLevel = logLevel
            }
            static trace(message, ...optionalParams) {
              if (Logger.logLevel >= LogLevel.Debug) {
                return
              }
              console.debug(message, optionalParams)
            }
            static debug(message, ...optionalParams) {
              if (Logger.logLevel >= LogLevel.Debug) {
                return
              }
              console.debug(message, optionalParams)
            }
            static info(message, ...optionalParams) {
              if (Logger.logLevel >= LogLevel.Info) {
                return
              }
              console.log(message, optionalParams)
            }
            static warn(message, ...optionalParams) {
              if (Logger.logLevel >= LogLevel.Warn) {
                return
              }
              console.warn(message, optionalParams)
            }
            static error(message, ...optionalParams) {
              if (Logger.logLevel >= LogLevel.Error) {
                return
              }
              console.error(message, optionalParams)
            }
          }
          exports.Logger = Logger
          Logger.logLevel = LogLevel.Debug
        },
        {},
      ],
      74: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TransactionOptions = exports.TransactionVersion = void 0
          const constants_1 = require('./constants')
          const errors = __importStar(require('./errors'))
          class TransactionVersion {
            /**
             * Creates a TransactionVersion object given a value.
             */
            constructor(value) {
              value = Number(value)
              if (value < 1) {
                throw new errors.ErrTransactionVersionInvalid(value)
              }
              this.value = value
            }
            /**
             * Creates a TransactionVersion object with the default version setting
             */
            static withDefaultVersion() {
              return new TransactionVersion(
                constants_1.TRANSACTION_VERSION_DEFAULT
              )
            }
            /**
             * Creates a TransactionVersion object with the VERSION setting for enabling options
             */
            static withTxOptions() {
              return new TransactionVersion(
                constants_1.TRANSACTION_VERSION_WITH_OPTIONS
              )
            }
            valueOf() {
              return this.value
            }
          }
          exports.TransactionVersion = TransactionVersion
          class TransactionOptions {
            /**
             * Creates a TransactionOptions from a numeric value.
             */
            constructor(value) {
              value = Number(value)
              if (value < 0) {
                throw new errors.ErrTransactionOptionsInvalid(value)
              }
              this.value = value
            }
            /**
             * Creates a TransactionOptions object with the default options.
             */
            static withDefaultOptions() {
              return new TransactionOptions(
                constants_1.TRANSACTION_OPTIONS_DEFAULT
              )
            }
            /**
             * Creates a TransactionOptions object from a set of options.
             */
            static withOptions(options) {
              let value = 0
              if (options.hashSign) {
                value |= constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN
              }
              if (options.guarded) {
                value |= constants_1.TRANSACTION_OPTIONS_TX_GUARDED
              }
              return new TransactionOptions(value)
            }
            /**
             * Returns true if the "hash sign" option is set.
             */
            isWithHashSign() {
              return (
                (this.value & constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN) ==
                constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN
              )
            }
            /**
             * Returns true if the "guarded transaction" option is set.
             */
            isWithGuardian() {
              return (
                (this.value & constants_1.TRANSACTION_OPTIONS_TX_GUARDED) ==
                constants_1.TRANSACTION_OPTIONS_TX_GUARDED
              )
            }
            /**
             * Sets the "hash sign" option.
             */
            setWithHashSign() {
              this.value |= constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN
            }
            /**
             * Sets the "guarded transaction" option.
             */
            setWithGuardian() {
              this.value |= constants_1.TRANSACTION_OPTIONS_TX_GUARDED
            }
            valueOf() {
              return this.value
            }
          }
          exports.TransactionOptions = TransactionOptions
        },
        { './constants': 65, './errors': 66 },
      ],
      75: [
        function (require, module, exports) {
          /*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
          'use strict'
          var $protobuf = require('protobufjs/minimal')
          // Common aliases
          var $Reader = $protobuf.Reader,
            $Writer = $protobuf.Writer,
            $util = $protobuf.util
          // Exported root namespace
          var $root =
            $protobuf.roots['default'] || ($protobuf.roots['default'] = {})
          $root.proto = (function () {
            /**
             * Namespace proto.
             * @exports proto
             * @namespace
             */
            var proto = {}
            proto.Transaction = (function () {
              /**
               * Properties of a Transaction.
               * @memberof proto
               * @interface ITransaction
               * @property {number|Long|null} [Nonce] Transaction Nonce
               * @property {Uint8Array|null} [Value] Transaction Value
               * @property {Uint8Array|null} [RcvAddr] Transaction RcvAddr
               * @property {Uint8Array|null} [RcvUserName] Transaction RcvUserName
               * @property {Uint8Array|null} [SndAddr] Transaction SndAddr
               * @property {Uint8Array|null} [SndUserName] Transaction SndUserName
               * @property {number|Long|null} [GasPrice] Transaction GasPrice
               * @property {number|Long|null} [GasLimit] Transaction GasLimit
               * @property {Uint8Array|null} [Data] Transaction Data
               * @property {Uint8Array|null} [ChainID] Transaction ChainID
               * @property {number|null} [Version] Transaction Version
               * @property {Uint8Array|null} [Signature] Transaction Signature
               * @property {number|null} [Options] Transaction Options
               * @property {Uint8Array|null} [GuardAddr] Transaction GuardAddr
               * @property {Uint8Array|null} [GuardSignature] Transaction GuardSignature
               */
              /**
               * Constructs a new Transaction.
               * @memberof proto
               * @classdesc Represents a Transaction.
               * @implements ITransaction
               * @constructor
               * @param {proto.ITransaction=} [properties] Properties to set
               */
              function Transaction(properties) {
                if (properties)
                  for (
                    var keys = Object.keys(properties), i = 0;
                    i < keys.length;
                    ++i
                  )
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]]
              }
              /**
               * Transaction Nonce.
               * @member {number|Long} Nonce
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.Nonce = $util.Long
                ? $util.Long.fromBits(0, 0, true)
                : 0
              /**
               * Transaction Value.
               * @member {Uint8Array} Value
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.Value = $util.newBuffer([])
              /**
               * Transaction RcvAddr.
               * @member {Uint8Array} RcvAddr
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.RcvAddr = $util.newBuffer([])
              /**
               * Transaction RcvUserName.
               * @member {Uint8Array} RcvUserName
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.RcvUserName = $util.newBuffer([])
              /**
               * Transaction SndAddr.
               * @member {Uint8Array} SndAddr
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.SndAddr = $util.newBuffer([])
              /**
               * Transaction SndUserName.
               * @member {Uint8Array} SndUserName
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.SndUserName = $util.newBuffer([])
              /**
               * Transaction GasPrice.
               * @member {number|Long} GasPrice
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.GasPrice = $util.Long
                ? $util.Long.fromBits(0, 0, true)
                : 0
              /**
               * Transaction GasLimit.
               * @member {number|Long} GasLimit
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.GasLimit = $util.Long
                ? $util.Long.fromBits(0, 0, true)
                : 0
              /**
               * Transaction Data.
               * @member {Uint8Array} Data
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.Data = $util.newBuffer([])
              /**
               * Transaction ChainID.
               * @member {Uint8Array} ChainID
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.ChainID = $util.newBuffer([])
              /**
               * Transaction Version.
               * @member {number} Version
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.Version = 0
              /**
               * Transaction Signature.
               * @member {Uint8Array} Signature
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.Signature = $util.newBuffer([])
              /**
               * Transaction Options.
               * @member {number} Options
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.Options = 0
              /**
               * Transaction GuardAddr.
               * @member {Uint8Array} GuardAddr
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.GuardAddr = $util.newBuffer([])
              /**
               * Transaction GuardSignature.
               * @member {Uint8Array} GuardSignature
               * @memberof proto.Transaction
               * @instance
               */
              Transaction.prototype.GuardSignature = $util.newBuffer([])
              /**
               * Creates a new Transaction instance using the specified properties.
               * @function create
               * @memberof proto.Transaction
               * @static
               * @param {proto.ITransaction=} [properties] Properties to set
               * @returns {proto.Transaction} Transaction instance
               */
              Transaction.create = function create(properties) {
                return new Transaction(properties)
              }
              /**
               * Encodes the specified Transaction message. Does not implicitly {@link proto.Transaction.verify|verify} messages.
               * @function encode
               * @memberof proto.Transaction
               * @static
               * @param {proto.ITransaction} message Transaction message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Transaction.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create()
                if (
                  message.Nonce != null &&
                  Object.hasOwnProperty.call(message, 'Nonce')
                )
                  writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.Nonce)
                if (
                  message.Value != null &&
                  Object.hasOwnProperty.call(message, 'Value')
                )
                  writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.Value)
                if (
                  message.RcvAddr != null &&
                  Object.hasOwnProperty.call(message, 'RcvAddr')
                )
                  writer
                    .uint32(/* id 3, wireType 2 =*/ 26)
                    .bytes(message.RcvAddr)
                if (
                  message.RcvUserName != null &&
                  Object.hasOwnProperty.call(message, 'RcvUserName')
                )
                  writer
                    .uint32(/* id 4, wireType 2 =*/ 34)
                    .bytes(message.RcvUserName)
                if (
                  message.SndAddr != null &&
                  Object.hasOwnProperty.call(message, 'SndAddr')
                )
                  writer
                    .uint32(/* id 5, wireType 2 =*/ 42)
                    .bytes(message.SndAddr)
                if (
                  message.SndUserName != null &&
                  Object.hasOwnProperty.call(message, 'SndUserName')
                )
                  writer
                    .uint32(/* id 6, wireType 2 =*/ 50)
                    .bytes(message.SndUserName)
                if (
                  message.GasPrice != null &&
                  Object.hasOwnProperty.call(message, 'GasPrice')
                )
                  writer
                    .uint32(/* id 7, wireType 0 =*/ 56)
                    .uint64(message.GasPrice)
                if (
                  message.GasLimit != null &&
                  Object.hasOwnProperty.call(message, 'GasLimit')
                )
                  writer
                    .uint32(/* id 8, wireType 0 =*/ 64)
                    .uint64(message.GasLimit)
                if (
                  message.Data != null &&
                  Object.hasOwnProperty.call(message, 'Data')
                )
                  writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.Data)
                if (
                  message.ChainID != null &&
                  Object.hasOwnProperty.call(message, 'ChainID')
                )
                  writer
                    .uint32(/* id 10, wireType 2 =*/ 82)
                    .bytes(message.ChainID)
                if (
                  message.Version != null &&
                  Object.hasOwnProperty.call(message, 'Version')
                )
                  writer
                    .uint32(/* id 11, wireType 0 =*/ 88)
                    .uint32(message.Version)
                if (
                  message.Signature != null &&
                  Object.hasOwnProperty.call(message, 'Signature')
                )
                  writer
                    .uint32(/* id 12, wireType 2 =*/ 98)
                    .bytes(message.Signature)
                if (
                  message.Options != null &&
                  Object.hasOwnProperty.call(message, 'Options')
                )
                  writer
                    .uint32(/* id 13, wireType 0 =*/ 104)
                    .uint32(message.Options)
                if (
                  message.GuardAddr != null &&
                  Object.hasOwnProperty.call(message, 'GuardAddr')
                )
                  writer
                    .uint32(/* id 14, wireType 2 =*/ 114)
                    .bytes(message.GuardAddr)
                if (
                  message.GuardSignature != null &&
                  Object.hasOwnProperty.call(message, 'GuardSignature')
                )
                  writer
                    .uint32(/* id 15, wireType 2 =*/ 122)
                    .bytes(message.GuardSignature)
                return writer
              }
              /**
               * Encodes the specified Transaction message, length delimited. Does not implicitly {@link proto.Transaction.verify|verify} messages.
               * @function encodeDelimited
               * @memberof proto.Transaction
               * @static
               * @param {proto.ITransaction} message Transaction message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Transaction.encodeDelimited = function encodeDelimited(
                message,
                writer
              ) {
                return this.encode(message, writer).ldelim()
              }
              /**
               * Decodes a Transaction message from the specified reader or buffer.
               * @function decode
               * @memberof proto.Transaction
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {proto.Transaction} Transaction
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Transaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader)
                var end =
                    length === undefined ? reader.len : reader.pos + length,
                  message = new $root.proto.Transaction()
                while (reader.pos < end) {
                  var tag = reader.uint32()
                  switch (tag >>> 3) {
                    case 1:
                      message.Nonce = reader.uint64()
                      break
                    case 2:
                      message.Value = reader.bytes()
                      break
                    case 3:
                      message.RcvAddr = reader.bytes()
                      break
                    case 4:
                      message.RcvUserName = reader.bytes()
                      break
                    case 5:
                      message.SndAddr = reader.bytes()
                      break
                    case 6:
                      message.SndUserName = reader.bytes()
                      break
                    case 7:
                      message.GasPrice = reader.uint64()
                      break
                    case 8:
                      message.GasLimit = reader.uint64()
                      break
                    case 9:
                      message.Data = reader.bytes()
                      break
                    case 10:
                      message.ChainID = reader.bytes()
                      break
                    case 11:
                      message.Version = reader.uint32()
                      break
                    case 12:
                      message.Signature = reader.bytes()
                      break
                    case 13:
                      message.Options = reader.uint32()
                      break
                    case 14:
                      message.GuardAddr = reader.bytes()
                      break
                    case 15:
                      message.GuardSignature = reader.bytes()
                      break
                    default:
                      reader.skipType(tag & 7)
                      break
                  }
                }
                return message
              }
              /**
               * Decodes a Transaction message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof proto.Transaction
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {proto.Transaction} Transaction
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Transaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader)
                return this.decode(reader, reader.uint32())
              }
              /**
               * Verifies a Transaction message.
               * @function verify
               * @memberof proto.Transaction
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              Transaction.verify = function verify(message) {
                if (typeof message !== 'object' || message === null)
                  return 'object expected'
                if (message.Nonce != null && message.hasOwnProperty('Nonce'))
                  if (
                    !$util.isInteger(message.Nonce) &&
                    !(
                      message.Nonce &&
                      $util.isInteger(message.Nonce.low) &&
                      $util.isInteger(message.Nonce.high)
                    )
                  )
                    return 'Nonce: integer|Long expected'
                if (message.Value != null && message.hasOwnProperty('Value'))
                  if (
                    !(
                      (message.Value &&
                        typeof message.Value.length === 'number') ||
                      $util.isString(message.Value)
                    )
                  )
                    return 'Value: buffer expected'
                if (
                  message.RcvAddr != null &&
                  message.hasOwnProperty('RcvAddr')
                )
                  if (
                    !(
                      (message.RcvAddr &&
                        typeof message.RcvAddr.length === 'number') ||
                      $util.isString(message.RcvAddr)
                    )
                  )
                    return 'RcvAddr: buffer expected'
                if (
                  message.RcvUserName != null &&
                  message.hasOwnProperty('RcvUserName')
                )
                  if (
                    !(
                      (message.RcvUserName &&
                        typeof message.RcvUserName.length === 'number') ||
                      $util.isString(message.RcvUserName)
                    )
                  )
                    return 'RcvUserName: buffer expected'
                if (
                  message.SndAddr != null &&
                  message.hasOwnProperty('SndAddr')
                )
                  if (
                    !(
                      (message.SndAddr &&
                        typeof message.SndAddr.length === 'number') ||
                      $util.isString(message.SndAddr)
                    )
                  )
                    return 'SndAddr: buffer expected'
                if (
                  message.SndUserName != null &&
                  message.hasOwnProperty('SndUserName')
                )
                  if (
                    !(
                      (message.SndUserName &&
                        typeof message.SndUserName.length === 'number') ||
                      $util.isString(message.SndUserName)
                    )
                  )
                    return 'SndUserName: buffer expected'
                if (
                  message.GasPrice != null &&
                  message.hasOwnProperty('GasPrice')
                )
                  if (
                    !$util.isInteger(message.GasPrice) &&
                    !(
                      message.GasPrice &&
                      $util.isInteger(message.GasPrice.low) &&
                      $util.isInteger(message.GasPrice.high)
                    )
                  )
                    return 'GasPrice: integer|Long expected'
                if (
                  message.GasLimit != null &&
                  message.hasOwnProperty('GasLimit')
                )
                  if (
                    !$util.isInteger(message.GasLimit) &&
                    !(
                      message.GasLimit &&
                      $util.isInteger(message.GasLimit.low) &&
                      $util.isInteger(message.GasLimit.high)
                    )
                  )
                    return 'GasLimit: integer|Long expected'
                if (message.Data != null && message.hasOwnProperty('Data'))
                  if (
                    !(
                      (message.Data &&
                        typeof message.Data.length === 'number') ||
                      $util.isString(message.Data)
                    )
                  )
                    return 'Data: buffer expected'
                if (
                  message.ChainID != null &&
                  message.hasOwnProperty('ChainID')
                )
                  if (
                    !(
                      (message.ChainID &&
                        typeof message.ChainID.length === 'number') ||
                      $util.isString(message.ChainID)
                    )
                  )
                    return 'ChainID: buffer expected'
                if (
                  message.Version != null &&
                  message.hasOwnProperty('Version')
                )
                  if (!$util.isInteger(message.Version))
                    return 'Version: integer expected'
                if (
                  message.Signature != null &&
                  message.hasOwnProperty('Signature')
                )
                  if (
                    !(
                      (message.Signature &&
                        typeof message.Signature.length === 'number') ||
                      $util.isString(message.Signature)
                    )
                  )
                    return 'Signature: buffer expected'
                if (
                  message.Options != null &&
                  message.hasOwnProperty('Options')
                )
                  if (!$util.isInteger(message.Options))
                    return 'Options: integer expected'
                if (
                  message.GuardAddr != null &&
                  message.hasOwnProperty('GuardAddr')
                )
                  if (
                    !(
                      (message.GuardAddr &&
                        typeof message.GuardAddr.length === 'number') ||
                      $util.isString(message.GuardAddr)
                    )
                  )
                    return 'GuardAddr: buffer expected'
                if (
                  message.GuardSignature != null &&
                  message.hasOwnProperty('GuardSignature')
                )
                  if (
                    !(
                      (message.GuardSignature &&
                        typeof message.GuardSignature.length === 'number') ||
                      $util.isString(message.GuardSignature)
                    )
                  )
                    return 'GuardSignature: buffer expected'
                return null
              }
              /**
               * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof proto.Transaction
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {proto.Transaction} Transaction
               */
              Transaction.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Transaction) return object
                var message = new $root.proto.Transaction()
                if (object.Nonce != null)
                  if ($util.Long)
                    (message.Nonce = $util.Long.fromValue(
                      object.Nonce
                    )).unsigned = true
                  else if (typeof object.Nonce === 'string')
                    message.Nonce = parseInt(object.Nonce, 10)
                  else if (typeof object.Nonce === 'number')
                    message.Nonce = object.Nonce
                  else if (typeof object.Nonce === 'object')
                    message.Nonce = new $util.LongBits(
                      object.Nonce.low >>> 0,
                      object.Nonce.high >>> 0
                    ).toNumber(true)
                if (object.Value != null)
                  if (typeof object.Value === 'string')
                    $util.base64.decode(
                      object.Value,
                      (message.Value = $util.newBuffer(
                        $util.base64.length(object.Value)
                      )),
                      0
                    )
                  else if (object.Value.length) message.Value = object.Value
                if (object.RcvAddr != null)
                  if (typeof object.RcvAddr === 'string')
                    $util.base64.decode(
                      object.RcvAddr,
                      (message.RcvAddr = $util.newBuffer(
                        $util.base64.length(object.RcvAddr)
                      )),
                      0
                    )
                  else if (object.RcvAddr.length)
                    message.RcvAddr = object.RcvAddr
                if (object.RcvUserName != null)
                  if (typeof object.RcvUserName === 'string')
                    $util.base64.decode(
                      object.RcvUserName,
                      (message.RcvUserName = $util.newBuffer(
                        $util.base64.length(object.RcvUserName)
                      )),
                      0
                    )
                  else if (object.RcvUserName.length)
                    message.RcvUserName = object.RcvUserName
                if (object.SndAddr != null)
                  if (typeof object.SndAddr === 'string')
                    $util.base64.decode(
                      object.SndAddr,
                      (message.SndAddr = $util.newBuffer(
                        $util.base64.length(object.SndAddr)
                      )),
                      0
                    )
                  else if (object.SndAddr.length)
                    message.SndAddr = object.SndAddr
                if (object.SndUserName != null)
                  if (typeof object.SndUserName === 'string')
                    $util.base64.decode(
                      object.SndUserName,
                      (message.SndUserName = $util.newBuffer(
                        $util.base64.length(object.SndUserName)
                      )),
                      0
                    )
                  else if (object.SndUserName.length)
                    message.SndUserName = object.SndUserName
                if (object.GasPrice != null)
                  if ($util.Long)
                    (message.GasPrice = $util.Long.fromValue(
                      object.GasPrice
                    )).unsigned = true
                  else if (typeof object.GasPrice === 'string')
                    message.GasPrice = parseInt(object.GasPrice, 10)
                  else if (typeof object.GasPrice === 'number')
                    message.GasPrice = object.GasPrice
                  else if (typeof object.GasPrice === 'object')
                    message.GasPrice = new $util.LongBits(
                      object.GasPrice.low >>> 0,
                      object.GasPrice.high >>> 0
                    ).toNumber(true)
                if (object.GasLimit != null)
                  if ($util.Long)
                    (message.GasLimit = $util.Long.fromValue(
                      object.GasLimit
                    )).unsigned = true
                  else if (typeof object.GasLimit === 'string')
                    message.GasLimit = parseInt(object.GasLimit, 10)
                  else if (typeof object.GasLimit === 'number')
                    message.GasLimit = object.GasLimit
                  else if (typeof object.GasLimit === 'object')
                    message.GasLimit = new $util.LongBits(
                      object.GasLimit.low >>> 0,
                      object.GasLimit.high >>> 0
                    ).toNumber(true)
                if (object.Data != null)
                  if (typeof object.Data === 'string')
                    $util.base64.decode(
                      object.Data,
                      (message.Data = $util.newBuffer(
                        $util.base64.length(object.Data)
                      )),
                      0
                    )
                  else if (object.Data.length) message.Data = object.Data
                if (object.ChainID != null)
                  if (typeof object.ChainID === 'string')
                    $util.base64.decode(
                      object.ChainID,
                      (message.ChainID = $util.newBuffer(
                        $util.base64.length(object.ChainID)
                      )),
                      0
                    )
                  else if (object.ChainID.length)
                    message.ChainID = object.ChainID
                if (object.Version != null)
                  message.Version = object.Version >>> 0
                if (object.Signature != null)
                  if (typeof object.Signature === 'string')
                    $util.base64.decode(
                      object.Signature,
                      (message.Signature = $util.newBuffer(
                        $util.base64.length(object.Signature)
                      )),
                      0
                    )
                  else if (object.Signature.length)
                    message.Signature = object.Signature
                if (object.Options != null)
                  message.Options = object.Options >>> 0
                if (object.GuardAddr != null)
                  if (typeof object.GuardAddr === 'string')
                    $util.base64.decode(
                      object.GuardAddr,
                      (message.GuardAddr = $util.newBuffer(
                        $util.base64.length(object.GuardAddr)
                      )),
                      0
                    )
                  else if (object.GuardAddr.length)
                    message.GuardAddr = object.GuardAddr
                if (object.GuardSignature != null)
                  if (typeof object.GuardSignature === 'string')
                    $util.base64.decode(
                      object.GuardSignature,
                      (message.GuardSignature = $util.newBuffer(
                        $util.base64.length(object.GuardSignature)
                      )),
                      0
                    )
                  else if (object.GuardSignature.length)
                    message.GuardSignature = object.GuardSignature
                return message
              }
              /**
               * Creates a plain object from a Transaction message. Also converts values to other types if specified.
               * @function toObject
               * @memberof proto.Transaction
               * @static
               * @param {proto.Transaction} message Transaction
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              Transaction.toObject = function toObject(message, options) {
                if (!options) options = {}
                var object = {}
                if (options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, true)
                    object.Nonce =
                      options.longs === String
                        ? long.toString()
                        : options.longs === Number
                        ? long.toNumber()
                        : long
                  } else object.Nonce = options.longs === String ? '0' : 0
                  if (options.bytes === String) object.Value = ''
                  else {
                    object.Value = []
                    if (options.bytes !== Array)
                      object.Value = $util.newBuffer(object.Value)
                  }
                  if (options.bytes === String) object.RcvAddr = ''
                  else {
                    object.RcvAddr = []
                    if (options.bytes !== Array)
                      object.RcvAddr = $util.newBuffer(object.RcvAddr)
                  }
                  if (options.bytes === String) object.RcvUserName = ''
                  else {
                    object.RcvUserName = []
                    if (options.bytes !== Array)
                      object.RcvUserName = $util.newBuffer(object.RcvUserName)
                  }
                  if (options.bytes === String) object.SndAddr = ''
                  else {
                    object.SndAddr = []
                    if (options.bytes !== Array)
                      object.SndAddr = $util.newBuffer(object.SndAddr)
                  }
                  if (options.bytes === String) object.SndUserName = ''
                  else {
                    object.SndUserName = []
                    if (options.bytes !== Array)
                      object.SndUserName = $util.newBuffer(object.SndUserName)
                  }
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, true)
                    object.GasPrice =
                      options.longs === String
                        ? long.toString()
                        : options.longs === Number
                        ? long.toNumber()
                        : long
                  } else object.GasPrice = options.longs === String ? '0' : 0
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, true)
                    object.GasLimit =
                      options.longs === String
                        ? long.toString()
                        : options.longs === Number
                        ? long.toNumber()
                        : long
                  } else object.GasLimit = options.longs === String ? '0' : 0
                  if (options.bytes === String) object.Data = ''
                  else {
                    object.Data = []
                    if (options.bytes !== Array)
                      object.Data = $util.newBuffer(object.Data)
                  }
                  if (options.bytes === String) object.ChainID = ''
                  else {
                    object.ChainID = []
                    if (options.bytes !== Array)
                      object.ChainID = $util.newBuffer(object.ChainID)
                  }
                  object.Version = 0
                  if (options.bytes === String) object.Signature = ''
                  else {
                    object.Signature = []
                    if (options.bytes !== Array)
                      object.Signature = $util.newBuffer(object.Signature)
                  }
                  object.Options = 0
                  if (options.bytes === String) object.GuardAddr = ''
                  else {
                    object.GuardAddr = []
                    if (options.bytes !== Array)
                      object.GuardAddr = $util.newBuffer(object.GuardAddr)
                  }
                  if (options.bytes === String) object.GuardSignature = ''
                  else {
                    object.GuardSignature = []
                    if (options.bytes !== Array)
                      object.GuardSignature = $util.newBuffer(
                        object.GuardSignature
                      )
                  }
                }
                if (message.Nonce != null && message.hasOwnProperty('Nonce'))
                  if (typeof message.Nonce === 'number')
                    object.Nonce =
                      options.longs === String
                        ? String(message.Nonce)
                        : message.Nonce
                  else
                    object.Nonce =
                      options.longs === String
                        ? $util.Long.prototype.toString.call(message.Nonce)
                        : options.longs === Number
                        ? new $util.LongBits(
                            message.Nonce.low >>> 0,
                            message.Nonce.high >>> 0
                          ).toNumber(true)
                        : message.Nonce
                if (message.Value != null && message.hasOwnProperty('Value'))
                  object.Value =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.Value,
                          0,
                          message.Value.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.Value)
                      : message.Value
                if (
                  message.RcvAddr != null &&
                  message.hasOwnProperty('RcvAddr')
                )
                  object.RcvAddr =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.RcvAddr,
                          0,
                          message.RcvAddr.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.RcvAddr)
                      : message.RcvAddr
                if (
                  message.RcvUserName != null &&
                  message.hasOwnProperty('RcvUserName')
                )
                  object.RcvUserName =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.RcvUserName,
                          0,
                          message.RcvUserName.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.RcvUserName)
                      : message.RcvUserName
                if (
                  message.SndAddr != null &&
                  message.hasOwnProperty('SndAddr')
                )
                  object.SndAddr =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.SndAddr,
                          0,
                          message.SndAddr.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.SndAddr)
                      : message.SndAddr
                if (
                  message.SndUserName != null &&
                  message.hasOwnProperty('SndUserName')
                )
                  object.SndUserName =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.SndUserName,
                          0,
                          message.SndUserName.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.SndUserName)
                      : message.SndUserName
                if (
                  message.GasPrice != null &&
                  message.hasOwnProperty('GasPrice')
                )
                  if (typeof message.GasPrice === 'number')
                    object.GasPrice =
                      options.longs === String
                        ? String(message.GasPrice)
                        : message.GasPrice
                  else
                    object.GasPrice =
                      options.longs === String
                        ? $util.Long.prototype.toString.call(message.GasPrice)
                        : options.longs === Number
                        ? new $util.LongBits(
                            message.GasPrice.low >>> 0,
                            message.GasPrice.high >>> 0
                          ).toNumber(true)
                        : message.GasPrice
                if (
                  message.GasLimit != null &&
                  message.hasOwnProperty('GasLimit')
                )
                  if (typeof message.GasLimit === 'number')
                    object.GasLimit =
                      options.longs === String
                        ? String(message.GasLimit)
                        : message.GasLimit
                  else
                    object.GasLimit =
                      options.longs === String
                        ? $util.Long.prototype.toString.call(message.GasLimit)
                        : options.longs === Number
                        ? new $util.LongBits(
                            message.GasLimit.low >>> 0,
                            message.GasLimit.high >>> 0
                          ).toNumber(true)
                        : message.GasLimit
                if (message.Data != null && message.hasOwnProperty('Data'))
                  object.Data =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.Data,
                          0,
                          message.Data.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.Data)
                      : message.Data
                if (
                  message.ChainID != null &&
                  message.hasOwnProperty('ChainID')
                )
                  object.ChainID =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.ChainID,
                          0,
                          message.ChainID.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.ChainID)
                      : message.ChainID
                if (
                  message.Version != null &&
                  message.hasOwnProperty('Version')
                )
                  object.Version = message.Version
                if (
                  message.Signature != null &&
                  message.hasOwnProperty('Signature')
                )
                  object.Signature =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.Signature,
                          0,
                          message.Signature.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.Signature)
                      : message.Signature
                if (
                  message.Options != null &&
                  message.hasOwnProperty('Options')
                )
                  object.Options = message.Options
                if (
                  message.GuardAddr != null &&
                  message.hasOwnProperty('GuardAddr')
                )
                  object.GuardAddr =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.GuardAddr,
                          0,
                          message.GuardAddr.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.GuardAddr)
                      : message.GuardAddr
                if (
                  message.GuardSignature != null &&
                  message.hasOwnProperty('GuardSignature')
                )
                  object.GuardSignature =
                    options.bytes === String
                      ? $util.base64.encode(
                          message.GuardSignature,
                          0,
                          message.GuardSignature.length
                        )
                      : options.bytes === Array
                      ? Array.prototype.slice.call(message.GuardSignature)
                      : message.GuardSignature
                return object
              }
              /**
               * Converts this Transaction to JSON.
               * @function toJSON
               * @memberof proto.Transaction
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              Transaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(
                  this,
                  $protobuf.util.toJSONOptions
                )
              }
              return Transaction
            })()
            return proto
          })()
          module.exports = $root
        },
        { 'protobufjs/minimal': 46 },
      ],
      76: [
        function (require, module, exports) {
          'use strict'
          /**
           * @packageDocumentation
           * @module proto
           */
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __exportStar =
            (this && this.__exportStar) ||
            function (m, exports) {
              for (var p in m)
                if (
                  p !== 'default' &&
                  !Object.prototype.hasOwnProperty.call(exports, p)
                )
                  __createBinding(exports, m, p)
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          __exportStar(require('./serializer'), exports)
        },
        { './serializer': 77 },
      ],
      77: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      Object.defineProperty(o, k2, {
                        enumerable: true,
                        get: function () {
                          return m[k]
                        },
                      })
                    }
                  : function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      o[k2] = m[k]
                    })
              var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function (o, v) {
                      Object.defineProperty(o, 'default', {
                        enumerable: true,
                        value: v,
                      })
                    }
                  : function (o, v) {
                      o['default'] = v
                    })
              var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                  if (mod && mod.__esModule) return mod
                  var result = {}
                  if (mod != null)
                    for (var k in mod)
                      if (
                        k !== 'default' &&
                        Object.prototype.hasOwnProperty.call(mod, k)
                      )
                        __createBinding(result, mod, k)
                  __setModuleDefault(result, mod)
                  return result
                }
              var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule ? mod : { default: mod }
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.ProtoSerializer = void 0
              const bignumber_js_1 = __importDefault(require('bignumber.js'))
              const address_1 = require('../address')
              const constants_1 = require('../constants')
              const errors = __importStar(require('../errors'))
              const utils_1 = require('../smartcontracts/codec/utils')
              /**
 * Hides away the serialization complexity, for each type of object (e.g. transactions).
 
 * The implementation is non-generic, but practical: there's a pair of `serialize` / `deserialize` method for each type of object.
 */
              class ProtoSerializer {
                /**
                 * Serializes a Transaction object to a Buffer. Handles low-level conversion logic and field-mappings as well.
                 */
                serializeTransaction(transaction) {
                  const proto = require('./compiled').proto
                  const receiverPubkey = new address_1.Address(
                    transaction.getReceiver().bech32()
                  ).pubkey()
                  const senderPubkey = new address_1.Address(
                    transaction.getSender().bech32()
                  ).pubkey()
                  let protoTransaction = new proto.Transaction({
                    // mx-chain-go's serializer handles nonce == 0 differently, thus we treat 0 as "undefined".
                    Nonce: transaction.getNonce().valueOf()
                      ? transaction.getNonce().valueOf()
                      : undefined,
                    Value: this.serializeTransactionValue(
                      transaction.getValue()
                    ),
                    RcvAddr: receiverPubkey,
                    RcvUserName: transaction.getReceiverUsername()
                      ? Buffer.from(transaction.getReceiverUsername()).toString(
                          'base64'
                        )
                      : undefined,
                    SndAddr: senderPubkey,
                    SndUserName: transaction.getSenderUsername()
                      ? Buffer.from(transaction.getSenderUsername()).toString(
                          'base64'
                        )
                      : undefined,
                    GasPrice: transaction.getGasPrice().valueOf(),
                    GasLimit: transaction.getGasLimit().valueOf(),
                    Data:
                      transaction.getData().length() == 0
                        ? null
                        : transaction.getData().valueOf(),
                    ChainID: Buffer.from(transaction.getChainID().valueOf()),
                    Version: transaction.getVersion().valueOf(),
                    Signature: transaction.getSignature(),
                  })
                  if (
                    transaction.getOptions().valueOf() !==
                    constants_1.TRANSACTION_OPTIONS_DEFAULT
                  ) {
                    protoTransaction.Options = transaction
                      .getOptions()
                      .valueOf()
                  }
                  if (transaction.isGuardedTransaction()) {
                    const guardianAddress = transaction.getGuardian()
                    protoTransaction.GuardAddr = new address_1.Address(
                      guardianAddress.bech32()
                    ).pubkey()
                    protoTransaction.GuardSignature =
                      transaction.getGuardianSignature()
                  }
                  const encoded =
                    proto.Transaction.encode(protoTransaction).finish()
                  const buffer = Buffer.from(encoded)
                  return buffer
                }
                /**
                 * Custom serialization, compatible with mx-chain-go.
                 */
                serializeTransactionValue(transactionValue) {
                  let value = new bignumber_js_1.default(
                    transactionValue.toString()
                  )
                  if (value.isZero()) {
                    return Buffer.from([0, 0])
                  }
                  // Will retain the magnitude, as a buffer.
                  let buffer = utils_1.bigIntToBuffer(value)
                  // We prepend the "positive" sign marker, in order to be compatible with mx-chain-go's "sign & magnitude" proto-representation (a custom one).
                  buffer = Buffer.concat([Buffer.from([0x00]), buffer])
                  return buffer
                }
                deserializeTransaction(_buffer) {
                  // Not needed (yet).
                  throw new errors.ErrUnsupportedOperation(
                    'deserializeTransaction'
                  )
                }
              }
              exports.ProtoSerializer = ProtoSerializer
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../address': 62,
          '../constants': 65,
          '../errors': 66,
          '../smartcontracts/codec/utils': 107,
          './compiled': 75,
          'bignumber.js': 13,
          buffer: 18,
        },
      ],
      78: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.getJavascriptPrototypesInHierarchy = void 0
          function getJavascriptPrototypesInHierarchy(obj, filter) {
            let prototypes = []
            let prototype = Object.getPrototypeOf(obj)
            while (prototype && filter(prototype)) {
              prototypes.push(prototype)
              prototype = Object.getPrototypeOf(prototype)
            }
            return prototypes
          }
          exports.getJavascriptPrototypesInHierarchy =
            getJavascriptPrototypesInHierarchy
        },
        {},
      ],
      79: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule ? mod : { default: mod }
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.RelayedTransactionV1Builder = void 0
              const bignumber_js_1 = __importDefault(require('bignumber.js'))
              const address_1 = require('./address')
              const errors_1 = require('./errors')
              const transaction_1 = require('./transaction')
              const transactionPayload_1 = require('./transactionPayload')
              class RelayedTransactionV1Builder {
                /**
                 * Sets the inner transaction to be used. It has to be already signed.
                 *
                 * @param {Transaction} transaction The inner transaction to be used
                 */
                setInnerTransaction(transaction) {
                  this.innerTransaction = transaction
                  return this
                }
                /**
                 * Sets the network config to be used for building the relayed v1 transaction
                 *
                 * @param {INetworkConfig} netConfig The network configuration to be used
                 */
                setNetworkConfig(netConfig) {
                  this.netConfig = netConfig
                  return this
                }
                /**
                 * Sets the address of the relayer (the one that will actually pay the fee)
                 *
                 * @param relayerAddress
                 */
                setRelayerAddress(relayerAddress) {
                  this.relayerAddress = relayerAddress
                  return this
                }
                /**
                 * (optional) Sets the nonce of the relayer
                 *
                 * @param relayerNonce
                 */
                setRelayerNonce(relayerNonce) {
                  this.relayerNonce = relayerNonce
                  return this
                }
                /**
                 * (optional) Sets the version of the relayed transaction
                 *
                 * @param relayedTxVersion
                 */
                setRelayedTransactionVersion(relayedTxVersion) {
                  this.relayedTransactionVersion = relayedTxVersion
                  return this
                }
                /**
                 * (optional) Sets the options of the relayed transaction
                 *
                 * @param relayedTxOptions
                 */
                setRelayedTransactionOptions(relayedTxOptions) {
                  this.relayedTransactionOptions = relayedTxOptions
                  return this
                }
                /**
                 * (optional) Sets the guardian of the relayed transaction
                 *
                 * @param relayedTxGuardian
                 */
                setRelayedTransactionGuardian(relayedTxGuardian) {
                  this.relayedTransactionGuardian = relayedTxGuardian
                  return this
                }
                /**
                 * Tries to build the relayed v1 transaction based on the previously set fields
                 *
                 * @throws ErrInvalidRelayedV1BuilderArguments
                 * @return Transaction
                 */
                build() {
                  if (
                    !this.innerTransaction ||
                    !this.netConfig ||
                    !this.relayerAddress ||
                    !this.innerTransaction.getSignature()
                  ) {
                    throw new errors_1.ErrInvalidRelayedV1BuilderArguments()
                  }
                  const serializedTransaction = this.prepareInnerTransaction()
                  const data = `relayedTx@${Buffer.from(
                    serializedTransaction
                  ).toString('hex')}`
                  const payload = new transactionPayload_1.TransactionPayload(
                    data
                  )
                  const gasLimit =
                    this.netConfig.MinGasLimit +
                    this.netConfig.GasPerDataByte * payload.length() +
                    this.innerTransaction.getGasLimit().valueOf()
                  let relayedTransaction = new transaction_1.Transaction({
                    nonce: this.relayerNonce,
                    sender: this.relayerAddress,
                    receiver: this.innerTransaction.getSender(),
                    value: 0,
                    gasLimit: gasLimit,
                    data: payload,
                    chainID: this.netConfig.ChainID,
                    version: this.relayedTransactionVersion,
                    options: this.relayedTransactionOptions,
                    guardian: this.relayedTransactionGuardian,
                  })
                  if (this.relayerNonce) {
                    relayedTransaction.setNonce(this.relayerNonce)
                  }
                  return relayedTransaction
                }
                prepareInnerTransaction() {
                  if (!this.innerTransaction) {
                    return ''
                  }
                  const txObject = {
                    nonce: this.innerTransaction.getNonce().valueOf(),
                    sender: new address_1.Address(
                      this.innerTransaction.getSender().bech32()
                    )
                      .pubkey()
                      .toString('base64'),
                    receiver: new address_1.Address(
                      this.innerTransaction.getReceiver().bech32()
                    )
                      .pubkey()
                      .toString('base64'),
                    value: new bignumber_js_1.default(
                      this.innerTransaction.getValue().toString(),
                      10
                    ).toNumber(),
                    gasPrice: this.innerTransaction.getGasPrice().valueOf(),
                    gasLimit: this.innerTransaction.getGasLimit().valueOf(),
                    data: this.innerTransaction
                      .getData()
                      .valueOf()
                      .toString('base64'),
                    signature: this.innerTransaction
                      .getSignature()
                      .toString('base64'),
                    chainID: Buffer.from(
                      this.innerTransaction.getChainID().valueOf()
                    ).toString('base64'),
                    version: this.innerTransaction.getVersion().valueOf(),
                    options:
                      this.innerTransaction.getOptions().valueOf() == 0
                        ? undefined
                        : this.innerTransaction.getOptions().valueOf(),
                    guardian: this.innerTransaction.getGuardian().bech32()
                      ? new address_1.Address(
                          this.innerTransaction.getGuardian().bech32()
                        )
                          .pubkey()
                          .toString('base64')
                      : undefined,
                    guardianSignature: this.innerTransaction
                      .getGuardianSignature()
                      .toString('hex')
                      ? this.innerTransaction
                          .getGuardianSignature()
                          .toString('base64')
                      : undefined,
                    sndUserName: this.innerTransaction.getSenderUsername()
                      ? Buffer.from(
                          this.innerTransaction.getSenderUsername()
                        ).toString('base64')
                      : undefined,
                    rcvUserName: this.innerTransaction.getReceiverUsername()
                      ? Buffer.from(
                          this.innerTransaction.getReceiverUsername()
                        ).toString('base64')
                      : undefined,
                  }
                  return JSON.stringify(txObject)
                }
              }
              exports.RelayedTransactionV1Builder = RelayedTransactionV1Builder
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          './address': 62,
          './errors': 66,
          './transaction': 153,
          './transactionPayload': 154,
          'bignumber.js': 13,
          buffer: 18,
        },
      ],
      80: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.RelayedTransactionV2Builder = void 0
          const errors_1 = require('./errors')
          const smartcontracts_1 = require('./smartcontracts')
          const transaction_1 = require('./transaction')
          const transactionPayload_1 = require('./transactionPayload')
          class RelayedTransactionV2Builder {
            /**
             * Sets the inner transaction to be used. It has to be already signed and with gasLimit set to 0. These checks
             * are performed on the build() method
             *
             * @param {Transaction} transaction The inner transaction to be used
             */
            setInnerTransaction(transaction) {
              this.innerTransaction = transaction
              return this
            }
            /**
             * Sets the gas limit to be used for the SC Call inside the inner transaction
             *
             * @param {IGasLimit} gasLimit The gas limit to be used. The inner transaction needs to have the gas limit set to 0,
             * so this field will specify the gas to be used for the SC call of the inner transaction
             */
            setInnerTransactionGasLimit(gasLimit) {
              this.innerTransactionGasLimit = gasLimit
              return this
            }
            /**
             * Sets the network config to be used for building the relayed v2 transaction
             *
             * @param {INetworkConfig} netConfig The network configuration to be used
             */
            setNetworkConfig(netConfig) {
              this.netConfig = netConfig
              return this
            }
            /**
             * Sets the address of the relayer (the one that will actually pay the fee)
             *
             * @param relayerAddress
             */
            setRelayerAddress(relayerAddress) {
              this.relayerAddress = relayerAddress
              return this
            }
            /**
             * (optional) Sets the nonce of the relayer
             *
             * @param relayerNonce
             */
            setRelayerNonce(relayerNonce) {
              this.relayerNonce = relayerNonce
              return this
            }
            /**
             * Tries to build the relayed v2 transaction based on the previously set fields.
             * It returns a transaction that isn't signed
             *
             * @throws ErrInvalidRelayedV2BuilderArguments
             * @throws ErrGasLimitShouldBe0ForInnerTransaction
             * @return Transaction
             */
            build() {
              if (
                !this.innerTransaction ||
                !this.innerTransactionGasLimit ||
                !this.relayerAddress ||
                !this.netConfig ||
                !this.innerTransaction.getSignature()
              ) {
                throw new errors_1.ErrInvalidRelayedV2BuilderArguments()
              }
              if (this.innerTransaction.getGasLimit() != 0) {
                throw new errors_1.ErrGasLimitShouldBe0ForInnerTransaction()
              }
              const { argumentsString } =
                new smartcontracts_1.ArgSerializer().valuesToString([
                  new smartcontracts_1.AddressValue(
                    this.innerTransaction.getReceiver()
                  ),
                  new smartcontracts_1.U64Value(
                    this.innerTransaction.getNonce().valueOf()
                  ),
                  new smartcontracts_1.BytesValue(
                    this.innerTransaction.getData().valueOf()
                  ),
                  new smartcontracts_1.BytesValue(
                    this.innerTransaction.getSignature()
                  ),
                ])
              const data = `relayedTxV2@${argumentsString}`
              const payload = new transactionPayload_1.TransactionPayload(data)
              let relayedTransaction = new transaction_1.Transaction({
                sender: this.relayerAddress,
                receiver: this.innerTransaction.getSender(),
                value: 0,
                gasLimit:
                  this.innerTransactionGasLimit.valueOf() +
                  this.netConfig.MinGasLimit +
                  this.netConfig.GasPerDataByte * payload.length(),
                data: payload,
                chainID: this.netConfig.ChainID,
              })
              if (this.relayerNonce) {
                relayedTransaction.setNonce(this.relayerNonce)
              }
              return relayedTransaction
            }
          }
          exports.RelayedTransactionV2Builder = RelayedTransactionV2Builder
        },
        {
          './errors': 66,
          './smartcontracts': 109,
          './transaction': 153,
          './transactionPayload': 154,
        },
      ],
      81: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.SignableMessage = exports.MESSAGE_PREFIX = void 0
              const address_1 = require('./address')
              const signature_1 = require('./signature')
              const createKeccakHash = require('keccak')
              exports.MESSAGE_PREFIX = '\x17Elrond Signed Message:\n'
              class SignableMessage {
                constructor(init) {
                  this.message = Buffer.from([])
                  this.signature = Buffer.from([])
                  this.version = 1
                  this.signer = 'ErdJS'
                  this.address = new address_1.Address()
                  Object.assign(this, init)
                }
                serializeForSigning() {
                  const messageSize = Buffer.from(
                    this.message.length.toString()
                  )
                  const signableMessage = Buffer.concat([
                    messageSize,
                    this.message,
                  ])
                  let bytesToHash = Buffer.concat([
                    Buffer.from(exports.MESSAGE_PREFIX),
                    signableMessage,
                  ])
                  return createKeccakHash('keccak256')
                    .update(bytesToHash)
                    .digest()
                }
                serializeForSigningRaw() {
                  return Buffer.concat([this.getMessageSize(), this.message])
                }
                getSignature() {
                  return this.signature
                }
                applySignature(signature) {
                  this.signature =
                    signature_1.interpretSignatureAsBuffer(signature)
                }
                getMessageSize() {
                  const messageSize = Buffer.alloc(4)
                  messageSize.writeUInt32BE(this.message.length, 0)
                  return messageSize
                }
                toJSON() {
                  return {
                    address: this.address.bech32(),
                    message: '0x' + this.message.toString('hex'),
                    signature: '0x' + this.signature.toString('hex'),
                    version: this.version,
                    signer: this.signer,
                  }
                }
              }
              exports.SignableMessage = SignableMessage
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { './address': 62, './signature': 82, buffer: 18, keccak: 23 },
      ],
      82: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      Object.defineProperty(o, k2, {
                        enumerable: true,
                        get: function () {
                          return m[k]
                        },
                      })
                    }
                  : function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      o[k2] = m[k]
                    })
              var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function (o, v) {
                      Object.defineProperty(o, 'default', {
                        enumerable: true,
                        value: v,
                      })
                    }
                  : function (o, v) {
                      o['default'] = v
                    })
              var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                  if (mod && mod.__esModule) return mod
                  var result = {}
                  if (mod != null)
                    for (var k in mod)
                      if (
                        k !== 'default' &&
                        Object.prototype.hasOwnProperty.call(mod, k)
                      )
                        __createBinding(result, mod, k)
                  __setModuleDefault(result, mod)
                  return result
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.interpretSignatureAsBuffer = exports.Signature = void 0
              const errors = __importStar(require('./errors'))
              const SIGNATURE_LENGTH = 64
              /**
               * Signature, as an immutable object.
               */
              class Signature {
                constructor(value) {
                  this.valueHex = ''
                  if (!value) {
                    return
                  }
                  if (typeof value === 'string') {
                    return Signature.fromHex(value)
                  }
                  if (value instanceof Buffer) {
                    return Signature.fromBuffer(value)
                  }
                }
                static empty() {
                  return new Signature()
                }
                static fromHex(value) {
                  if (value.startsWith('0x')) {
                    value = value.slice(2)
                  }
                  if (!Signature.isValidHex(value)) {
                    throw new errors.ErrSignatureCannotCreate(value)
                  }
                  return Signature.fromValidHex(value)
                }
                static isValidHex(value) {
                  return Buffer.from(value, 'hex').length == SIGNATURE_LENGTH
                }
                static fromValidHex(value) {
                  let result = new Signature()
                  result.valueHex = value
                  return result
                }
                static fromBuffer(buffer) {
                  if (buffer.length != SIGNATURE_LENGTH) {
                    throw new errors.ErrSignatureCannotCreate(buffer)
                  }
                  return Signature.fromValidHex(buffer.toString('hex'))
                }
                hex() {
                  return this.valueHex
                }
              }
              exports.Signature = Signature
              function interpretSignatureAsBuffer(signature) {
                if (ArrayBuffer.isView(signature)) {
                  return Buffer.from(signature)
                } else if (signature.hex != null) {
                  return Buffer.from(signature.hex(), 'hex')
                }
                throw new Error(
                  `Object cannot be interpreted as a signature: ${signature}`
                )
              }
              exports.interpretSignatureAsBuffer = interpretSignatureAsBuffer
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { './errors': 66, buffer: 18 },
      ],
      83: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.ArgSerializer = void 0
              const constants_1 = require('../constants')
              const codec_1 = require('./codec')
              const typesystem_1 = require('./typesystem')
              const algebraic_1 = require('./typesystem/algebraic')
              const composite_1 = require('./typesystem/composite')
              const variadic_1 = require('./typesystem/variadic')
              // TODO: perhaps move default construction options to a factory (ArgSerializerFactory), instead of referencing them in the constructor
              // (postpone as much as possible, breaking change)
              const defaultArgSerializerOptions = {
                codec: new codec_1.BinaryCodec(),
              }
              class ArgSerializer {
                constructor(options) {
                  options = Object.assign(
                    Object.assign({}, defaultArgSerializerOptions),
                    options
                  )
                  this.codec = options.codec
                }
                /**
                 * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.
                 */
                stringToValues(joinedString, parameters) {
                  let buffers = this.stringToBuffers(joinedString)
                  let values = this.buffersToValues(buffers, parameters)
                  return values
                }
                /**
                 * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).
                 */
                stringToBuffers(joinedString) {
                  // We also keep the zero-length buffers (they could encode missing options, Option<T>).
                  return joinedString
                    .split(constants_1.ARGUMENTS_SEPARATOR)
                    .map((item) => Buffer.from(item, 'hex'))
                }
                /**
                 * Decodes a set of buffers into a set of typed values, given parameter definitions.
                 */
                buffersToValues(buffers, parameters) {
                  // TODO: Refactor, split (function is quite complex).
                  const self = this
                  buffers = buffers || []
                  let values = []
                  let bufferIndex = 0
                  let numBuffers = buffers.length
                  for (let i = 0; i < parameters.length; i++) {
                    let parameter = parameters[i]
                    let type = parameter.type
                    let value = readValue(type)
                    values.push(value)
                  }
                  // This is a recursive function.
                  function readValue(type) {
                    if (
                      type.hasExactClass(algebraic_1.OptionalType.ClassName)
                    ) {
                      const typedValue = readValue(type.getFirstTypeParameter())
                      return new algebraic_1.OptionalValue(type, typedValue)
                    }
                    if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {
                      return readVariadicValue(type)
                    }
                    if (
                      type.hasExactClass(composite_1.CompositeType.ClassName)
                    ) {
                      const typedValues = []
                      for (const typeParameter of type.getTypeParameters()) {
                        typedValues.push(readValue(typeParameter))
                      }
                      return new composite_1.CompositeValue(type, typedValues)
                    }
                    // Non-composite (singular), non-variadic (fixed) type.
                    // The only branching without a recursive call.
                    const typedValue = decodeNextBuffer(type)
                    return typedValue
                  }
                  function readVariadicValue(type) {
                    const variadicType = type
                    const typedValues = []
                    if (variadicType.isCounted) {
                      const count = readValue(new typesystem_1.U32Type())
                        .valueOf()
                        .toNumber()
                      for (let i = 0; i < count; i++) {
                        typedValues.push(
                          readValue(type.getFirstTypeParameter())
                        )
                      }
                    } else {
                      while (!hasReachedTheEnd()) {
                        typedValues.push(
                          readValue(type.getFirstTypeParameter())
                        )
                      }
                    }
                    return new variadic_1.VariadicValue(
                      variadicType,
                      typedValues
                    )
                  }
                  function decodeNextBuffer(type) {
                    if (hasReachedTheEnd()) {
                      return null
                    }
                    let buffer = buffers[bufferIndex++]
                    let decodedValue = self.codec.decodeTopLevel(buffer, type)
                    return decodedValue
                  }
                  function hasReachedTheEnd() {
                    return bufferIndex >= numBuffers
                  }
                  return values
                }
                /**
                 * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).
                 */
                valuesToString(values) {
                  let strings = this.valuesToStrings(values)
                  let argumentsString = strings.join(
                    constants_1.ARGUMENTS_SEPARATOR
                  )
                  let count = strings.length
                  return { argumentsString, count }
                }
                /**
                 * Serializes a set of typed values into a set of strings.
                 */
                valuesToStrings(values) {
                  let buffers = this.valuesToBuffers(values)
                  let strings = buffers.map((buffer) => buffer.toString('hex'))
                  return strings
                }
                /**
                 * Serializes a set of typed values into a set of strings buffers.
                 * Variadic types and composite types might result into none, one or more buffers.
                 */
                valuesToBuffers(values) {
                  // TODO: Refactor, split (function is quite complex).
                  const self = this
                  const buffers = []
                  for (const value of values) {
                    handleValue(value)
                  }
                  // This is a recursive function. It appends to the "buffers" variable.
                  function handleValue(value) {
                    if (
                      value.hasExactClass(algebraic_1.OptionalValue.ClassName)
                    ) {
                      const valueAsOptional = value
                      if (valueAsOptional.isSet()) {
                        handleValue(valueAsOptional.getTypedValue())
                      }
                      return
                    }
                    if (
                      value.hasExactClass(variadic_1.VariadicValue.ClassName)
                    ) {
                      handleVariadicValue(value)
                      return
                    }
                    if (
                      value.hasExactClass(composite_1.CompositeValue.ClassName)
                    ) {
                      const valueAsComposite = value
                      for (const item of valueAsComposite.getItems()) {
                        handleValue(item)
                      }
                      return
                    }
                    // Non-composite (singular), non-variadic (fixed) type.
                    // The only branching without a recursive call.
                    const buffer = self.codec.encodeTopLevel(value)
                    buffers.push(buffer)
                  }
                  function handleVariadicValue(value) {
                    const variadicType = value.getType()
                    if (variadicType.isCounted) {
                      const countValue = new typesystem_1.U32Value(
                        value.getItems().length
                      )
                      buffers.push(self.codec.encodeTopLevel(countValue))
                    }
                    for (const item of value.getItems()) {
                      handleValue(item)
                    }
                  }
                  return buffers
                }
              }
              exports.ArgSerializer = ArgSerializer
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../constants': 65,
          './codec': 97,
          './typesystem': 135,
          './typesystem/algebraic': 121,
          './typesystem/composite': 126,
          './typesystem/variadic': 146,
          buffer: 18,
        },
      ],
      84: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ArgumentErrorContext = void 0
          const errors_1 = require('../errors')
          class ArgumentErrorContext {
            constructor(endpointName, argumentIndex, parameterDefinition) {
              this.endpointName = endpointName
              this.argumentIndex = argumentIndex
              this.parameterDefinition = parameterDefinition
            }
            throwError(specificError) {
              throw new errors_1.ErrInvalidArgument(
                `Error when converting arguments for endpoint (endpoint name: ${this.endpointName}, argument index: ${this.argumentIndex}, name: ${this.parameterDefinition.name}, type: ${this.parameterDefinition.type})\nNested error: ${specificError}`
              )
            }
            convertError(native, typeName) {
              this.throwError(
                `Can't convert argument (argument: ${native}, type ${typeof native}), wanted type: ${typeName})`
              )
            }
            unhandledType(functionName, type) {
              this.throwError(
                `Unhandled type (function: ${functionName}, type: ${type})`
              )
            }
            guardSameLength(native, valueTypes) {
              native = native || []
              if (native.length != valueTypes.length) {
                this.throwError(
                  `Incorrect composite type length: have ${native.length}, expected ${valueTypes.length} (argument: ${native})`
                )
              }
            }
            guardHasField(native, fieldName) {
              native = native || {}
              if (!(fieldName in native)) {
                this.throwError(
                  `Struct argument does not contain a field named "${fieldName}" (argument: ${JSON.stringify(
                    native
                  )})`
                )
              }
            }
          }
          exports.ArgumentErrorContext = ArgumentErrorContext
        },
        { '../errors': 66 },
      ],
      85: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.Code = void 0
              const createHasher = require('blake2b')
              const CODE_HASH_LENGTH = 32
              /**
               * Bytecode of a Smart Contract, as an abstraction.
               */
              class Code {
                constructor(hex) {
                  this.hex = hex
                }
                /**
                 * Creates a Code object from a buffer (sequence of bytes).
                 */
                static fromBuffer(code) {
                  return new Code(code.toString('hex'))
                }
                /**
                 * Creates a Code object from a hex-encoded string.
                 */
                static fromHex(hex) {
                  return new Code(hex)
                }
                /**
                 * Returns the bytecode as a hex-encoded string.
                 */
                toString() {
                  return this.hex
                }
                valueOf() {
                  return Buffer.from(this.hex, 'hex')
                }
                computeHash() {
                  const hash = createHasher(CODE_HASH_LENGTH)
                    .update(this.valueOf())
                    .digest()
                  return Buffer.from(hash)
                }
              }
              exports.Code = Code
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { blake2b: 16, buffer: 18 },
      ],
      86: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.CodeMetadata = void 0
              /**
               * The metadata of a Smart Contract, as an abstraction.
               */
              class CodeMetadata {
                /**
                 * Creates a metadata object. By default, set the `upgradeable` attribute, and uset all others.
                 *
                 * @param upgradeable Whether the contract is upgradeable
                 * @param readable Whether other contracts can read this contract's data (without calling one of its pure functions)
                 * @param payable Whether the contract is payable
                 * @param payableBySc Whether the contract is payable by other smart contracts
                 */
                constructor(
                  upgradeable = true,
                  readable = false,
                  payable = false,
                  payableBySc = false
                ) {
                  this.upgradeable = upgradeable
                  this.readable = readable
                  this.payable = payable
                  this.payableBySc = payableBySc
                }
                /**
                 * Creates a metadata object from a buffer.
                 */
                static fromBuffer(buffer) {
                  if (buffer.length < 2) {
                    throw new Error('Buffer is too short.')
                  }
                  const byteZero = buffer[0]
                  const byteOne = buffer[1]
                  const upgradeable =
                    (byteZero & CodeMetadata.ByteZero.Upgradeable) !== 0
                  const readable =
                    (byteZero & CodeMetadata.ByteZero.Readable) !== 0
                  const payable = (byteOne & CodeMetadata.ByteOne.Payable) !== 0
                  const payableBySc =
                    (byteOne & CodeMetadata.ByteOne.PayableBySc) !== 0
                  return new CodeMetadata(
                    upgradeable,
                    readable,
                    payable,
                    payableBySc
                  )
                }
                /**
                 * Adjust the metadata (the `upgradeable` attribute), when preparing the deployment transaction.
                 */
                toggleUpgradeable(value) {
                  this.upgradeable = value
                }
                /**
                 * Adjust the metadata (the `readable` attribute), when preparing the deployment transaction.
                 */
                toggleReadable(value) {
                  this.readable = value
                }
                /**
                 * Adjust the metadata (the `payable` attribute), when preparing the deployment transaction.
                 */
                togglePayable(value) {
                  this.payable = value
                }
                /**
                 * Adjust the metadata (the `payableBySc` attribute), when preparing the deployment transaction.
                 */
                togglePayableBySc(value) {
                  this.payableBySc = value
                }
                /**
                 * Converts the metadata to the protocol-friendly representation.
                 */
                toBuffer() {
                  let byteZero = 0
                  let byteOne = 0
                  if (this.upgradeable) {
                    byteZero |= CodeMetadata.ByteZero.Upgradeable
                  }
                  if (this.readable) {
                    byteZero |= CodeMetadata.ByteZero.Readable
                  }
                  if (this.payable) {
                    byteOne |= CodeMetadata.ByteOne.Payable
                  }
                  if (this.payableBySc) {
                    byteOne |= CodeMetadata.ByteOne.PayableBySc
                  }
                  return Buffer.from([byteZero, byteOne])
                }
                /**
                 * Converts the metadata to a hex-encoded string.
                 */
                toString() {
                  return this.toBuffer().toString('hex')
                }
                /**
                 * Converts the metadata to a pretty, plain JavaScript object.
                 */
                toJSON() {
                  return {
                    upgradeable: this.upgradeable,
                    readable: this.readable,
                    payable: this.payable,
                    payableBySc: this.payableBySc,
                  }
                }
                equals(other) {
                  return (
                    this.upgradeable == other.upgradeable &&
                    this.readable == other.readable &&
                    this.payable == other.payable &&
                    this.payableBySc == other.payableBySc
                  )
                }
              }
              exports.CodeMetadata = CodeMetadata
              CodeMetadata.ByteZero = {
                Upgradeable: 1,
                Reserved2: 2,
                Readable: 4,
              }
              CodeMetadata.ByteOne = {
                Reserved1: 1,
                Payable: 2,
                PayableBySc: 4,
              }
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { buffer: 18 },
      ],
      87: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.AddressBinaryCodec = void 0
          const address_1 = require('../../address')
          const typesystem_1 = require('../typesystem')
          class AddressBinaryCodec {
            /**
             * Reads and decodes an AddressValue from a given buffer.
             *
             * @param buffer the input buffer
             */
            decodeNested(buffer) {
              // We don't check the size of the buffer, we just read 32 bytes.
              let slice = buffer.slice(0, 32)
              let value = new address_1.Address(slice)
              return [new typesystem_1.AddressValue(value), 32]
            }
            /**
             * Reads and decodes an AddressValue from a given buffer.
             *
             * @param buffer the input buffer
             */
            decodeTopLevel(buffer) {
              let [decoded, length] = this.decodeNested(buffer)
              return decoded
            }
            /**
             * Encodes an AddressValue to a buffer.
             */
            encodeNested(primitive) {
              return primitive.valueOf().pubkey()
            }
            /**
             * Encodes an AddressValue to a buffer.
             */
            encodeTopLevel(primitive) {
              return primitive.valueOf().pubkey()
            }
          }
          exports.AddressBinaryCodec = AddressBinaryCodec
        },
        { '../../address': 62, '../typesystem': 135 },
      ],
      88: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.ArrayVecBinaryCodec = void 0
              const typesystem_1 = require('../typesystem')
              class ArrayVecBinaryCodec {
                constructor(binaryCodec) {
                  this.binaryCodec = binaryCodec
                }
                decodeNested(buffer, type) {
                  let arrayLength = type.length
                  let typeParameter = type.getFirstTypeParameter()
                  let result = []
                  let totalLength = 0
                  for (let i = 0; i < arrayLength; i++) {
                    let [decoded, decodedLength] =
                      this.binaryCodec.decodeNested(buffer, typeParameter)
                    result.push(decoded)
                    totalLength += decodedLength
                    buffer = buffer.slice(decodedLength)
                  }
                  return [new typesystem_1.ArrayVec(type, result), totalLength]
                }
                decodeTopLevel(buffer, type) {
                  let [result, _] = this.decodeNested(buffer, type)
                  return result
                }
                encodeNested(array) {
                  let itemsBuffers = []
                  for (const item of array.getItems()) {
                    let itemBuffer = this.binaryCodec.encodeNested(item)
                    itemsBuffers.push(itemBuffer)
                  }
                  return Buffer.concat(itemsBuffers)
                }
                encodeTopLevel(array) {
                  return this.encodeNested(array)
                }
              }
              exports.ArrayVecBinaryCodec = ArrayVecBinaryCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../typesystem': 135, buffer: 18 },
      ],
      89: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.BinaryCodecConstraints = exports.BinaryCodec = void 0
          const errors = __importStar(require('../../errors'))
          const typesystem_1 = require('../typesystem')
          const utils_1 = require('../../utils')
          const option_1 = require('./option')
          const primitive_1 = require('./primitive')
          const list_1 = require('./list')
          const struct_1 = require('./struct')
          const enum_1 = require('./enum')
          const tuple_1 = require('./tuple')
          const arrayVec_1 = require('./arrayVec')
          class BinaryCodec {
            constructor(constraints = null) {
              this.constraints = constraints || new BinaryCodecConstraints()
              this.optionCodec = new option_1.OptionValueBinaryCodec(this)
              this.listCodec = new list_1.ListBinaryCodec(this)
              this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this)
              this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this)
              this.structCodec = new struct_1.StructBinaryCodec(this)
              this.tupleCodec = new tuple_1.TupleBinaryCodec(this)
              this.enumCodec = new enum_1.EnumBinaryCodec(this)
            }
            decodeTopLevel(buffer, type) {
              this.constraints.checkBufferLength(buffer)
              let typedValue = typesystem_1.onTypeSelect(type, {
                onOption: () =>
                  this.optionCodec.decodeTopLevel(
                    buffer,
                    type.getFirstTypeParameter()
                  ),
                onList: () => this.listCodec.decodeTopLevel(buffer, type),
                onArray: () => this.arrayCodec.decodeTopLevel(buffer, type),
                onPrimitive: () =>
                  this.primitiveCodec.decodeTopLevel(buffer, type),
                onStruct: () => this.structCodec.decodeTopLevel(buffer, type),
                onTuple: () => this.tupleCodec.decodeTopLevel(buffer, type),
                onEnum: () => this.enumCodec.decodeTopLevel(buffer, type),
              })
              return typedValue
            }
            decodeNested(buffer, type) {
              this.constraints.checkBufferLength(buffer)
              let [typedResult, decodedLength] = typesystem_1.onTypeSelect(
                type,
                {
                  onOption: () =>
                    this.optionCodec.decodeNested(
                      buffer,
                      type.getFirstTypeParameter()
                    ),
                  onList: () => this.listCodec.decodeNested(buffer, type),
                  onArray: () => this.arrayCodec.decodeNested(buffer, type),
                  onPrimitive: () =>
                    this.primitiveCodec.decodeNested(buffer, type),
                  onStruct: () => this.structCodec.decodeNested(buffer, type),
                  onTuple: () => this.tupleCodec.decodeNested(buffer, type),
                  onEnum: () => this.enumCodec.decodeNested(buffer, type),
                }
              )
              return [typedResult, decodedLength]
            }
            encodeNested(typedValue) {
              utils_1.guardTrue(
                typedValue.getType().getCardinality().isSingular(),
                'singular cardinality, thus encodable type'
              )
              return typesystem_1.onTypedValueSelect(typedValue, {
                onPrimitive: () => this.primitiveCodec.encodeNested(typedValue),
                onOption: () => this.optionCodec.encodeNested(typedValue),
                onList: () => this.listCodec.encodeNested(typedValue),
                onArray: () => this.arrayCodec.encodeNested(typedValue),
                onStruct: () => this.structCodec.encodeNested(typedValue),
                onTuple: () => this.tupleCodec.encodeNested(typedValue),
                onEnum: () => this.enumCodec.encodeNested(typedValue),
              })
            }
            encodeTopLevel(typedValue) {
              utils_1.guardTrue(
                typedValue.getType().getCardinality().isSingular(),
                'singular cardinality, thus encodable type'
              )
              return typesystem_1.onTypedValueSelect(typedValue, {
                onPrimitive: () =>
                  this.primitiveCodec.encodeTopLevel(typedValue),
                onOption: () => this.optionCodec.encodeTopLevel(typedValue),
                onList: () => this.listCodec.encodeTopLevel(typedValue),
                onArray: () => this.arrayCodec.encodeTopLevel(typedValue),
                onStruct: () => this.structCodec.encodeTopLevel(typedValue),
                onTuple: () => this.tupleCodec.encodeTopLevel(typedValue),
                onEnum: () => this.enumCodec.encodeTopLevel(typedValue),
              })
            }
          }
          exports.BinaryCodec = BinaryCodec
          class BinaryCodecConstraints {
            constructor(init) {
              this.maxBufferLength =
                (init === null || init === void 0
                  ? void 0
                  : init.maxBufferLength) || 256000
              this.maxListLength =
                (init === null || init === void 0
                  ? void 0
                  : init.maxListLength) || 128000
            }
            checkBufferLength(buffer) {
              if (buffer.length > this.maxBufferLength) {
                throw new errors.ErrCodec(
                  `Buffer too large: ${buffer.length} > ${this.maxBufferLength}`
                )
              }
            }
            /**
             * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).
             */
            checkListLength(length) {
              if (length > this.maxListLength) {
                throw new errors.ErrCodec(
                  `List too large: ${length} > ${this.maxListLength}`
                )
              }
            }
          }
          exports.BinaryCodecConstraints = BinaryCodecConstraints
        },
        {
          '../../errors': 66,
          '../../utils': 158,
          '../typesystem': 135,
          './arrayVec': 88,
          './enum': 94,
          './list': 98,
          './option': 101,
          './primitive': 102,
          './struct': 104,
          './tuple': 106,
        },
      ],
      90: [
        function (require, module, exports) {
          'use strict'
          var __importDefault =
            (this && this.__importDefault) ||
            function (mod) {
              return mod && mod.__esModule ? mod : { default: mod }
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.decodeBigNumber =
            exports.decodeString =
            exports.decodeBool =
            exports.decodeUnsignedNumber =
              void 0
          const bignumber_js_1 = __importDefault(require('bignumber.js'))
          const typesystem_1 = require('../typesystem')
          const binary_1 = require('./binary')
          const Codec = new binary_1.BinaryCodec()
          function decodeUnsignedNumber(buffer) {
            let value = Codec.decodeTopLevel(
              buffer,
              new typesystem_1.BigUIntType()
            )
            let raw = Number(value.valueOf())
            return raw
          }
          exports.decodeUnsignedNumber = decodeUnsignedNumber
          function decodeBool(buffer) {
            let value = Codec.decodeTopLevel(
              buffer,
              new typesystem_1.BooleanType()
            )
            let raw = Boolean(value.valueOf())
            return raw
          }
          exports.decodeBool = decodeBool
          function decodeString(buffer) {
            let value = Codec.decodeTopLevel(
              buffer,
              new typesystem_1.BytesType()
            )
            let raw = String(value.valueOf())
            return raw
          }
          exports.decodeString = decodeString
          function decodeBigNumber(buffer) {
            let value = Codec.decodeTopLevel(
              buffer,
              new typesystem_1.BigUIntType()
            )
            let raw = new bignumber_js_1.default(value.valueOf())
            return raw
          }
          exports.decodeBigNumber = decodeBigNumber
        },
        { '../typesystem': 135, './binary': 89, 'bignumber.js': 13 },
      ],
      91: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      Object.defineProperty(o, k2, {
                        enumerable: true,
                        get: function () {
                          return m[k]
                        },
                      })
                    }
                  : function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      o[k2] = m[k]
                    })
              var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function (o, v) {
                      Object.defineProperty(o, 'default', {
                        enumerable: true,
                        value: v,
                      })
                    }
                  : function (o, v) {
                      o['default'] = v
                    })
              var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                  if (mod && mod.__esModule) return mod
                  var result = {}
                  if (mod != null)
                    for (var k in mod)
                      if (
                        k !== 'default' &&
                        Object.prototype.hasOwnProperty.call(mod, k)
                      )
                        __createBinding(result, mod, k)
                  __setModuleDefault(result, mod)
                  return result
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.BooleanBinaryCodec = void 0
              const errors = __importStar(require('../../errors'))
              const typesystem_1 = require('../typesystem')
              /**
               * Encodes and decodes "BooleanValue" objects.
               */
              class BooleanBinaryCodec {
                decodeNested(buffer) {
                  // We don't check the size of the buffer, we just read the first byte.
                  let byte = buffer.readUInt8(0)
                  return [
                    new typesystem_1.BooleanValue(
                      byte == BooleanBinaryCodec.TRUE
                    ),
                    1,
                  ]
                }
                decodeTopLevel(buffer) {
                  if (buffer.length > 1) {
                    throw new errors.ErrInvalidArgument(
                      'buffer should be of size <= 1'
                    )
                  }
                  let firstByte = buffer[0]
                  return new typesystem_1.BooleanValue(
                    firstByte == BooleanBinaryCodec.TRUE
                  )
                }
                encodeNested(primitive) {
                  if (primitive.isTrue()) {
                    return Buffer.from([BooleanBinaryCodec.TRUE])
                  }
                  return Buffer.from([BooleanBinaryCodec.FALSE])
                }
                encodeTopLevel(primitive) {
                  if (primitive.isTrue()) {
                    return Buffer.from([BooleanBinaryCodec.TRUE])
                  }
                  return Buffer.from([])
                }
              }
              exports.BooleanBinaryCodec = BooleanBinaryCodec
              BooleanBinaryCodec.TRUE = 0x01
              BooleanBinaryCodec.FALSE = 0x00
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../../errors': 66, '../typesystem': 135, buffer: 18 },
      ],
      92: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.BytesBinaryCodec = void 0
              const bytes_1 = require('../typesystem/bytes')
              const constants_1 = require('./constants')
              /**
               * Encodes and decodes "BytesValue" objects.
               */
              class BytesBinaryCodec {
                decodeNested(buffer) {
                  let length = buffer.readUInt32BE(0)
                  let payload = buffer.slice(
                    constants_1.SizeOfU32,
                    constants_1.SizeOfU32 + length
                  )
                  let result = new bytes_1.BytesValue(payload)
                  return [result, constants_1.SizeOfU32 + length]
                }
                decodeTopLevel(buffer) {
                  return new bytes_1.BytesValue(buffer)
                }
                encodeNested(bytes) {
                  let lengthBuffer = Buffer.alloc(constants_1.SizeOfU32)
                  lengthBuffer.writeUInt32BE(bytes.getLength())
                  let buffer = Buffer.concat([lengthBuffer, bytes.valueOf()])
                  return buffer
                }
                encodeTopLevel(bytes) {
                  return bytes.valueOf()
                }
              }
              exports.BytesBinaryCodec = BytesBinaryCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../typesystem/bytes': 123, './constants': 93, buffer: 18 },
      ],
      93: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.SizeOfU32 = void 0
          exports.SizeOfU32 = 4
        },
        {},
      ],
      94: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.EnumBinaryCodec = void 0
              const typesystem_1 = require('../typesystem')
              const fields_1 = require('./fields')
              class EnumBinaryCodec {
                constructor(binaryCodec) {
                  this.binaryCodec = binaryCodec
                  this.fieldsCodec = new fields_1.FieldsBinaryCodec(binaryCodec)
                }
                decodeTopLevel(buffer, type) {
                  // This handles enums without fields, with discriminant = 0, as well.
                  let [enumValue] = this.decodeNested(buffer, type)
                  return enumValue
                }
                decodeNested(buffer, type) {
                  let [discriminant, lengthOfDiscriminant] =
                    this.readDiscriminant(buffer)
                  buffer = buffer.slice(lengthOfDiscriminant)
                  let variant = type.getVariantByDiscriminant(discriminant)
                  let fieldDefinitions = variant.getFieldsDefinitions()
                  let [fields, lengthOfFields] = this.fieldsCodec.decodeNested(
                    buffer,
                    fieldDefinitions
                  )
                  let enumValue = new typesystem_1.EnumValue(
                    type,
                    variant,
                    fields
                  )
                  return [enumValue, lengthOfDiscriminant + lengthOfFields]
                }
                readDiscriminant(buffer) {
                  let [value, length] = this.binaryCodec.decodeNested(
                    buffer,
                    new typesystem_1.U8Type()
                  )
                  let discriminant = value.valueOf()
                  return [discriminant, length]
                }
                encodeNested(enumValue) {
                  let discriminant = new typesystem_1.U8Value(
                    enumValue.discriminant
                  )
                  let discriminantBuffer =
                    this.binaryCodec.encodeNested(discriminant)
                  let fields = enumValue.getFields()
                  let fieldsBuffer = this.fieldsCodec.encodeNested(fields)
                  return Buffer.concat([discriminantBuffer, fieldsBuffer])
                }
                encodeTopLevel(enumValue) {
                  let fields = enumValue.getFields()
                  let hasFields = fields.length > 0
                  let fieldsBuffer = this.fieldsCodec.encodeNested(fields)
                  let discriminant = new typesystem_1.U8Value(
                    enumValue.discriminant
                  )
                  let discriminantBuffer = hasFields
                    ? this.binaryCodec.encodeNested(discriminant)
                    : this.binaryCodec.encodeTopLevel(discriminant)
                  return Buffer.concat([discriminantBuffer, fieldsBuffer])
                }
              }
              exports.EnumBinaryCodec = EnumBinaryCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../typesystem': 135, './fields': 95, buffer: 18 },
      ],
      95: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.FieldsBinaryCodec = void 0
              const typesystem_1 = require('../typesystem')
              class FieldsBinaryCodec {
                constructor(binaryCodec) {
                  this.binaryCodec = binaryCodec
                }
                decodeNested(buffer, fieldDefinitions) {
                  let fields = []
                  let totalLength = 0
                  for (const fieldDefinition of fieldDefinitions) {
                    let [decoded, decodedLength] =
                      this.binaryCodec.decodeNested(
                        buffer,
                        fieldDefinition.type
                      )
                    buffer = buffer.slice(decodedLength)
                    totalLength += decodedLength
                    let field = new typesystem_1.Field(
                      decoded,
                      fieldDefinition.name
                    )
                    fields.push(field)
                  }
                  return [fields, totalLength]
                }
                encodeNested(fields) {
                  let buffers = []
                  for (const field of fields) {
                    let fieldBuffer = this.binaryCodec.encodeNested(field.value)
                    buffers.push(fieldBuffer)
                  }
                  return Buffer.concat(buffers)
                }
              }
              exports.FieldsBinaryCodec = FieldsBinaryCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../typesystem': 135, buffer: 18 },
      ],
      96: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.H256BinaryCodec = void 0
          const h256_1 = require('../typesystem/h256')
          class H256BinaryCodec {
            /**
             * Reads and decodes a H256Value from a given buffer.
             *
             * @param buffer the input buffer
             */
            decodeNested(buffer) {
              // We don't check the size of the buffer, we just read 32 bytes.
              let slice = buffer.slice(0, 32)
              return [new h256_1.H256Value(slice), 32]
            }
            /**
             * Reads and decodes a H256Value from a given buffer.
             *
             * @param buffer the input buffer
             */
            decodeTopLevel(buffer) {
              let [decoded, length] = this.decodeNested(buffer)
              return decoded
            }
            /**
             * Encodes a H256Value to a buffer.
             */
            encodeNested(primitive) {
              return primitive.valueOf()
            }
            /**
             * Encodes a H256Value to a buffer.
             */
            encodeTopLevel(primitive) {
              return primitive.valueOf()
            }
          }
          exports.H256BinaryCodec = H256BinaryCodec
        },
        { '../typesystem/h256': 134 },
      ],
      97: [
        function (require, module, exports) {
          'use strict'
          /**
           * @packageDocumentation
           * @module codec
           */
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __exportStar =
            (this && this.__exportStar) ||
            function (m, exports) {
              for (var p in m)
                if (
                  p !== 'default' &&
                  !Object.prototype.hasOwnProperty.call(exports, p)
                )
                  __createBinding(exports, m, p)
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          __exportStar(require('./binary'), exports)
          __exportStar(require('./binaryCodecUtils'), exports)
        },
        { './binary': 89, './binaryCodecUtils': 90 },
      ],
      98: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.ListBinaryCodec = void 0
              const typesystem_1 = require('../typesystem')
              const constants_1 = require('./constants')
              /**
               * Encodes and decodes "List" objects.
               */
              class ListBinaryCodec {
                constructor(binaryCodec) {
                  this.binaryCodec = binaryCodec
                }
                decodeNested(buffer, type) {
                  let typeParameter = type.getFirstTypeParameter()
                  let result = []
                  let numItems = buffer.readUInt32BE(0)
                  this.binaryCodec.constraints.checkListLength(numItems)
                  let originalBuffer = buffer
                  let offset = constants_1.SizeOfU32
                  buffer = originalBuffer.slice(offset)
                  for (let i = 0; i < numItems; i++) {
                    let [decoded, decodedLength] =
                      this.binaryCodec.decodeNested(buffer, typeParameter)
                    result.push(decoded)
                    offset += decodedLength
                    buffer = originalBuffer.slice(offset)
                  }
                  return [new typesystem_1.List(type, result), offset]
                }
                decodeTopLevel(buffer, type) {
                  let typeParameter = type.getFirstTypeParameter()
                  let result = []
                  let originalBuffer = buffer
                  let offset = 0
                  while (buffer.length > 0) {
                    let [decoded, decodedLength] =
                      this.binaryCodec.decodeNested(buffer, typeParameter)
                    result.push(decoded)
                    offset += decodedLength
                    buffer = originalBuffer.slice(offset)
                    this.binaryCodec.constraints.checkListLength(result.length)
                  }
                  return new typesystem_1.List(type, result)
                }
                encodeNested(list) {
                  this.binaryCodec.constraints.checkListLength(list.getLength())
                  let lengthBuffer = Buffer.alloc(constants_1.SizeOfU32)
                  lengthBuffer.writeUInt32BE(list.getLength())
                  let itemsBuffers = []
                  for (const item of list.getItems()) {
                    let itemBuffer = this.binaryCodec.encodeNested(item)
                    itemsBuffers.push(itemBuffer)
                  }
                  let buffer = Buffer.concat([lengthBuffer, ...itemsBuffers])
                  return buffer
                }
                encodeTopLevel(list) {
                  this.binaryCodec.constraints.checkListLength(list.getLength())
                  let itemsBuffers = []
                  for (const item of list.getItems()) {
                    let itemBuffer = this.binaryCodec.encodeNested(item)
                    itemsBuffers.push(itemBuffer)
                  }
                  let buffer = Buffer.concat(itemsBuffers)
                  return buffer
                }
              }
              exports.ListBinaryCodec = ListBinaryCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../typesystem': 135, './constants': 93, buffer: 18 },
      ],
      99: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.NothingCodec = void 0
              const typesystem_1 = require('../typesystem')
              class NothingCodec {
                decodeNested() {
                  return [new typesystem_1.NothingValue(), 0]
                }
                decodeTopLevel() {
                  return new typesystem_1.NothingValue()
                }
                encodeNested() {
                  return Buffer.from([])
                }
                encodeTopLevel() {
                  return Buffer.from([])
                }
              }
              exports.NothingCodec = NothingCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../typesystem': 135, buffer: 18 },
      ],
      100: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule ? mod : { default: mod }
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.NumericalBinaryCodec = void 0
              const bignumber_js_1 = __importDefault(require('bignumber.js'))
              const typesystem_1 = require('../typesystem')
              const constants_1 = require('./constants')
              const utils_1 = require('./utils')
              /**
               * Encodes and decodes "NumericalValue" objects.
               */
              class NumericalBinaryCodec {
                decodeNested(buffer, type) {
                  let offset = 0
                  let length = type.sizeInBytes
                  if (!length) {
                    // Size of type is not known: arbitrary-size big integer.
                    // Therefore, we must read the length from the header.
                    offset = constants_1.SizeOfU32
                    length = buffer.readUInt32BE(0)
                  }
                  let payload = buffer.slice(offset, offset + length)
                  let result = this.decodeTopLevel(payload, type)
                  let decodedLength = length + offset
                  return [result, decodedLength]
                }
                decodeTopLevel(buffer, type) {
                  let payload = utils_1.cloneBuffer(buffer)
                  let empty = buffer.length == 0
                  if (empty) {
                    return new typesystem_1.NumericalValue(
                      type,
                      new bignumber_js_1.default(0)
                    )
                  }
                  let isPositive = !type.withSign || utils_1.isMsbZero(payload)
                  if (isPositive) {
                    let value = utils_1.bufferToBigInt(payload)
                    return new typesystem_1.NumericalValue(type, value)
                  }
                  // Also see: https://github.com/multiversx/mx-components-big-int/blob/master/twos-complement/twos2bigint.go
                  utils_1.flipBufferBitsInPlace(payload)
                  let value = utils_1.bufferToBigInt(payload)
                  let negativeValue = value.multipliedBy(
                    new bignumber_js_1.default(-1)
                  )
                  let negativeValueMinusOne = negativeValue.minus(
                    new bignumber_js_1.default(1)
                  )
                  return new typesystem_1.NumericalValue(
                    type,
                    negativeValueMinusOne
                  )
                }
                encodeNested(primitive) {
                  if (primitive.sizeInBytes) {
                    return this.encodeNestedFixedSize(
                      primitive,
                      primitive.sizeInBytes
                    )
                  }
                  // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.
                  let buffer = this.encodeTopLevel(primitive)
                  let length = Buffer.alloc(constants_1.SizeOfU32)
                  length.writeUInt32BE(buffer.length)
                  return Buffer.concat([length, buffer])
                }
                encodeNestedFixedSize(primitive, size) {
                  if (primitive.value.isZero()) {
                    return Buffer.alloc(size, 0x00)
                  }
                  if (!primitive.withSign) {
                    const buffer = utils_1.bigIntToBuffer(primitive.value)
                    const paddingBytes = Buffer.alloc(
                      size - buffer.length,
                      0x00
                    )
                    return Buffer.concat([paddingBytes, buffer])
                  }
                  if (primitive.value.isPositive()) {
                    let buffer = utils_1.bigIntToBuffer(primitive.value)
                    // Fix ambiguity if any
                    if (utils_1.isMsbOne(buffer)) {
                      buffer = utils_1.prependByteToBuffer(buffer, 0x00)
                    }
                    const paddingBytes = Buffer.alloc(
                      size - buffer.length,
                      0x00
                    )
                    return Buffer.concat([paddingBytes, buffer])
                  }
                  // Negative:
                  // Also see: https://github.com/multiversx/mx-components-big-int/blob/master/twos-complement/bigint2twos.go
                  let valuePlusOne = primitive.value.plus(
                    new bignumber_js_1.default(1)
                  )
                  let buffer = utils_1.bigIntToBuffer(valuePlusOne)
                  utils_1.flipBufferBitsInPlace(buffer)
                  // Fix ambiguity if any
                  if (utils_1.isMsbZero(buffer)) {
                    buffer = utils_1.prependByteToBuffer(buffer, 0xff)
                  }
                  const paddingBytes = Buffer.alloc(size - buffer.length, 0xff)
                  return Buffer.concat([paddingBytes, buffer])
                }
                encodeTopLevel(primitive) {
                  let withSign = primitive.withSign
                  // Nothing or Zero:
                  if (primitive.value.isZero()) {
                    return Buffer.alloc(0)
                  }
                  // I don't care about the sign:
                  if (!withSign) {
                    return utils_1.bigIntToBuffer(primitive.value)
                  }
                  return this.encodePrimitive(primitive)
                }
                encodePrimitive(primitive) {
                  // Positive:
                  if (primitive.value.isPositive()) {
                    let buffer = utils_1.bigIntToBuffer(primitive.value)
                    // Fix ambiguity if any
                    if (utils_1.isMsbOne(buffer)) {
                      buffer = utils_1.prependByteToBuffer(buffer, 0x00)
                    }
                    return buffer
                  }
                  // Negative:
                  // Also see: https://github.com/multiversx/mx-components-big-int/blob/master/twos-complement/bigint2twos.go
                  let valuePlusOne = primitive.value.plus(
                    new bignumber_js_1.default(1)
                  )
                  let buffer = utils_1.bigIntToBuffer(valuePlusOne)
                  utils_1.flipBufferBitsInPlace(buffer)
                  // Fix ambiguity if any
                  if (utils_1.isMsbZero(buffer)) {
                    buffer = utils_1.prependByteToBuffer(buffer, 0xff)
                  }
                  return buffer
                }
              }
              exports.NumericalBinaryCodec = NumericalBinaryCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../typesystem': 135,
          './constants': 93,
          './utils': 107,
          'bignumber.js': 13,
          buffer: 18,
        },
      ],
      101: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      Object.defineProperty(o, k2, {
                        enumerable: true,
                        get: function () {
                          return m[k]
                        },
                      })
                    }
                  : function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      o[k2] = m[k]
                    })
              var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function (o, v) {
                      Object.defineProperty(o, 'default', {
                        enumerable: true,
                        value: v,
                      })
                    }
                  : function (o, v) {
                      o['default'] = v
                    })
              var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                  if (mod && mod.__esModule) return mod
                  var result = {}
                  if (mod != null)
                    for (var k in mod)
                      if (
                        k !== 'default' &&
                        Object.prototype.hasOwnProperty.call(mod, k)
                      )
                        __createBinding(result, mod, k)
                  __setModuleDefault(result, mod)
                  return result
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.OptionValueBinaryCodec = void 0
              const errors = __importStar(require('../../errors'))
              const typesystem_1 = require('../typesystem')
              /**
               * Encodes and decodes "OptionValue" objects
               */
              class OptionValueBinaryCodec {
                constructor(binaryCodec) {
                  this.binaryCodec = binaryCodec
                }
                decodeNested(buffer, type) {
                  if (buffer[0] == 0x00) {
                    return [typesystem_1.OptionValue.newMissingTyped(type), 1]
                  }
                  if (buffer[0] != 0x01) {
                    throw new errors.ErrCodec(
                      'invalid buffer for optional value'
                    )
                  }
                  let [decoded, decodedLength] = this.binaryCodec.decodeNested(
                    buffer.slice(1),
                    type
                  )
                  return [
                    typesystem_1.OptionValue.newProvided(decoded),
                    decodedLength + 1,
                  ]
                }
                decodeTopLevel(buffer, type) {
                  if (buffer.length == 0) {
                    return new typesystem_1.OptionValue(type)
                  }
                  if (buffer[0] != 0x01) {
                    throw new errors.ErrCodec(
                      'invalid buffer for optional value'
                    )
                  }
                  let [decoded, decodedLength] = this.binaryCodec.decodeNested(
                    buffer.slice(1),
                    type
                  )
                  return new typesystem_1.OptionValue(type, decoded)
                }
                encodeNested(optionValue) {
                  if (optionValue.isSet()) {
                    return Buffer.concat([
                      Buffer.from([1]),
                      this.binaryCodec.encodeNested(
                        optionValue.getTypedValue()
                      ),
                    ])
                  }
                  return Buffer.from([0])
                }
                encodeTopLevel(optionValue) {
                  if (optionValue.isSet()) {
                    return Buffer.concat([
                      Buffer.from([1]),
                      this.binaryCodec.encodeNested(
                        optionValue.getTypedValue()
                      ),
                    ])
                  }
                  return Buffer.from([])
                }
              }
              exports.OptionValueBinaryCodec = OptionValueBinaryCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../../errors': 66, '../typesystem': 135, buffer: 18 },
      ],
      102: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.PrimitiveBinaryCodec = void 0
          const typesystem_1 = require('../typesystem')
          const address_1 = require('./address')
          const boolean_1 = require('./boolean')
          const numerical_1 = require('./numerical')
          const h256_1 = require('./h256')
          const bytes_1 = require('./bytes')
          const tokenIdentifier_1 = require('./tokenIdentifier')
          const nothing_1 = require('./nothing')
          const string_1 = require('./string')
          class PrimitiveBinaryCodec {
            constructor(binaryCodec) {
              this.binaryCodec = binaryCodec
              this.booleanCodec = new boolean_1.BooleanBinaryCodec()
              this.numericalCodec = new numerical_1.NumericalBinaryCodec()
              this.addressCodec = new address_1.AddressBinaryCodec()
              this.h256Codec = new h256_1.H256BinaryCodec()
              this.bytesCodec = new bytes_1.BytesBinaryCodec()
              this.stringCodec = new string_1.StringBinaryCodec()
              this.tokenIdentifierCodec =
                new tokenIdentifier_1.TokenIdentifierCodec()
              this.nothingCodec = new nothing_1.NothingCodec()
            }
            decodeNested(buffer, type) {
              return typesystem_1.onPrimitiveTypeSelect(type, {
                onBoolean: () => this.booleanCodec.decodeNested(buffer),
                onNumerical: () =>
                  this.numericalCodec.decodeNested(buffer, type),
                onAddress: () => this.addressCodec.decodeNested(buffer),
                onBytes: () => this.bytesCodec.decodeNested(buffer),
                onString: () => this.stringCodec.decodeNested(buffer),
                onH256: () => this.h256Codec.decodeNested(buffer),
                onTokenIndetifier: () =>
                  this.tokenIdentifierCodec.decodeNested(buffer),
                onNothing: () => this.nothingCodec.decodeNested(),
              })
            }
            decodeTopLevel(buffer, type) {
              return typesystem_1.onPrimitiveTypeSelect(type, {
                onBoolean: () => this.booleanCodec.decodeTopLevel(buffer),
                onNumerical: () =>
                  this.numericalCodec.decodeTopLevel(buffer, type),
                onAddress: () => this.addressCodec.decodeTopLevel(buffer),
                onBytes: () => this.bytesCodec.decodeTopLevel(buffer),
                onString: () => this.stringCodec.decodeTopLevel(buffer),
                onH256: () => this.h256Codec.decodeTopLevel(buffer),
                onTokenIndetifier: () =>
                  this.tokenIdentifierCodec.decodeTopLevel(buffer),
                onNothing: () => this.nothingCodec.decodeTopLevel(),
              })
            }
            encodeNested(value) {
              return typesystem_1.onPrimitiveValueSelect(value, {
                onBoolean: () => this.booleanCodec.encodeNested(value),
                onNumerical: () => this.numericalCodec.encodeNested(value),
                onAddress: () => this.addressCodec.encodeNested(value),
                onBytes: () => this.bytesCodec.encodeNested(value),
                onString: () => this.stringCodec.encodeNested(value),
                onH256: () => this.h256Codec.encodeNested(value),
                onTypeIdentifier: () =>
                  this.tokenIdentifierCodec.encodeNested(value),
                onNothing: () => this.nothingCodec.encodeNested(),
              })
            }
            encodeTopLevel(value) {
              return typesystem_1.onPrimitiveValueSelect(value, {
                onBoolean: () => this.booleanCodec.encodeTopLevel(value),
                onNumerical: () => this.numericalCodec.encodeTopLevel(value),
                onAddress: () => this.addressCodec.encodeTopLevel(value),
                onBytes: () => this.bytesCodec.encodeTopLevel(value),
                onString: () => this.stringCodec.encodeTopLevel(value),
                onH256: () => this.h256Codec.encodeTopLevel(value),
                onTypeIdentifier: () =>
                  this.tokenIdentifierCodec.encodeTopLevel(value),
                onNothing: () => this.nothingCodec.encodeTopLevel(),
              })
            }
          }
          exports.PrimitiveBinaryCodec = PrimitiveBinaryCodec
        },
        {
          '../typesystem': 135,
          './address': 87,
          './boolean': 91,
          './bytes': 92,
          './h256': 96,
          './nothing': 99,
          './numerical': 100,
          './string': 103,
          './tokenIdentifier': 105,
        },
      ],
      103: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.StringBinaryCodec = void 0
              const typesystem_1 = require('../typesystem')
              const bytes_1 = require('../typesystem/bytes')
              const bytes_2 = require('./bytes')
              class StringBinaryCodec {
                constructor() {
                  this.bytesBinaryCodec = new bytes_2.BytesBinaryCodec()
                }
                decodeNested(buffer) {
                  let [decoded, length] =
                    this.bytesBinaryCodec.decodeNested(buffer)
                  let decodedAsString = new typesystem_1.StringValue(
                    decoded.valueOf().toString()
                  )
                  return [decodedAsString, length]
                }
                decodeTopLevel(buffer) {
                  return new typesystem_1.StringValue(buffer.toString())
                }
                encodeNested(value) {
                  let valueAsBytes = bytes_1.BytesValue.fromUTF8(
                    value.valueOf()
                  )
                  return this.bytesBinaryCodec.encodeNested(valueAsBytes)
                }
                encodeTopLevel(value) {
                  return Buffer.from(value.valueOf())
                }
              }
              exports.StringBinaryCodec = StringBinaryCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../typesystem': 135,
          '../typesystem/bytes': 123,
          './bytes': 92,
          buffer: 18,
        },
      ],
      104: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.StructBinaryCodec = void 0
          const typesystem_1 = require('../typesystem')
          const fields_1 = require('./fields')
          class StructBinaryCodec {
            constructor(binaryCodec) {
              this.fieldsCodec = new fields_1.FieldsBinaryCodec(binaryCodec)
            }
            decodeTopLevel(buffer, type) {
              let [decoded] = this.decodeNested(buffer, type)
              return decoded
            }
            decodeNested(buffer, type) {
              let fieldDefinitions = type.getFieldsDefinitions()
              let [fields, offset] = this.fieldsCodec.decodeNested(
                buffer,
                fieldDefinitions
              )
              let struct = new typesystem_1.Struct(type, fields)
              return [struct, offset]
            }
            encodeNested(struct) {
              let fields = struct.getFields()
              let buffer = this.fieldsCodec.encodeNested(fields)
              return buffer
            }
            encodeTopLevel(struct) {
              return this.encodeNested(struct)
            }
          }
          exports.StructBinaryCodec = StructBinaryCodec
        },
        { '../typesystem': 135, './fields': 95 },
      ],
      105: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.TokenIdentifierCodec = void 0
              const bytes_1 = require('../typesystem/bytes')
              const tokenIdentifier_1 = require('../typesystem/tokenIdentifier')
              const bytes_2 = require('./bytes')
              class TokenIdentifierCodec {
                constructor() {
                  this.bytesCodec = new bytes_2.BytesBinaryCodec()
                }
                decodeNested(buffer) {
                  let [bytesValue, length] =
                    this.bytesCodec.decodeNested(buffer)
                  return [
                    new tokenIdentifier_1.TokenIdentifierValue(
                      bytesValue.toString()
                    ),
                    length,
                  ]
                }
                decodeTopLevel(buffer) {
                  let bytesValue = this.bytesCodec.decodeTopLevel(buffer)
                  return new tokenIdentifier_1.TokenIdentifierValue(
                    bytesValue.toString()
                  )
                }
                encodeNested(tokenIdentifier) {
                  let bytesValue = bytes_1.BytesValue.fromUTF8(
                    tokenIdentifier.valueOf()
                  )
                  return this.bytesCodec.encodeNested(bytesValue)
                }
                encodeTopLevel(tokenIdentifier) {
                  return Buffer.from(tokenIdentifier.valueOf())
                }
              }
              exports.TokenIdentifierCodec = TokenIdentifierCodec
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../typesystem/bytes': 123,
          '../typesystem/tokenIdentifier': 141,
          './bytes': 92,
          buffer: 18,
        },
      ],
      106: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TupleBinaryCodec = void 0
          const struct_1 = require('./struct')
          class TupleBinaryCodec {
            constructor(binaryCodec) {
              this.structCodec = new struct_1.StructBinaryCodec(binaryCodec)
            }
            decodeTopLevel(buffer, type) {
              return this.structCodec.decodeTopLevel(buffer, type)
            }
            decodeNested(buffer, type) {
              return this.structCodec.decodeNested(buffer, type)
            }
            encodeNested(struct) {
              return this.structCodec.encodeNested(struct)
            }
            encodeTopLevel(struct) {
              return this.structCodec.encodeTopLevel(struct)
            }
          }
          exports.TupleBinaryCodec = TupleBinaryCodec
        },
        { './struct': 104 },
      ],
      107: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule ? mod : { default: mod }
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.prependByteToBuffer =
                exports.flipBufferBitsInPlace =
                exports.getHexMagnitudeOfBigInt =
                exports.bigIntToBuffer =
                exports.bufferToBigInt =
                exports.cloneBuffer =
                exports.isMsbZero =
                exports.isMsbOne =
                  void 0
              const bignumber_js_1 = __importDefault(require('bignumber.js'))
              const utils_codec_1 = require('../../utils.codec')
              /**
               * Returns whether the most significant bit of a given byte (within a buffer) is 1.
               * @param buffer the buffer to test
               * @param byteIndex the index of the byte to test
               */
              function isMsbOne(buffer, byteIndex = 0) {
                let byte = buffer[byteIndex]
                let bit = byte >> 7
                let isSet = bit == 1
                return isSet
              }
              exports.isMsbOne = isMsbOne
              /**
               * Returns whether the most significant bit of a given byte (within a buffer) is 0.
               * @param buffer the buffer to test
               * @param byteIndex the index of the byte to test
               */
              function isMsbZero(buffer, byteIndex = 0) {
                return !isMsbOne(buffer, byteIndex)
              }
              exports.isMsbZero = isMsbZero
              function cloneBuffer(buffer) {
                let clone = Buffer.alloc(buffer.length)
                buffer.copy(clone)
                return clone
              }
              exports.cloneBuffer = cloneBuffer
              function bufferToBigInt(buffer) {
                // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size Buffer to BigInt conversion.
                let hex = buffer.toString('hex')
                return new bignumber_js_1.default(`0x${hex}`, 16)
              }
              exports.bufferToBigInt = bufferToBigInt
              function bigIntToBuffer(value) {
                // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size BigInt to Buffer conversion.
                let hex = getHexMagnitudeOfBigInt(value)
                return Buffer.from(hex, 'hex')
              }
              exports.bigIntToBuffer = bigIntToBuffer
              function getHexMagnitudeOfBigInt(value) {
                value = new bignumber_js_1.default(value)
                if (!value) {
                  return ''
                }
                if (value.isNegative()) {
                  value = value.multipliedBy(new bignumber_js_1.default(-1))
                }
                return utils_codec_1.numberToPaddedHex(value)
              }
              exports.getHexMagnitudeOfBigInt = getHexMagnitudeOfBigInt
              function flipBufferBitsInPlace(buffer) {
                for (let i = 0; i < buffer.length; i++) {
                  buffer[i] = ~buffer[i]
                }
              }
              exports.flipBufferBitsInPlace = flipBufferBitsInPlace
              function prependByteToBuffer(buffer, byte) {
                return Buffer.concat([Buffer.from([byte]), buffer])
              }
              exports.prependByteToBuffer = prependByteToBuffer
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../../utils.codec': 157, 'bignumber.js': 13, buffer: 18 },
      ],
      108: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ContractFunction = void 0
          const errors = __importStar(require('../errors'))
          /**
           * A function of a Smart Contract, as an abstraction.
           */
          class ContractFunction {
            /**
             * Creates a ContractFunction object, given its name.
             *
             * @param name the name of the function
             */
            constructor(name) {
              this.name = name
              if (name == null) {
                throw new errors.ErrInvalidFunctionName()
              }
            }
            /**
             * Null-object pattern: creates an empty ContractFunction object.
             */
            static none() {
              return new ContractFunction('untitled')
            }
            /**
             * Returns the name of the function.
             */
            toString() {
              return this.name
            }
            valueOf() {
              return this.name
            }
          }
          exports.ContractFunction = ContractFunction
        },
        { '../errors': 66 },
      ],
      109: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __exportStar =
            (this && this.__exportStar) ||
            function (m, exports) {
              for (var p in m)
                if (
                  p !== 'default' &&
                  !Object.prototype.hasOwnProperty.call(exports, p)
                )
                  __createBinding(exports, m, p)
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          __exportStar(require('./argSerializer'), exports)
          __exportStar(require('./code'), exports)
          __exportStar(require('./codec'), exports)
          __exportStar(require('./codeMetadata'), exports)
          __exportStar(require('./function'), exports)
          __exportStar(require('./interaction'), exports)
          __exportStar(require('./interactionChecker'), exports)
          __exportStar(require('./interface'), exports)
          __exportStar(require('./nativeSerializer'), exports)
          __exportStar(require('./query'), exports)
          __exportStar(require('./resultsParser'), exports)
          __exportStar(require('./returnCode'), exports)
          __exportStar(require('./smartContract'), exports)
          __exportStar(require('./transactionPayloadBuilders'), exports)
          __exportStar(require('./typesystem'), exports)
        },
        {
          './argSerializer': 83,
          './code': 85,
          './codeMetadata': 86,
          './codec': 97,
          './function': 108,
          './interaction': 110,
          './interactionChecker': 111,
          './interface': 112,
          './nativeSerializer': 113,
          './query': 114,
          './resultsParser': 115,
          './returnCode': 116,
          './smartContract': 117,
          './transactionPayloadBuilders': 118,
          './typesystem': 135,
        },
      ],
      110: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.Interaction = void 0
          const address_1 = require('../address')
          const compatibility_1 = require('../compatibility')
          const constants_1 = require('../constants')
          const function_1 = require('./function')
          const interactionChecker_1 = require('./interactionChecker')
          const query_1 = require('./query')
          const typesystem_1 = require('./typesystem')
          /**
           * Interactions can be seen as mutable transaction & query builders.
           *
           * Aside from building transactions and queries, the interactors are also responsible for interpreting
           * the execution outcome for the objects they've built.
           */
          class Interaction {
            constructor(contract, func, args) {
              this.nonce = 0
              this.value = '0'
              this.gasLimit = 0
              this.gasPrice = undefined
              this.chainID = ''
              this.querent = new address_1.Address()
              this.sender = new address_1.Address()
              this.isWithSingleESDTTransfer = false
              this.isWithSingleESDTNFTTransfer = false
              this.isWithMultiESDTNFTTransfer = false
              this.contract = contract
              this.function = func
              this.args = args
              this.tokenTransfers = new TokenTransfersWithinInteraction(
                [],
                this
              )
            }
            getContractAddress() {
              return this.contract.getAddress()
            }
            getFunction() {
              return this.function
            }
            getEndpoint() {
              return this.contract.getEndpoint(this.function)
            }
            getArguments() {
              return this.args
            }
            getValue() {
              return this.value
            }
            getTokenTransfers() {
              return this.tokenTransfers.getTransfers()
            }
            getGasLimit() {
              return this.gasLimit
            }
            getExplicitReceiver() {
              return this.explicitReceiver
            }
            buildTransaction() {
              compatibility_1.Compatibility.guardAddressIsSetAndNonZero(
                this.sender,
                "'sender' of interaction",
                'use interaction.withSender()'
              )
              let receiver = this.explicitReceiver || this.contract.getAddress()
              let func = this.function
              let args = this.args
              if (this.isWithSingleESDTTransfer) {
                func = new function_1.ContractFunction(
                  constants_1.ESDT_TRANSFER_FUNCTION_NAME
                )
                args = this.tokenTransfers.buildArgsForSingleESDTTransfer()
              } else if (this.isWithSingleESDTNFTTransfer) {
                // For NFT, SFT and MetaESDT, transaction.sender == transaction.receiver.
                receiver = this.sender
                func = new function_1.ContractFunction(
                  constants_1.ESDTNFT_TRANSFER_FUNCTION_NAME
                )
                args = this.tokenTransfers.buildArgsForSingleESDTNFTTransfer()
              } else if (this.isWithMultiESDTNFTTransfer) {
                // For NFT, SFT and MetaESDT, transaction.sender == transaction.receiver.
                receiver = this.sender
                func = new function_1.ContractFunction(
                  constants_1.MULTI_ESDTNFT_TRANSFER_FUNCTION_NAME
                )
                args = this.tokenTransfers.buildArgsForMultiESDTNFTTransfer()
              }
              let transaction = this.contract.call({
                func: func,
                // GasLimit will be set using "withGasLimit()".
                gasLimit: this.gasLimit,
                gasPrice: this.gasPrice,
                args: args,
                // Value will be set using "withValue()".
                value: this.value,
                receiver: receiver,
                chainID: this.chainID,
                caller: this.sender,
              })
              transaction.setNonce(this.nonce)
              return transaction
            }
            buildQuery() {
              return new query_1.Query({
                address: this.contract.getAddress(),
                func: this.function,
                args: this.args,
                // Value will be set using "withValue()".
                value: this.value,
                caller: this.querent,
              })
            }
            withValue(value) {
              this.value = value
              return this
            }
            withSingleESDTTransfer(transfer) {
              this.isWithSingleESDTTransfer = true
              this.tokenTransfers = new TokenTransfersWithinInteraction(
                [transfer],
                this
              )
              return this
            }
            withSingleESDTNFTTransfer(transfer, sender) {
              this.isWithSingleESDTNFTTransfer = true
              this.tokenTransfers = new TokenTransfersWithinInteraction(
                [transfer],
                this
              )
              if (sender) {
                this.sender = sender
              }
              return this
            }
            withMultiESDTNFTTransfer(transfers, sender) {
              this.isWithMultiESDTNFTTransfer = true
              this.tokenTransfers = new TokenTransfersWithinInteraction(
                transfers,
                this
              )
              if (sender) {
                this.sender = sender
              }
              return this
            }
            withGasLimit(gasLimit) {
              this.gasLimit = gasLimit
              return this
            }
            withGasPrice(gasPrice) {
              this.gasPrice = gasPrice
              return this
            }
            withNonce(nonce) {
              this.nonce = nonce
              return this
            }
            useThenIncrementNonceOf(account) {
              return this.withNonce(account.getNonceThenIncrement())
            }
            withChainID(chainID) {
              this.chainID = chainID
              return this
            }
            withSender(sender) {
              this.sender = sender
              return this
            }
            /**
             * Sets the "caller" field on contract queries.
             */
            withQuerent(querent) {
              this.querent = querent
              return this
            }
            withExplicitReceiver(receiver) {
              this.explicitReceiver = receiver
              return this
            }
            /**
             * To perform custom checking, extend {@link Interaction} and override this method.
             */
            check() {
              new interactionChecker_1.InteractionChecker().checkInteraction(
                this,
                this.getEndpoint()
              )
              return this
            }
          }
          exports.Interaction = Interaction
          class TokenTransfersWithinInteraction {
            constructor(transfers, interaction) {
              this.transfers = transfers
              this.interaction = interaction
            }
            getTransfers() {
              return this.transfers
            }
            buildArgsForSingleESDTTransfer() {
              let singleTransfer = this.transfers[0]
              return [
                this.getTypedTokenIdentifier(singleTransfer),
                this.getTypedTokenQuantity(singleTransfer),
                this.getTypedInteractionFunction(),
                ...this.getInteractionArguments(),
              ]
            }
            buildArgsForSingleESDTNFTTransfer() {
              let singleTransfer = this.transfers[0]
              return [
                this.getTypedTokenIdentifier(singleTransfer),
                this.getTypedTokenNonce(singleTransfer),
                this.getTypedTokenQuantity(singleTransfer),
                this.getTypedTokensReceiver(),
                this.getTypedInteractionFunction(),
                ...this.getInteractionArguments(),
              ]
            }
            buildArgsForMultiESDTNFTTransfer() {
              let result = []
              result.push(this.getTypedTokensReceiver())
              result.push(this.getTypedNumberOfTransfers())
              for (const transfer of this.transfers) {
                result.push(this.getTypedTokenIdentifier(transfer))
                result.push(this.getTypedTokenNonce(transfer))
                result.push(this.getTypedTokenQuantity(transfer))
              }
              result.push(this.getTypedInteractionFunction())
              result.push(...this.getInteractionArguments())
              return result
            }
            getTypedNumberOfTransfers() {
              return new typesystem_1.U8Value(this.transfers.length)
            }
            getTypedTokenIdentifier(transfer) {
              // Important: for NFTs, this has to be the "collection" name, actually.
              // We will reconsider adding the field "collection" on "Token" upon merging "ApiProvider" and "ProxyProvider".
              return typesystem_1.BytesValue.fromUTF8(transfer.tokenIdentifier)
            }
            getTypedTokenNonce(transfer) {
              // The token nonce (creation nonce)
              return new typesystem_1.U64Value(transfer.nonce)
            }
            getTypedTokenQuantity(transfer) {
              // For NFTs, this will be 1.
              return new typesystem_1.BigUIntValue(transfer.amountAsBigInteger)
            }
            getTypedTokensReceiver() {
              // The actual receiver of the token(s): the contract
              return new typesystem_1.AddressValue(
                this.interaction.getContractAddress()
              )
            }
            getTypedInteractionFunction() {
              return typesystem_1.BytesValue.fromUTF8(
                this.interaction.getFunction().valueOf()
              )
            }
            getInteractionArguments() {
              return this.interaction.getArguments()
            }
          }
        },
        {
          '../address': 62,
          '../compatibility': 64,
          '../constants': 65,
          './function': 108,
          './interactionChecker': 111,
          './query': 114,
          './typesystem': 135,
        },
      ],
      111: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          var __importDefault =
            (this && this.__importDefault) ||
            function (mod) {
              return mod && mod.__esModule ? mod : { default: mod }
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.InteractionChecker = void 0
          const errors = __importStar(require('../errors'))
          const bignumber_js_1 = __importDefault(require('bignumber.js'))
          /**
           * An interaction checker that aims to be as strict as possible.
           * It is designed to catch programmer errors such as:
           *  - incorrect types of contract call arguments
           *  - errors related to calling "non-payable" functions with some value provided
           *  - gas estimation errors (not yet implemented)
           */
          class InteractionChecker {
            checkInteraction(interaction, definition) {
              this.checkPayable(interaction, definition)
              this.checkArguments(interaction, definition)
            }
            checkPayable(interaction, definition) {
              let hasValue = !new bignumber_js_1.default(
                interaction.getValue().toString()
              ).isZero()
              let isPayableInEGLD = definition.modifiers.isPayableInEGLD()
              if (hasValue && !isPayableInEGLD) {
                throw new errors.ErrContractInteraction(
                  'cannot send EGLD value to non-payable'
                )
              }
            }
            checkArguments(interaction, definition) {
              let formalArguments = definition.input
              let actualArguments = interaction.getArguments()
              let numFormalArguments = formalArguments.length
              let numActualArguments = actualArguments.length
              if (numFormalArguments != numActualArguments) {
                throw new errors.ErrContractInteraction(
                  `bad arguments, expected: ${numFormalArguments}, got: ${numActualArguments}`
                )
              }
              // TODO: discuss again, possibly redesign the handling of covariance / contravariance.
              for (let i = 0; i < numFormalArguments; i++) {
                let expectedType = formalArguments[i].type
                let argument = actualArguments[i]
                let actualType = argument.getType()
                // isAssignableFrom() is responsible to handle covariance and contravariance (depending on the class that overrides it).
                let ok = expectedType.isAssignableFrom(actualType)
                if (!ok) {
                  throw new errors.ErrContractInteraction(
                    `type mismatch at index ${i}, expected: ${expectedType}, got: ${actualType}`
                  )
                }
              }
            }
          }
          exports.InteractionChecker = InteractionChecker
        },
        { '../errors': 66, 'bignumber.js': 13 },
      ],
      112: [
        function (require, module, exports) {
          arguments[4][71][0].apply(exports, arguments)
        },
        { dup: 71 },
      ],
      113: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule ? mod : { default: mod }
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.NativeSerializer = void 0
              const bignumber_js_1 = __importDefault(require('bignumber.js'))
              const address_1 = require('../address')
              const errors_1 = require('../errors')
              const utils_codec_1 = require('../utils.codec')
              const argumentErrorContext_1 = require('./argumentErrorContext')
              const typesystem_1 = require('./typesystem')
              var NativeSerializer
              ;(function (NativeSerializer) {
                /**
                 * Interprets a set of native javascript values into a set of typed values, given parameter definitions.
                 */
                function nativeToTypedValues(args, endpoint) {
                  args = args || []
                  checkArgumentsCardinality(args, endpoint)
                  if (hasNonCountedVariadicParameter(endpoint)) {
                    args = repackNonCountedVariadicParameters(args, endpoint)
                  } else {
                    // Repacking makes sense (it's possible) only for regular, non-counted variadic parameters.
                  }
                  let parameters = endpoint.input
                  let values = []
                  for (let i = 0; i < parameters.length; i++) {
                    let parameter = parameters[i]
                    let errorContext =
                      new argumentErrorContext_1.ArgumentErrorContext(
                        endpoint.name,
                        i,
                        parameter
                      )
                    let value = convertToTypedValue(
                      args[i],
                      parameter.type,
                      errorContext
                    )
                    values.push(value)
                  }
                  return values
                }
                NativeSerializer.nativeToTypedValues = nativeToTypedValues
                function checkArgumentsCardinality(args, endpoint) {
                  // With respect to the notes of "repackNonCountedVariadicParameters", "getArgumentsCardinality" will not be needed anymore.
                  // Currently, it is used only for a arguments count check, which will become redundant.
                  const { min, max } = getArgumentsCardinality(endpoint.input)
                  if (!(min <= args.length && args.length <= max)) {
                    throw new errors_1.ErrInvalidArgument(
                      `Wrong number of arguments for endpoint ${endpoint.name}: expected between ${min} and ${max} arguments, have ${args.length}`
                    )
                  }
                }
                function hasNonCountedVariadicParameter(endpoint) {
                  const lastParameter =
                    endpoint.input[endpoint.input.length - 1]
                  return (
                    (lastParameter === null || lastParameter === void 0
                      ? void 0
                      : lastParameter.type) instanceof
                      typesystem_1.VariadicType && !lastParameter.type.isCounted
                  )
                }
                // In a future version of the type inference system, re-packing logic will be removed.
                // The client code will be responsible for passing the correctly packed arguments (variadic arguments explicitly packed as arrays).
                // For developers, calling `foo(["erd1", 42, [1, 2, 3]])` will be less ambiguous than `foo(["erd1", 42, 1, 2, 3])`.
                // Furthermore, multiple counted-variadic arguments cannot be expressed in the current variant.
                // E.g. now, it's unreasonable to decide that `foo([1, 2, 3, "a", "b", "c"])` calls `foo(counted-variadic<int>, counted-variadic<string>)`.
                function repackNonCountedVariadicParameters(args, endpoint) {
                  const lastEndpointParamIndex = endpoint.input.length - 1
                  const argAtIndex = args[lastEndpointParamIndex]
                  if (
                    argAtIndex === null || argAtIndex === void 0
                      ? void 0
                      : argAtIndex.belongsToTypesystem
                  ) {
                    const isVariadicValue = argAtIndex.hasClassOrSuperclass(
                      typesystem_1.VariadicValue.ClassName
                    )
                    if (!isVariadicValue) {
                      throw new errors_1.ErrInvalidArgument(
                        `Wrong argument type for endpoint ${
                          endpoint.name
                        }: typed value provided; expected variadic type, have ${argAtIndex.getClassName()}`
                      )
                    }
                    // Do not repack.
                  } else {
                    args[lastEndpointParamIndex] = args.slice(
                      lastEndpointParamIndex
                    )
                  }
                  return args
                }
                // A function may have one of the following formats:
                // f(arg1, arg2, optional<arg3>, optional<arg4>) returns { min: 2, max: 4, variadic: false }
                // f(arg1, variadic<bytes>) returns { min: 1, max: Infinity, variadic: true }
                // f(arg1, arg2, optional<arg3>, arg4, optional<arg5>, variadic<bytes>) returns { min: 2, max: Infinity, variadic: true }
                function getArgumentsCardinality(parameters) {
                  let reversed = [...parameters].reverse() // keep the original unchanged
                  let min = parameters.length
                  let max = parameters.length
                  let variadic = false
                  if (
                    reversed.length > 0 &&
                    reversed[0].type.getCardinality().isComposite()
                  ) {
                    max = Infinity
                    variadic = true
                  }
                  for (let parameter of reversed) {
                    if (parameter.type.getCardinality().isSingular()) {
                      break
                    }
                    min -= 1
                  }
                  return { min, max, variadic }
                }
                function convertToTypedValue(value, type, errorContext) {
                  if (value && value.belongsToTypesystem) {
                    // Value is already typed, no need to convert it.
                    return value
                  }
                  if (type instanceof typesystem_1.OptionType) {
                    return toOptionValue(value, type, errorContext)
                  }
                  if (type instanceof typesystem_1.OptionalType) {
                    return toOptionalValue(value, type, errorContext)
                  }
                  if (type instanceof typesystem_1.VariadicType) {
                    return toVariadicValue(value, type, errorContext)
                  }
                  if (type instanceof typesystem_1.CompositeType) {
                    return toCompositeValue(value, type, errorContext)
                  }
                  if (type instanceof typesystem_1.TupleType) {
                    return toTupleValue(value, type, errorContext)
                  }
                  if (type instanceof typesystem_1.StructType) {
                    return toStructValue(value, type, errorContext)
                  }
                  if (type instanceof typesystem_1.ListType) {
                    return toListValue(value, type, errorContext)
                  }
                  if (type instanceof typesystem_1.PrimitiveType) {
                    return toPrimitive(value, type, errorContext)
                  }
                  if (type instanceof typesystem_1.EnumType) {
                    return toEnumValue(value, type, errorContext)
                  }
                  errorContext.throwError(
                    `convertToTypedValue: unhandled type ${type}`
                  )
                }
                function toOptionValue(native, type, errorContext) {
                  if (native == null) {
                    return typesystem_1.OptionValue.newMissing()
                  }
                  let converted = convertToTypedValue(
                    native,
                    type.getFirstTypeParameter(),
                    errorContext
                  )
                  return typesystem_1.OptionValue.newProvided(converted)
                }
                function toOptionalValue(native, type, errorContext) {
                  if (native == null) {
                    return new typesystem_1.OptionalValue(type)
                  }
                  let converted = convertToTypedValue(
                    native,
                    type.getFirstTypeParameter(),
                    errorContext
                  )
                  return new typesystem_1.OptionalValue(type, converted)
                }
                function toVariadicValue(native, type, errorContext) {
                  if (type.isCounted) {
                    throw new errors_1.ErrInvalidArgument(
                      `Counted variadic arguments must be explicitly typed. E.g. use "VariadicValue.fromItemsCounted()" or "new VariadicValue()"`
                    )
                  }
                  if (native == null) {
                    native = []
                  }
                  if (native.map === undefined) {
                    errorContext.convertError(native, 'Variadic')
                  }
                  let converted = native.map(function (item) {
                    return convertToTypedValue(
                      item,
                      type.getFirstTypeParameter(),
                      errorContext
                    )
                  })
                  return new typesystem_1.VariadicValue(type, converted)
                }
                function toListValue(native, type, errorContext) {
                  if (native.map === undefined) {
                    errorContext.convertError(native, 'List')
                  }
                  let converted = native.map(function (item) {
                    return convertToTypedValue(
                      item,
                      type.getFirstTypeParameter(),
                      errorContext
                    )
                  })
                  return new typesystem_1.List(type, converted)
                }
                function toCompositeValue(native, type, errorContext) {
                  let typedValues = []
                  let typeParameters = type.getTypeParameters()
                  errorContext.guardSameLength(native, typeParameters)
                  for (let i = 0; i < typeParameters.length; i++) {
                    typedValues.push(
                      convertToTypedValue(
                        native[i],
                        typeParameters[i],
                        errorContext
                      )
                    )
                  }
                  return new typesystem_1.CompositeValue(type, typedValues)
                }
                function toTupleValue(native, type, errorContext) {
                  let typedValues = []
                  const fields = type.getFieldsDefinitions()
                  errorContext.guardSameLength(native, fields)
                  for (let i = 0; i < fields.length; i++) {
                    typedValues.push(
                      convertToTypedValue(
                        native[i],
                        fields[i].type,
                        errorContext
                      )
                    )
                  }
                  return typesystem_1.Tuple.fromItems(typedValues)
                }
                function toStructValue(native, type, errorContext) {
                  let structFieldValues = []
                  const fields = type.getFieldsDefinitions()
                  for (let i = 0; i < fields.length; i++) {
                    const fieldName = fields[i].name
                    errorContext.guardHasField(native, fieldName)
                    const fieldNativeValue = native[fieldName]
                    const fieldTypedValue = convertToTypedValue(
                      fieldNativeValue,
                      fields[i].type,
                      errorContext
                    )
                    structFieldValues.push(
                      new typesystem_1.Field(fieldTypedValue, fieldName)
                    )
                  }
                  return new typesystem_1.Struct(type, structFieldValues)
                }
                function toPrimitive(native, type, errorContext) {
                  if (type instanceof typesystem_1.NumericalType) {
                    let number = new bignumber_js_1.default(native)
                    return convertNumericalType(number, type, errorContext)
                  }
                  if (type instanceof typesystem_1.BytesType) {
                    return convertNativeToBytesValue(native, errorContext)
                  }
                  if (type instanceof typesystem_1.AddressType) {
                    return new typesystem_1.AddressValue(
                      convertNativeToAddress(native, errorContext)
                    )
                  }
                  if (type instanceof typesystem_1.BooleanType) {
                    return new typesystem_1.BooleanValue(native)
                  }
                  if (type instanceof typesystem_1.TokenIdentifierType) {
                    return new typesystem_1.TokenIdentifierValue(
                      convertNativeToString(native, errorContext)
                    )
                  }
                  errorContext.throwError(
                    `(function: toPrimitive) unsupported type ${type}`
                  )
                }
                function toEnumValue(native, type, errorContext) {
                  if (typeof native === 'number') {
                    return typesystem_1.EnumValue.fromDiscriminant(type, native)
                  }
                  if (typeof native === 'string') {
                    return typesystem_1.EnumValue.fromName(type, native)
                  }
                  if (typeof native === 'object') {
                    errorContext.guardHasField(native, 'name')
                    const variant = type.getVariantByName(native.name)
                    errorContext.guardHasField(native, 'fields')
                    const nativeFields = native.fields
                    const fieldValues = []
                    const fields = variant.getFieldsDefinitions()
                    for (let i = 0; i < fields.length; i++) {
                      const fieldName = fields[i].name
                      errorContext.guardHasField(nativeFields, fieldName)
                      const fieldNativeValue = nativeFields[fieldName]
                      const fieldTypedValue = convertToTypedValue(
                        fieldNativeValue,
                        fields[i].type,
                        errorContext
                      )
                      fieldValues.push(
                        new typesystem_1.Field(fieldTypedValue, fieldName)
                      )
                    }
                    return new typesystem_1.EnumValue(
                      type,
                      variant,
                      fieldValues
                    )
                  }
                  errorContext.throwError(
                    `(function: toEnumValue) unsupported native type ${typeof native}`
                  )
                }
                // TODO: move logic to typesystem/bytes.ts
                function convertNativeToBytesValue(native, errorContext) {
                  const innerValue = native.valueOf()
                  if (native === undefined) {
                    errorContext.convertError(native, 'BytesValue')
                  }
                  if (native instanceof Buffer) {
                    return new typesystem_1.BytesValue(native)
                  }
                  if (typeof native === 'string') {
                    return typesystem_1.BytesValue.fromUTF8(native)
                  }
                  if (innerValue instanceof Buffer) {
                    return new typesystem_1.BytesValue(innerValue)
                  }
                  if (typeof innerValue === 'number') {
                    return typesystem_1.BytesValue.fromHex(
                      utils_codec_1.numberToPaddedHex(innerValue)
                    )
                  }
                  errorContext.convertError(native, 'BytesValue')
                }
                // TODO: move logic to typesystem/string.ts
                function convertNativeToString(native, errorContext) {
                  if (native === undefined) {
                    errorContext.convertError(native, 'Buffer')
                  }
                  if (native instanceof Buffer) {
                    return native.toString()
                  }
                  if (typeof native === 'string') {
                    return native
                  }
                  errorContext.convertError(native, 'Buffer')
                }
                // TODO: move logic to typesystem/address.ts
                function convertNativeToAddress(native, errorContext) {
                  if (native.bech32) {
                    return native
                  }
                  if (native.getAddress) {
                    return native.getAddress()
                  }
                  switch (native.constructor) {
                    case Buffer:
                    case String:
                      return new address_1.Address(native)
                    default:
                      errorContext.convertError(native, 'Address')
                  }
                }
                NativeSerializer.convertNativeToAddress = convertNativeToAddress
                // TODO: move logic to typesystem/numerical.ts
                function convertNumericalType(number, type, errorContext) {
                  switch (type.constructor) {
                    case typesystem_1.U8Type:
                      return new typesystem_1.U8Value(number)
                    case typesystem_1.I8Type:
                      return new typesystem_1.I8Value(number)
                    case typesystem_1.U16Type:
                      return new typesystem_1.U16Value(number)
                    case typesystem_1.I16Type:
                      return new typesystem_1.I16Value(number)
                    case typesystem_1.U32Type:
                      return new typesystem_1.U32Value(number)
                    case typesystem_1.I32Type:
                      return new typesystem_1.I32Value(number)
                    case typesystem_1.U64Type:
                      return new typesystem_1.U64Value(number)
                    case typesystem_1.I64Type:
                      return new typesystem_1.I64Value(number)
                    case typesystem_1.BigUIntType:
                      return new typesystem_1.BigUIntValue(number)
                    case typesystem_1.BigIntType:
                      return new typesystem_1.BigIntValue(number)
                    default:
                      errorContext.unhandledType('convertNumericalType', type)
                  }
                }
              })(
                (NativeSerializer =
                  exports.NativeSerializer || (exports.NativeSerializer = {}))
              )
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../address': 62,
          '../errors': 66,
          '../utils.codec': 157,
          './argumentErrorContext': 84,
          './typesystem': 135,
          'bignumber.js': 13,
          buffer: 18,
        },
      ],
      114: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.Query = void 0
          const address_1 = require('../address')
          const argSerializer_1 = require('./argSerializer')
          class Query {
            constructor(obj) {
              this.caller = obj.caller || new address_1.Address()
              this.address = obj.address
              this.func = obj.func
              this.args = obj.args || []
              this.value = obj.value || 0
            }
            getEncodedArguments() {
              return new argSerializer_1.ArgSerializer().valuesToStrings(
                this.args
              )
            }
          }
          exports.Query = Query
        },
        { '../address': 62, './argSerializer': 83 },
      ],
      115: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.ResultsParser = void 0
              const transaction_decoder_1 = require('@multiversx/sdk-transaction-decoder/lib/src/transaction.decoder')
              const address_1 = require('../address')
              const errors_1 = require('../errors')
              const logger_1 = require('../logger')
              const argSerializer_1 = require('./argSerializer')
              const returnCode_1 = require('./returnCode')
              var WellKnownEvents
              ;(function (WellKnownEvents) {
                WellKnownEvents['OnTransactionCompleted'] = 'completedTxEvent'
                WellKnownEvents['OnSignalError'] = 'signalError'
                WellKnownEvents['OnWriteLog'] = 'writeLog'
              })(WellKnownEvents || (WellKnownEvents = {}))
              var WellKnownTopics
              ;(function (WellKnownTopics) {
                WellKnownTopics['TooMuchGas'] =
                  '@too much gas provided for processing'
              })(WellKnownTopics || (WellKnownTopics = {}))
              // TODO: perhaps move default construction options to a factory (ResultsParserFactory), instead of referencing them in the constructor
              // (postpone as much as possible, breaking change)
              const defaultResultsParserOptions = {
                argsSerializer: new argSerializer_1.ArgSerializer(),
              }
              /**
               * Parses contract query responses and smart contract results.
               * The parsing involves some heuristics, in order to handle slight inconsistencies (e.g. some SCRs are present on API, but missing on Gateway).
               */
              class ResultsParser {
                constructor(options) {
                  options = Object.assign(
                    Object.assign({}, defaultResultsParserOptions),
                    options
                  )
                  this.argsSerializer = options.argsSerializer
                }
                parseQueryResponse(queryResponse, endpoint) {
                  let parts = queryResponse.getReturnDataParts()
                  let values = this.argsSerializer.buffersToValues(
                    parts,
                    endpoint.output
                  )
                  let returnCode = new returnCode_1.ReturnCode(
                    queryResponse.returnCode.toString()
                  )
                  return {
                    returnCode: returnCode,
                    returnMessage: queryResponse.returnMessage,
                    values: values,
                    firstValue: values[0],
                    secondValue: values[1],
                    thirdValue: values[2],
                    lastValue: values[values.length - 1],
                  }
                }
                parseUntypedQueryResponse(queryResponse) {
                  let returnCode = new returnCode_1.ReturnCode(
                    queryResponse.returnCode.toString()
                  )
                  return {
                    returnCode: returnCode,
                    returnMessage: queryResponse.returnMessage,
                    values: queryResponse.getReturnDataParts(),
                  }
                }
                parseOutcome(transaction, endpoint) {
                  let untypedBundle = this.parseUntypedOutcome(transaction)
                  let values = this.argsSerializer.buffersToValues(
                    untypedBundle.values,
                    endpoint.output
                  )
                  return {
                    returnCode: untypedBundle.returnCode,
                    returnMessage: untypedBundle.returnMessage,
                    values: values,
                    firstValue: values[0],
                    secondValue: values[1],
                    thirdValue: values[2],
                    lastValue: values[values.length - 1],
                  }
                }
                parseUntypedOutcome(transaction) {
                  let bundle
                  let transactionMetadata =
                    this.parseTransactionMetadata(transaction)
                  bundle = this.createBundleOnSimpleMoveBalance(transaction)
                  if (bundle) {
                    logger_1.Logger.trace(
                      'parseUntypedOutcome(): on simple move balance'
                    )
                    return bundle
                  }
                  bundle = this.createBundleOnInvalidTransaction(transaction)
                  if (bundle) {
                    logger_1.Logger.trace(
                      'parseUntypedOutcome(): on invalid transaction'
                    )
                    return bundle
                  }
                  bundle = this.createBundleOnEasilyFoundResultWithReturnData(
                    transaction.contractResults
                  )
                  if (bundle) {
                    logger_1.Logger.trace(
                      'parseUntypedOutcome(): on easily found result with return data'
                    )
                    return bundle
                  }
                  bundle = this.createBundleOnSignalError(transaction.logs)
                  if (bundle) {
                    logger_1.Logger.trace(
                      'parseUntypedOutcome(): on signal error'
                    )
                    return bundle
                  }
                  bundle = this.createBundleOnTooMuchGasWarning(
                    transaction.logs
                  )
                  if (bundle) {
                    logger_1.Logger.trace(
                      "parseUntypedOutcome(): on 'too much gas' warning"
                    )
                    return bundle
                  }
                  bundle =
                    this.createBundleOnWriteLogWhereFirstTopicEqualsAddress(
                      transaction.logs,
                      transaction.sender
                    )
                  if (bundle) {
                    logger_1.Logger.trace(
                      'parseUntypedOutcome(): on writelog with topics[0] == tx.sender'
                    )
                    return bundle
                  }
                  bundle = this.createBundleWithCustomHeuristics(
                    transaction,
                    transactionMetadata
                  )
                  if (bundle) {
                    logger_1.Logger.trace(
                      'parseUntypedOutcome(): with custom heuristics'
                    )
                    return bundle
                  }
                  bundle = this.createBundleWithFallbackHeuristics(
                    transaction,
                    transactionMetadata
                  )
                  if (bundle) {
                    logger_1.Logger.trace(
                      'parseUntypedOutcome(): with fallback heuristics'
                    )
                    return bundle
                  }
                  throw new errors_1.ErrCannotParseContractResults(
                    `transaction ${transaction.hash.toString()}`
                  )
                }
                parseTransactionMetadata(transaction) {
                  return new transaction_decoder_1.TransactionDecoder().getTransactionMetadata(
                    {
                      sender: transaction.sender.bech32(),
                      receiver: transaction.receiver.bech32(),
                      data: transaction.data.toString('base64'),
                      value: transaction.value.toString(),
                    }
                  )
                }
                createBundleOnSimpleMoveBalance(transaction) {
                  let noResults = transaction.contractResults.items.length == 0
                  let noLogs = transaction.logs.events.length == 0
                  if (noResults && noLogs) {
                    return {
                      returnCode: returnCode_1.ReturnCode.None,
                      returnMessage: returnCode_1.ReturnCode.None.toString(),
                      values: [],
                    }
                  }
                  return null
                }
                createBundleOnInvalidTransaction(transaction) {
                  if (transaction.status.isInvalid()) {
                    if (transaction.receipt.data) {
                      return {
                        returnCode: returnCode_1.ReturnCode.OutOfFunds,
                        returnMessage: transaction.receipt.data,
                        values: [],
                      }
                    }
                    // If there's no receipt message, let other heuristics to handle the outcome (most probably, a log with "signalError" is emitted).
                  }
                  return null
                }
                createBundleOnEasilyFoundResultWithReturnData(results) {
                  let resultItemWithReturnData = results.items.find(
                    (item) =>
                      item.nonce.valueOf() != 0 && item.data.startsWith('@')
                  )
                  if (!resultItemWithReturnData) {
                    return null
                  }
                  let { returnCode, returnDataParts } =
                    this.sliceDataFieldInParts(resultItemWithReturnData.data)
                  let returnMessage =
                    resultItemWithReturnData.returnMessage ||
                    returnCode.toString()
                  return {
                    returnCode: returnCode,
                    returnMessage: returnMessage,
                    values: returnDataParts,
                  }
                }
                createBundleOnSignalError(logs) {
                  let eventSignalError = logs.findSingleOrNoneEvent(
                    WellKnownEvents.OnSignalError
                  )
                  if (!eventSignalError) {
                    return null
                  }
                  let { returnCode, returnDataParts } =
                    this.sliceDataFieldInParts(eventSignalError.data)
                  let lastTopic = eventSignalError.getLastTopic()
                  let returnMessage =
                    (lastTopic === null || lastTopic === void 0
                      ? void 0
                      : lastTopic.toString()) || returnCode.toString()
                  return {
                    returnCode: returnCode,
                    returnMessage: returnMessage,
                    values: returnDataParts,
                  }
                }
                createBundleOnTooMuchGasWarning(logs) {
                  let eventTooMuchGas = logs.findSingleOrNoneEvent(
                    WellKnownEvents.OnWriteLog,
                    (event) =>
                      event.findFirstOrNoneTopic((topic) =>
                        topic.toString().startsWith(WellKnownTopics.TooMuchGas)
                      ) != undefined
                  )
                  if (!eventTooMuchGas) {
                    return null
                  }
                  let { returnCode, returnDataParts } =
                    this.sliceDataFieldInParts(eventTooMuchGas.data)
                  let lastTopic = eventTooMuchGas.getLastTopic()
                  let returnMessage =
                    (lastTopic === null || lastTopic === void 0
                      ? void 0
                      : lastTopic.toString()) || returnCode.toString()
                  return {
                    returnCode: returnCode,
                    returnMessage: returnMessage,
                    values: returnDataParts,
                  }
                }
                createBundleOnWriteLogWhereFirstTopicEqualsAddress(
                  logs,
                  address
                ) {
                  let hexAddress = new address_1.Address(address.bech32()).hex()
                  let eventWriteLogWhereTopicIsSender =
                    logs.findSingleOrNoneEvent(
                      WellKnownEvents.OnWriteLog,
                      (event) =>
                        event.findFirstOrNoneTopic(
                          (topic) => topic.hex() == hexAddress
                        ) != undefined
                    )
                  if (!eventWriteLogWhereTopicIsSender) {
                    return null
                  }
                  let { returnCode, returnDataParts } =
                    this.sliceDataFieldInParts(
                      eventWriteLogWhereTopicIsSender.data
                    )
                  let returnMessage = returnCode.toString()
                  return {
                    returnCode: returnCode,
                    returnMessage: returnMessage,
                    values: returnDataParts,
                  }
                }
                /**
                 * Override this method (in a subclass of {@link ResultsParser}) if the basic heuristics of the parser are not sufficient.
                 */
                createBundleWithCustomHeuristics(
                  _transaction,
                  _transactionMetadata
                ) {
                  return null
                }
                createBundleWithFallbackHeuristics(
                  transaction,
                  transactionMetadata
                ) {
                  let contractAddress = new address_1.Address(
                    transactionMetadata.receiver
                  )
                  // Search the nested logs for matching events (writeLog):
                  for (const resultItem of transaction.contractResults.items) {
                    let writeLogWithReturnData =
                      resultItem.logs.findSingleOrNoneEvent(
                        WellKnownEvents.OnWriteLog,
                        (event) => {
                          var _a
                          let addressIsSender =
                            event.address.bech32() ==
                            transaction.sender.bech32()
                          let firstTopicIsContract =
                            ((_a = event.topics[0]) === null || _a === void 0
                              ? void 0
                              : _a.hex()) == contractAddress.hex()
                          return addressIsSender && firstTopicIsContract
                        }
                      )
                    if (writeLogWithReturnData) {
                      let { returnCode, returnDataParts } =
                        this.sliceDataFieldInParts(writeLogWithReturnData.data)
                      let returnMessage = returnCode.toString()
                      return {
                        returnCode: returnCode,
                        returnMessage: returnMessage,
                        values: returnDataParts,
                      }
                    }
                  }
                  return null
                }
                sliceDataFieldInParts(data) {
                  // By default, skip the first part, which is usually empty (e.g. "[empty]@6f6b")
                  let startingIndex = 1
                  // Before trying to parse the hex strings, cut the unwanted parts of the data field, in case of token transfers:
                  if (data.startsWith('ESDTTransfer')) {
                    // Skip "ESDTTransfer" (1), token identifier (2), amount (3)
                    startingIndex = 3
                  } else {
                    // TODO: Upon gathering more transaction samples, fix for other kinds of transfers, as well (future PR, as needed).
                  }
                  let parts = this.argsSerializer.stringToBuffers(data)
                  let returnCodePart = parts[startingIndex] || Buffer.from([])
                  let returnDataParts = parts.slice(startingIndex + 1)
                  if (returnCodePart.length == 0) {
                    throw new errors_1.ErrCannotParseContractResults(
                      'no return code'
                    )
                  }
                  let returnCode =
                    returnCode_1.ReturnCode.fromBuffer(returnCodePart)
                  return { returnCode, returnDataParts }
                }
                parseEvent(transactionEvent, eventDefinition) {
                  var _a, _b
                  const result = {}
                  // We skip the first topic, because that's the event identifier.
                  const topics = transactionEvent.topics
                    .map((topic) => Buffer.from(topic.valueOf()))
                    .slice(1)
                  // < Sirius.
                  const legacyData =
                    ((_a = transactionEvent.dataPayload) === null ||
                    _a === void 0
                      ? void 0
                      : _a.valueOf()) || Buffer.from([])
                  // >= Sirius.
                  const additionalData =
                    ((_b = transactionEvent.additionalData) === null ||
                    _b === void 0
                      ? void 0
                      : _b.map((data) => Buffer.from(data.valueOf()))) || []
                  // < Sirius.
                  if (additionalData.length == 0) {
                    if (legacyData.length > 0) {
                      additionalData.push(Buffer.from(legacyData))
                    }
                  }
                  // "Indexed" ABI "event.inputs" correspond to "event.topics[1:]":
                  const indexedInputs = eventDefinition.inputs.filter(
                    (input) => input.indexed
                  )
                  const decodedTopics = this.argsSerializer.buffersToValues(
                    topics,
                    indexedInputs
                  )
                  for (let i = 0; i < indexedInputs.length; i++) {
                    result[indexedInputs[i].name] = decodedTopics[i].valueOf()
                  }
                  // "Non-indexed" ABI "event.inputs" correspond to "event.data":
                  const nonIndexedInputs = eventDefinition.inputs.filter(
                    (input) => !input.indexed
                  )
                  const decodedDataParts = this.argsSerializer.buffersToValues(
                    additionalData,
                    nonIndexedInputs
                  )
                  for (let i = 0; i < nonIndexedInputs.length; i++) {
                    result[nonIndexedInputs[i].name] =
                      decodedDataParts[i].valueOf()
                  }
                  return result
                }
              }
              exports.ResultsParser = ResultsParser
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../address': 62,
          '../errors': 66,
          '../logger': 73,
          './argSerializer': 83,
          './returnCode': 116,
          '@multiversx/sdk-transaction-decoder/lib/src/transaction.decoder': 1,
          buffer: 18,
        },
      ],
      116: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ReturnCode = void 0
          /**
           * Also see: https://github.com/multiversx/mx-chain-vm-common-go/blob/master/returnCodes.go
           */
          class ReturnCode {
            constructor(text) {
              this.text = text
            }
            static fromBuffer(buffer) {
              let text = buffer.toString()
              return new ReturnCode(text)
            }
            toString() {
              return this.text
            }
            valueOf() {
              return this.text
            }
            equals(other) {
              if (!other) {
                return false
              }
              return this.text == other.text
            }
            isSuccess() {
              return this.equals(ReturnCode.Ok) || this.equals(ReturnCode.None)
            }
          }
          exports.ReturnCode = ReturnCode
          ReturnCode.None = new ReturnCode('')
          ReturnCode.Ok = new ReturnCode('ok')
          ReturnCode.FunctionNotFound = new ReturnCode('function not found')
          ReturnCode.FunctionWrongSignature = new ReturnCode(
            'wrong signature for function'
          )
          ReturnCode.ContractNotFound = new ReturnCode('contract not found')
          ReturnCode.UserError = new ReturnCode('user error')
          ReturnCode.OutOfGas = new ReturnCode('out of gas')
          ReturnCode.AccountCollision = new ReturnCode('account collision')
          ReturnCode.OutOfFunds = new ReturnCode('out of funds')
          ReturnCode.CallStackOverFlow = new ReturnCode('call stack overflow')
          ReturnCode.ContractInvalid = new ReturnCode('contract invalid')
          ReturnCode.ExecutionFailed = new ReturnCode('execution failed')
          ReturnCode.Unknown = new ReturnCode('unknown')
        },
        {},
      ],
      117: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule ? mod : { default: mod }
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.SmartContract = void 0
              const bignumber_js_1 = __importDefault(require('bignumber.js'))
              const address_1 = require('../address')
              const compatibility_1 = require('../compatibility')
              const errors_1 = require('../errors')
              const transaction_1 = require('../transaction')
              const utils_1 = require('../utils')
              const utils_2 = require('./codec/utils')
              const codeMetadata_1 = require('./codeMetadata')
              const function_1 = require('./function')
              const interaction_1 = require('./interaction')
              const nativeSerializer_1 = require('./nativeSerializer')
              const query_1 = require('./query')
              const transactionPayloadBuilders_1 = require('./transactionPayloadBuilders')
              const createKeccakHash = require('keccak')
              /**
               * An abstraction for deploying and interacting with Smart Contracts.
               */
              class SmartContract {
                /**
                 * Create a SmartContract object by providing its address on the Network.
                 */
                constructor(options = {}) {
                  this.address = new address_1.Address()
                  /**
                   * This object contains a function for each endpoint defined by the contract.
                   * (a bit similar to web3js's "contract.methods").
                   */
                  this.methodsExplicit = {}
                  /**
                   * This object contains a function for each endpoint defined by the contract.
                   * (a bit similar to web3js's "contract.methods").
                   *
                   * This is an alternative to {@link methodsExplicit}.
                   * Unlike {@link methodsExplicit}, automatic type inference (wrt. ABI) is applied when using {@link methods}.
                   */
                  this.methods = {}
                  this.address = options.address || new address_1.Address()
                  this.abi = options.abi
                  if (this.abi) {
                    this.setupMethods()
                  }
                }
                setupMethods() {
                  let contract = this
                  let abi = this.getAbi()
                  for (const definition of abi.getEndpoints()) {
                    let functionName = definition.name
                    // For each endpoint defined by the ABI, we attach a function to the "methods" and "methodsAuto" objects,
                    // a function that receives typed values as arguments
                    // and returns a prepared contract interaction.
                    this.methodsExplicit[functionName] = function (args) {
                      let func = new function_1.ContractFunction(functionName)
                      let interaction = new interaction_1.Interaction(
                        contract,
                        func,
                        args || []
                      )
                      return interaction
                    }
                    this.methods[functionName] = function (args) {
                      let func = new function_1.ContractFunction(functionName)
                      // Perform automatic type inference, wrt. the endpoint definition:
                      let typedArgs =
                        nativeSerializer_1.NativeSerializer.nativeToTypedValues(
                          args || [],
                          definition
                        )
                      let interaction = new interaction_1.Interaction(
                        contract,
                        func,
                        typedArgs || []
                      )
                      return interaction
                    }
                  }
                }
                /**
                 * Sets the address, as on Network.
                 */
                setAddress(address) {
                  this.address = address
                }
                /**
                 * Gets the address, as on Network.
                 */
                getAddress() {
                  return this.address
                }
                getAbi() {
                  utils_1.guardValueIsSet('abi', this.abi)
                  return this.abi
                }
                getEndpoint(name) {
                  return this.getAbi().getEndpoint(name)
                }
                /**
                 * Creates a {@link Transaction} for deploying the Smart Contract to the Network.
                 */
                deploy({
                  deployer,
                  code,
                  codeMetadata,
                  initArguments,
                  value,
                  gasLimit,
                  gasPrice,
                  chainID,
                }) {
                  compatibility_1.Compatibility.guardAddressIsSetAndNonZero(
                    deployer,
                    "'deployer' of SmartContract.deploy()",
                    'pass the actual address to deploy()'
                  )
                  codeMetadata =
                    codeMetadata || new codeMetadata_1.CodeMetadata()
                  initArguments = initArguments || []
                  value = value || 0
                  let payload =
                    new transactionPayloadBuilders_1.ContractDeployPayloadBuilder()
                      .setCode(code)
                      .setCodeMetadata(codeMetadata)
                      .setInitArgs(initArguments)
                      .build()
                  let transaction = new transaction_1.Transaction({
                    receiver: address_1.Address.Zero(),
                    sender: deployer,
                    value: value,
                    gasLimit: gasLimit,
                    gasPrice: gasPrice,
                    data: payload,
                    chainID: chainID,
                  })
                  return transaction
                }
                /**
                 * Creates a {@link Transaction} for upgrading the Smart Contract on the Network.
                 */
                upgrade({
                  caller,
                  code,
                  codeMetadata,
                  initArguments,
                  value,
                  gasLimit,
                  gasPrice,
                  chainID,
                }) {
                  compatibility_1.Compatibility.guardAddressIsSetAndNonZero(
                    caller,
                    "'caller' of SmartContract.upgrade()",
                    'pass the actual address to upgrade()'
                  )
                  this.ensureHasAddress()
                  codeMetadata =
                    codeMetadata || new codeMetadata_1.CodeMetadata()
                  initArguments = initArguments || []
                  value = value || 0
                  let payload =
                    new transactionPayloadBuilders_1.ContractUpgradePayloadBuilder()
                      .setCode(code)
                      .setCodeMetadata(codeMetadata)
                      .setInitArgs(initArguments)
                      .build()
                  let transaction = new transaction_1.Transaction({
                    sender: caller,
                    receiver: this.getAddress(),
                    value: value,
                    gasLimit: gasLimit,
                    gasPrice: gasPrice,
                    data: payload,
                    chainID: chainID,
                  })
                  return transaction
                }
                /**
                 * Creates a {@link Transaction} for calling (a function of) the Smart Contract.
                 */
                call({
                  func,
                  args,
                  value,
                  gasLimit,
                  receiver,
                  gasPrice,
                  chainID,
                  caller,
                }) {
                  compatibility_1.Compatibility.guardAddressIsSetAndNonZero(
                    caller,
                    "'caller' of SmartContract.call()",
                    'pass the actual address to call()'
                  )
                  this.ensureHasAddress()
                  args = args || []
                  value = value || 0
                  let payload =
                    new transactionPayloadBuilders_1.ContractCallPayloadBuilder()
                      .setFunction(func)
                      .setArgs(args)
                      .build()
                  let transaction = new transaction_1.Transaction({
                    sender: caller,
                    receiver: receiver ? receiver : this.getAddress(),
                    value: value,
                    gasLimit: gasLimit,
                    gasPrice: gasPrice,
                    data: payload,
                    chainID: chainID,
                  })
                  return transaction
                }
                createQuery({ func, args, value, caller }) {
                  this.ensureHasAddress()
                  return new query_1.Query({
                    address: this.getAddress(),
                    func: func,
                    args: args,
                    value: value,
                    caller: caller,
                  })
                }
                ensureHasAddress() {
                  if (!this.getAddress().bech32()) {
                    throw new errors_1.ErrContractHasNoAddress()
                  }
                }
                /**
                 * Computes the address of a Smart Contract.
                 * The address is computed deterministically, from the address of the owner and the nonce of the deployment transaction.
                 *
                 * @param owner The owner of the Smart Contract
                 * @param nonce The owner nonce used for the deployment transaction
                 */
                static computeAddress(owner, nonce) {
                  let initialPadding = Buffer.alloc(8, 0)
                  let ownerPubkey = new address_1.Address(
                    owner.bech32()
                  ).pubkey()
                  let shardSelector = ownerPubkey.slice(30)
                  let ownerNonceBytes = Buffer.alloc(8)
                  const bigNonce = new bignumber_js_1.default(
                    nonce.valueOf().toString(10)
                  )
                  const bigNonceBuffer = utils_2.bigIntToBuffer(bigNonce)
                  ownerNonceBytes.write(
                    bigNonceBuffer.reverse().toString('hex'),
                    'hex'
                  )
                  let bytesToHash = Buffer.concat([
                    ownerPubkey,
                    ownerNonceBytes,
                  ])
                  let hash = createKeccakHash('keccak256')
                    .update(bytesToHash)
                    .digest()
                  let vmTypeBytes = Buffer.from(
                    transactionPayloadBuilders_1.ArwenVirtualMachine,
                    'hex'
                  )
                  let addressBytes = Buffer.concat([
                    initialPadding,
                    vmTypeBytes,
                    hash.slice(10, 30),
                    shardSelector,
                  ])
                  let address = new address_1.Address(addressBytes)
                  return address
                }
              }
              exports.SmartContract = SmartContract
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../address': 62,
          '../compatibility': 64,
          '../errors': 66,
          '../transaction': 153,
          '../utils': 158,
          './codeMetadata': 86,
          './codec/utils': 107,
          './function': 108,
          './interaction': 110,
          './nativeSerializer': 113,
          './query': 114,
          './transactionPayloadBuilders': 118,
          'bignumber.js': 13,
          buffer: 18,
          keccak: 23,
        },
      ],
      118: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ContractCallPayloadBuilder =
            exports.ContractUpgradePayloadBuilder =
            exports.ContractDeployPayloadBuilder =
            exports.ArwenVirtualMachine =
              void 0
          const transactionPayload_1 = require('../transactionPayload')
          const utils_1 = require('../utils')
          const argSerializer_1 = require('./argSerializer')
          exports.ArwenVirtualMachine = '0500'
          /**
           * A builder for {@link TransactionPayload} objects, to be used for Smart Contract deployment transactions.
           */
          class ContractDeployPayloadBuilder {
            constructor() {
              this.code = null
              this.codeMetadata = ''
              this.arguments = []
            }
            /**
             * Sets the code of the Smart Contract.
             */
            setCode(code) {
              this.code = code
              return this
            }
            /**
             * Sets the code metadata of the Smart Contract.
             */
            setCodeMetadata(codeMetadata) {
              this.codeMetadata = codeMetadata
              return this
            }
            /**
             * Adds constructor (`init`) arguments.
             */
            addInitArg(arg) {
              this.arguments.push(arg)
              return this
            }
            /**
             * Sets constructor (`init`) arguments.
             */
            setInitArgs(args) {
              this.arguments = args
              return this
            }
            /**
             * Builds the {@link TransactionPayload}.
             */
            build() {
              utils_1.guardValueIsSet('code', this.code)
              let code = this.code.toString()
              let codeMetadata = this.codeMetadata.toString()
              let data = `${code}@${exports.ArwenVirtualMachine}@${codeMetadata}`
              data = appendArgumentsToString(data, this.arguments)
              return new transactionPayload_1.TransactionPayload(data)
            }
          }
          exports.ContractDeployPayloadBuilder = ContractDeployPayloadBuilder
          /**
           * A builder for {@link TransactionPayload} objects, to be used for Smart Contract upgrade transactions.
           */
          class ContractUpgradePayloadBuilder {
            constructor() {
              this.code = null
              this.codeMetadata = ''
              this.arguments = []
            }
            /**
             * Sets the code of the Smart Contract.
             */
            setCode(code) {
              this.code = code
              return this
            }
            /**
             * Sets the code metadata of the Smart Contract.
             */
            setCodeMetadata(codeMetadata) {
              this.codeMetadata = codeMetadata
              return this
            }
            /**
             * Adds upgrade (`init`) arguments.
             */
            addInitArg(arg) {
              this.arguments.push(arg)
              return this
            }
            /**
             * Sets upgrade (`init`) arguments.
             */
            setInitArgs(args) {
              this.arguments = args
              return this
            }
            /**
             * Builds the {@link TransactionPayload}.
             */
            build() {
              utils_1.guardValueIsSet('code', this.code)
              let code = this.code.toString()
              let codeMetadata = this.codeMetadata.toString()
              let data = `upgradeContract@${code}@${codeMetadata}`
              data = appendArgumentsToString(data, this.arguments)
              return new transactionPayload_1.TransactionPayload(data)
            }
          }
          exports.ContractUpgradePayloadBuilder = ContractUpgradePayloadBuilder
          /**
           * A builder for {@link TransactionPayload} objects, to be used for Smart Contract execution transactions.
           */
          class ContractCallPayloadBuilder {
            constructor() {
              this.contractFunction = null
              this.arguments = []
            }
            /**
             * Sets the function to be called (executed).
             */
            setFunction(contractFunction) {
              this.contractFunction = contractFunction
              return this
            }
            /**
             * Adds a function argument.
             */
            addArg(arg) {
              this.arguments.push(arg)
              return this
            }
            /**
             * Sets the function arguments.
             */
            setArgs(args) {
              this.arguments = args
              return this
            }
            /**
             * Builds the {@link TransactionPayload}.
             */
            build() {
              utils_1.guardValueIsSet('calledFunction', this.contractFunction)
              let data = this.contractFunction.toString()
              data = appendArgumentsToString(data, this.arguments)
              return new transactionPayload_1.TransactionPayload(data)
            }
          }
          exports.ContractCallPayloadBuilder = ContractCallPayloadBuilder
          function appendArgumentsToString(to, values) {
            let { argumentsString, count } =
              new argSerializer_1.ArgSerializer().valuesToString(values)
            if (count == 0) {
              return to
            }
            return `${to}@${argumentsString}`
          }
        },
        {
          '../transactionPayload': 154,
          '../utils': 158,
          './argSerializer': 83,
        },
      ],
      119: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.AbiRegistry = void 0
          const errors = __importStar(require('../../errors'))
          const utils_1 = require('../../utils')
          const endpoint_1 = require('./endpoint')
          const enum_1 = require('./enum')
          const event_1 = require('./event')
          const struct_1 = require('./struct')
          const typeMapper_1 = require('./typeMapper')
          const interfaceNamePlaceholder = '?'
          class AbiRegistry {
            constructor(options) {
              this.endpoints = []
              this.customTypes = []
              this.events = []
              this.name = options.name
              this.constructorDefinition = options.constructorDefinition
              this.endpoints = options.endpoints
              this.customTypes = options.customTypes
              this.events = options.events || []
            }
            static create(options) {
              const name = options.name || interfaceNamePlaceholder
              const constructor = options.constructor || {}
              const endpoints = options.endpoints || []
              const types = options.types || {}
              const events = options.events || []
              // Load arbitrary input parameters into properly-defined objects (e.g. EndpointDefinition and CustomType).
              const constructorDefinition =
                endpoint_1.EndpointDefinition.fromJSON(
                  Object.assign({ name: 'constructor' }, constructor)
                )
              const endpointDefinitions = endpoints.map((item) =>
                endpoint_1.EndpointDefinition.fromJSON(item)
              )
              const customTypes = []
              for (const customTypeName in types) {
                const typeDefinition = types[customTypeName]
                if (typeDefinition.type == 'struct') {
                  customTypes.push(
                    struct_1.StructType.fromJSON({
                      name: customTypeName,
                      fields: typeDefinition.fields,
                    })
                  )
                } else if (
                  typeDefinition.type == 'enum' ||
                  typeDefinition.type == 'explicit-enum'
                ) {
                  customTypes.push(
                    enum_1.EnumType.fromJSON({
                      name: customTypeName,
                      variants: typeDefinition.variants,
                    })
                  )
                } else {
                  throw new errors.ErrTypingSystem(
                    `Cannot handle custom type: ${customTypeName}`
                  )
                }
              }
              const eventDefinitions = events.map((item) =>
                event_1.EventDefinition.fromJSON(item)
              )
              const registry = new AbiRegistry({
                name: name,
                constructorDefinition: constructorDefinition,
                endpoints: endpointDefinitions,
                customTypes: customTypes,
                events: eventDefinitions,
              })
              const remappedRegistry = registry.remapToKnownTypes()
              return remappedRegistry
            }
            getCustomType(name) {
              const result = this.customTypes.find((e) => e.getName() == name)
              utils_1.guardValueIsSetWithMessage(
                `custom type [${name}] not found`,
                result
              )
              return result
            }
            getStruct(name) {
              const result = this.customTypes.find(
                (e) =>
                  e.getName() == name &&
                  e.hasExactClass(struct_1.StructType.ClassName)
              )
              utils_1.guardValueIsSetWithMessage(
                `struct [${name}] not found`,
                result
              )
              return result
            }
            getStructs(names) {
              return names.map((name) => this.getStruct(name))
            }
            getEnum(name) {
              const result = this.customTypes.find(
                (e) =>
                  e.getName() == name &&
                  e.hasExactClass(enum_1.EnumType.ClassName)
              )
              utils_1.guardValueIsSetWithMessage(
                `enum [${name}] not found`,
                result
              )
              return result
            }
            getEnums(names) {
              return names.map((name) => this.getEnum(name))
            }
            getEndpoints() {
              return this.endpoints
            }
            getEndpoint(name) {
              const result = this.endpoints.find((e) => e.name == name)
              utils_1.guardValueIsSetWithMessage(
                `endpoint [${name}] not found`,
                result
              )
              return result
            }
            getEvent(name) {
              const result = this.events.find((e) => e.identifier == name)
              utils_1.guardValueIsSetWithMessage(
                `event [${name}] not found`,
                result
              )
              return result
            }
            /**
             * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)
             * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).
             *
             * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).
             *
             * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).
             * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).
             * The result is an equivalent, more explicit ABI registry.
             */
            remapToKnownTypes() {
              const mapper = new typeMapper_1.TypeMapper([])
              const newCustomTypes = []
              // First, remap custom types (actually, under the hood, this will remap types of struct fields)
              for (const type of this.customTypes) {
                this.mapCustomTypeDepthFirst(
                  type,
                  this.customTypes,
                  mapper,
                  newCustomTypes
                )
              }
              if (this.customTypes.length != newCustomTypes.length) {
                throw new errors.ErrTypingSystem(
                  'Did not re-map all custom types'
                )
              }
              // Let's remap the constructor:
              const newConstructor = mapEndpoint(
                this.constructorDefinition,
                mapper
              )
              // Then, remap types of all endpoint parameters.
              // The mapper learned all necessary types in the previous step.
              const newEndpoints = []
              for (const endpoint of this.endpoints) {
                newEndpoints.push(mapEndpoint(endpoint, mapper))
              }
              const newEvents = this.events.map((event) =>
                mapEvent(event, mapper)
              )
              // Now return the new registry, with all types remapped to known types
              const newRegistry = new AbiRegistry({
                name: this.name,
                constructorDefinition: newConstructor,
                endpoints: newEndpoints,
                customTypes: newCustomTypes,
                events: newEvents,
              })
              return newRegistry
            }
            mapCustomTypeDepthFirst(
              typeToMap,
              allTypesToMap,
              mapper,
              mappedTypes
            ) {
              const hasBeenMapped =
                mappedTypes.findIndex(
                  (type) => type.getName() == typeToMap.getName()
                ) >= 0
              if (hasBeenMapped) {
                return
              }
              for (const typeName of typeToMap.getNamesOfDependencies()) {
                const dependencyType = allTypesToMap.find(
                  (type) => type.getName() == typeName
                )
                if (!dependencyType) {
                  // It's a type that we don't have to map (e.g. could be a primitive type).
                  continue
                }
                this.mapCustomTypeDepthFirst(
                  dependencyType,
                  allTypesToMap,
                  mapper,
                  mappedTypes
                )
              }
              const mappedType = mapper.mapType(typeToMap)
              mappedTypes.push(mappedType)
            }
          }
          exports.AbiRegistry = AbiRegistry
          function mapEndpoint(endpoint, mapper) {
            const newInput = endpoint.input.map(
              (e) =>
                new endpoint_1.EndpointParameterDefinition(
                  e.name,
                  e.description,
                  mapper.mapType(e.type)
                )
            )
            const newOutput = endpoint.output.map(
              (e) =>
                new endpoint_1.EndpointParameterDefinition(
                  e.name,
                  e.description,
                  mapper.mapType(e.type)
                )
            )
            return new endpoint_1.EndpointDefinition(
              endpoint.name,
              newInput,
              newOutput,
              endpoint.modifiers
            )
          }
          function mapEvent(event, mapper) {
            const newInputs = event.inputs.map(
              (e) =>
                new event_1.EventTopicDefinition({
                  name: e.name,
                  type: mapper.mapType(e.type),
                  indexed: e.indexed,
                })
            )
            return new event_1.EventDefinition(event.identifier, newInputs)
          }
        },
        {
          '../../errors': 66,
          '../../utils': 158,
          './endpoint': 127,
          './enum': 128,
          './event': 129,
          './struct': 140,
          './typeMapper': 144,
        },
      ],
      120: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.AddressValue = exports.AddressType = void 0
          const address_1 = require('../../address')
          const types_1 = require('./types')
          class AddressType extends types_1.PrimitiveType {
            constructor() {
              super('Address')
            }
            getClassName() {
              return AddressType.ClassName
            }
          }
          exports.AddressType = AddressType
          AddressType.ClassName = 'AddressType'
          /**
           * An address fed to or fetched from a Smart Contract contract, as an immutable abstraction.
           */
          class AddressValue extends types_1.PrimitiveValue {
            constructor(value) {
              super(new AddressType())
              this.value = new address_1.Address(value.bech32())
            }
            getClassName() {
              return AddressValue.ClassName
            }
            /**
             * Returns whether two objects have the same value.
             *
             * @param other another AddressValue
             */
            equals(other) {
              return this.value.equals(other.value)
            }
            valueOf() {
              return this.value
            }
          }
          exports.AddressValue = AddressValue
          AddressValue.ClassName = 'AddressValue'
        },
        { '../../address': 62, './types': 145 },
      ],
      121: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.OptionalValue = exports.OptionalType = void 0
          const utils_1 = require('../../utils')
          const types_1 = require('./types')
          /**
           * An optional is an algebraic type. It holds zero or one values.
           */
          class OptionalType extends types_1.Type {
            constructor(typeParameter) {
              super(
                'Optional',
                [typeParameter],
                types_1.TypeCardinality.variable(1)
              )
            }
            getClassName() {
              return OptionalType.ClassName
            }
            isAssignableFrom(type) {
              if (!type.hasExactClass(OptionalType.ClassName)) {
                return false
              }
              let invariantTypeParameters = this.getFirstTypeParameter().equals(
                type.getFirstTypeParameter()
              )
              let fakeCovarianceToNull = type
                .getFirstTypeParameter()
                .hasExactClass(types_1.NullType.ClassName)
              return invariantTypeParameters || fakeCovarianceToNull
            }
          }
          exports.OptionalType = OptionalType
          OptionalType.ClassName = 'OptionalType'
          class OptionalValue extends types_1.TypedValue {
            constructor(type, value = null) {
              super(type)
              // TODO: assert value is of type type.getFirstTypeParameter()
              this.value = value
            }
            getClassName() {
              return OptionalValue.ClassName
            }
            /**
             * Creates an OptionalValue, as not provided (missing).
             */
            static newMissing() {
              let type = new OptionalType(new types_1.NullType())
              return new OptionalValue(type)
            }
            isSet() {
              return this.value ? true : false
            }
            getTypedValue() {
              utils_1.guardValueIsSet('value', this.value)
              return this.value
            }
            valueOf() {
              return this.value ? this.value.valueOf() : null
            }
            equals(other) {
              var _a
              return (
                ((_a = this.value) === null || _a === void 0
                  ? void 0
                  : _a.equals(other.value)) || false
              )
            }
          }
          exports.OptionalValue = OptionalValue
          OptionalValue.ClassName = 'OptionalValue'
        },
        { '../../utils': 158, './types': 145 },
      ],
      122: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.BooleanValue = exports.BooleanType = void 0
          const types_1 = require('./types')
          class BooleanType extends types_1.PrimitiveType {
            constructor() {
              super('bool')
            }
            getClassName() {
              return BooleanType.ClassName
            }
          }
          exports.BooleanType = BooleanType
          BooleanType.ClassName = 'BooleanType'
          /**
           * A boolean value fed to or fetched from a Smart Contract contract, as an immutable abstraction.
           */
          class BooleanValue extends types_1.PrimitiveValue {
            constructor(value) {
              super(new BooleanType())
              this.value = value
            }
            getClassName() {
              return BooleanValue.ClassName
            }
            /**
             * Returns whether two objects have the same value.
             *
             * @param other another BooleanValue
             */
            equals(other) {
              return this.value === other.value
            }
            isTrue() {
              return this.value === true
            }
            isFalse() {
              return !this.isTrue()
            }
            valueOf() {
              return this.value
            }
          }
          exports.BooleanValue = BooleanValue
          BooleanValue.ClassName = 'BooleanValue'
        },
        { './types': 145 },
      ],
      123: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.BytesValue = exports.BytesType = void 0
              const types_1 = require('./types')
              class BytesType extends types_1.PrimitiveType {
                constructor() {
                  super('bytes')
                }
                getClassName() {
                  return BytesType.ClassName
                }
              }
              exports.BytesType = BytesType
              BytesType.ClassName = 'BytesType'
              class BytesValue extends types_1.PrimitiveValue {
                constructor(value) {
                  super(new BytesType())
                  this.value = value
                }
                getClassName() {
                  return BytesValue.ClassName
                }
                /**
                 * Creates a BytesValue from a utf-8 string.
                 */
                static fromUTF8(value) {
                  let buffer = Buffer.from(value, 'utf-8')
                  return new BytesValue(buffer)
                }
                /**
                 * Creates a BytesValue from a hex-encoded string.
                 */
                static fromHex(value) {
                  let buffer = Buffer.from(value, 'hex')
                  return new BytesValue(buffer)
                }
                getLength() {
                  return this.value.length
                }
                /**
                 * Returns whether two objects have the same value.
                 */
                equals(other) {
                  if (this.getLength() != other.getLength()) {
                    return false
                  }
                  return this.value.equals(other.value)
                }
                valueOf() {
                  return this.value
                }
                toString() {
                  return this.value.toString()
                }
              }
              exports.BytesValue = BytesValue
              BytesValue.ClassName = 'BytesValue'
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { './types': 145, buffer: 18 },
      ],
      124: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.CodeMetadataValue = exports.CodeMetadataType = void 0
          const types_1 = require('./types')
          class CodeMetadataType extends types_1.PrimitiveType {
            constructor() {
              super('CodeMetadata')
            }
          }
          exports.CodeMetadataType = CodeMetadataType
          class CodeMetadataValue extends types_1.PrimitiveValue {
            constructor(value) {
              super(new CodeMetadataType())
              this.value = value
            }
            equals(other) {
              return this.value.equals(other.value)
            }
            valueOf() {
              return this.value
            }
          }
          exports.CodeMetadataValue = CodeMetadataValue
        },
        { './types': 145 },
      ],
      125: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.CollectionOfTypedValues = void 0
          class CollectionOfTypedValues {
            constructor(items) {
              this.items = items
            }
            getLength() {
              return this.items.length
            }
            getItems() {
              return this.items
            }
            valueOf() {
              return this.items.map((item) => item.valueOf())
            }
            equals(other) {
              if (this.getLength() != other.getLength()) {
                return false
              }
              for (let i = 0; i < this.getLength(); i++) {
                let selfItem = this.items[i]
                let otherItem = other.items[i]
                if (!selfItem.equals(otherItem)) {
                  return false
                }
              }
              return true
            }
          }
          exports.CollectionOfTypedValues = CollectionOfTypedValues
        },
        {},
      ],
      126: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.CompositeValue = exports.CompositeType = void 0
          const utils_1 = require('../../utils')
          const types_1 = require('./types')
          class CompositeType extends types_1.Type {
            constructor(...typeParameters) {
              super(
                'Composite',
                typeParameters,
                types_1.TypeCardinality.variable(typeParameters.length)
              )
            }
            getClassName() {
              return CompositeType.ClassName
            }
          }
          exports.CompositeType = CompositeType
          CompositeType.ClassName = 'CompositeType'
          class CompositeValue extends types_1.TypedValue {
            constructor(type, items) {
              super(type)
              utils_1.guardLength(items, type.getTypeParameters().length)
              // TODO: assert type of each item (wrt. type.getTypeParameters()).
              this.items = items
            }
            getClassName() {
              return CompositeValue.ClassName
            }
            static fromItems(...items) {
              let typeParameters = items.map((value) => value.getType())
              let type = new CompositeType(...typeParameters)
              return new CompositeValue(type, items)
            }
            getItems() {
              return this.items
            }
            valueOf() {
              return this.items.map((item) =>
                item === null || item === void 0 ? void 0 : item.valueOf()
              )
            }
            equals(other) {
              if (this.getType().differs(other.getType())) {
                return false
              }
              for (let i = 0; i < this.items.length; i++) {
                let selfItem = this.items[i]
                let otherItem = other.items[i]
                if (!selfItem.equals(otherItem)) {
                  return false
                }
              }
              return true
            }
          }
          exports.CompositeValue = CompositeValue
          CompositeValue.ClassName = 'CompositeValue'
        },
        { '../../utils': 158, './types': 145 },
      ],
      127: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.EndpointParameterDefinition =
            exports.EndpointModifiers =
            exports.EndpointDefinition =
              void 0
          const typeExpressionParser_1 = require('./typeExpressionParser')
          const NamePlaceholder = '?'
          const DescriptionPlaceholder = 'N / A'
          class EndpointDefinition {
            constructor(name, input, output, modifiers) {
              this.input = []
              this.output = []
              this.name = name
              this.input = input || []
              this.output = output || []
              this.modifiers = modifiers
            }
            isConstructor() {
              return this.name == 'constructor'
            }
            static fromJSON(json) {
              json.name = json.name == null ? NamePlaceholder : json.name
              json.onlyOwner = json.onlyOwner || false
              json.payableInTokens = json.payableInTokens || []
              json.inputs = json.inputs || []
              json.outputs = json.outputs || []
              let input = json.inputs.map((param) =>
                EndpointParameterDefinition.fromJSON(param)
              )
              let output = json.outputs.map((param) =>
                EndpointParameterDefinition.fromJSON(param)
              )
              let modifiers = new EndpointModifiers(
                json.mutability,
                json.payableInTokens,
                json.onlyOwner
              )
              return new EndpointDefinition(json.name, input, output, modifiers)
            }
          }
          exports.EndpointDefinition = EndpointDefinition
          class EndpointModifiers {
            constructor(mutability, payableInTokens, onlyOwner) {
              this.mutability = mutability || ''
              this.payableInTokens = payableInTokens || []
              this.onlyOwner = onlyOwner || false
            }
            isPayableInEGLD() {
              return this.isPayableInToken('EGLD')
            }
            isPayableInToken(token) {
              if (this.payableInTokens.includes(token)) {
                return true
              }
              if (this.payableInTokens.includes(`!${token}`)) {
                return false
              }
              if (this.payableInTokens.includes('*')) {
                return true
              }
              return false
            }
            isPayable() {
              return this.payableInTokens.length != 0
            }
            isReadonly() {
              return this.mutability == 'readonly'
            }
            isOnlyOwner() {
              return this.onlyOwner
            }
          }
          exports.EndpointModifiers = EndpointModifiers
          class EndpointParameterDefinition {
            constructor(name, description, type) {
              this.name = name
              this.description = description
              this.type = type
            }
            static fromJSON(json) {
              let parsedType =
                new typeExpressionParser_1.TypeExpressionParser().parse(
                  json.type
                )
              return new EndpointParameterDefinition(
                json.name || NamePlaceholder,
                json.description || DescriptionPlaceholder,
                parsedType
              )
            }
          }
          exports.EndpointParameterDefinition = EndpointParameterDefinition
        },
        { './typeExpressionParser': 143 },
      ],
      128: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.EnumValue =
            exports.EnumVariantDefinition =
            exports.EnumType =
              void 0
          const errors_1 = require('../../errors')
          const utils_1 = require('../../utils')
          const fields_1 = require('./fields')
          const types_1 = require('./types')
          const SimpleEnumMaxDiscriminant = 256
          class EnumType extends types_1.CustomType {
            constructor(name, variants) {
              super(name)
              this.variants = []
              this.variants = variants
            }
            getClassName() {
              return EnumType.ClassName
            }
            static fromJSON(json) {
              const rawVariants = EnumType.assignMissingDiscriminants(
                json.variants || []
              )
              const variants = rawVariants.map((variant) =>
                EnumVariantDefinition.fromJSON(variant)
              )
              return new EnumType(json.name, variants)
            }
            // For some enums (e.g. some "explicit-enum" types), the discriminants are missing.
            static assignMissingDiscriminants(variants) {
              const allDiscriminantsAreMissing = variants.every(
                (variant) => variant.discriminant == undefined
              )
              if (!allDiscriminantsAreMissing) {
                // We only assign discriminants if all of them are missing.
                return variants
              }
              return variants.map((variant, index) => {
                return Object.assign(Object.assign({}, variant), {
                  discriminant: index,
                })
              })
            }
            getVariantByDiscriminant(discriminant) {
              let result = this.variants.find(
                (e) => e.discriminant == discriminant
              )
              utils_1.guardValueIsSet(
                `variant by discriminant (${discriminant})`,
                result
              )
              return result
            }
            getVariantByName(name) {
              let result = this.variants.find((e) => e.name == name)
              utils_1.guardValueIsSet(`variant by name (${name})`, result)
              return result
            }
            getNamesOfDependencies() {
              const dependencies = []
              for (const variant of this.variants) {
                dependencies.push(...variant.getNamesOfDependencies())
              }
              return [...new Set(dependencies)]
            }
          }
          exports.EnumType = EnumType
          EnumType.ClassName = 'EnumType'
          class EnumVariantDefinition {
            constructor(name, discriminant, fieldsDefinitions = []) {
              this.fieldsDefinitions = []
              utils_1.guardTrue(
                discriminant < SimpleEnumMaxDiscriminant,
                `discriminant for simple enum should be less than ${SimpleEnumMaxDiscriminant}`
              )
              this.name = name
              this.discriminant = discriminant
              this.fieldsDefinitions = fieldsDefinitions
            }
            static fromJSON(json) {
              let definitions = (json.fields || []).map((definition) =>
                fields_1.FieldDefinition.fromJSON(definition)
              )
              return new EnumVariantDefinition(
                json.name,
                json.discriminant,
                definitions
              )
            }
            getFieldsDefinitions() {
              return this.fieldsDefinitions
            }
            getFieldDefinition(name) {
              return this.fieldsDefinitions.find((item) => item.name == name)
            }
            getNamesOfDependencies() {
              return fields_1.Fields.getNamesOfTypeDependencies(
                this.fieldsDefinitions
              )
            }
          }
          exports.EnumVariantDefinition = EnumVariantDefinition
          class EnumValue extends types_1.TypedValue {
            constructor(type, variant, fields) {
              super(type)
              this.fields = []
              this.name = variant.name
              this.discriminant = variant.discriminant
              this.fields = fields
              this.fieldsByName = new Map(
                fields.map((field) => [field.name, field])
              )
              let definitions = variant.getFieldsDefinitions()
              fields_1.Fields.checkTyping(this.fields, definitions)
            }
            getClassName() {
              return EnumValue.ClassName
            }
            /**
             * Utility (named constructor) to create a simple (i.e. without fields) enum value.
             */
            static fromName(type, name) {
              let variant = type.getVariantByName(name)
              return new EnumValue(type, variant, [])
            }
            /**
             * Utility (named constructor) to create a simple (i.e. without fields) enum value.
             */
            static fromDiscriminant(type, discriminant) {
              let variant = type.getVariantByDiscriminant(discriminant)
              return new EnumValue(type, variant, [])
            }
            equals(other) {
              if (!this.getType().equals(other.getType())) {
                return false
              }
              let selfFields = this.getFields()
              let otherFields = other.getFields()
              const nameIsSame = this.name == other.name
              const discriminantIsSame = this.discriminant == other.discriminant
              const fieldsAreSame = fields_1.Fields.equals(
                selfFields,
                otherFields
              )
              return nameIsSame && discriminantIsSame && fieldsAreSame
            }
            getFields() {
              return this.fields
            }
            getFieldValue(name) {
              let field = this.fieldsByName.get(name)
              if (field) {
                return field.value.valueOf()
              }
              throw new errors_1.ErrMissingFieldOnEnum(
                name,
                this.getType().getName()
              )
            }
            valueOf() {
              let result = { name: this.name, fields: [] }
              this.fields.forEach(
                (field, index) => (result.fields[index] = field.value.valueOf())
              )
              return result
            }
          }
          exports.EnumValue = EnumValue
          EnumValue.ClassName = 'EnumValue'
        },
        {
          '../../errors': 66,
          '../../utils': 158,
          './fields': 131,
          './types': 145,
        },
      ],
      129: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.EventTopicDefinition = exports.EventDefinition = void 0
          const typeExpressionParser_1 = require('./typeExpressionParser')
          const NamePlaceholder = '?'
          class EventDefinition {
            constructor(identifier, inputs) {
              this.inputs = []
              this.identifier = identifier
              this.inputs = inputs || []
            }
            static fromJSON(json) {
              json.identifier =
                json.identifier == null ? NamePlaceholder : json.identifier
              json.inputs = json.inputs || []
              const inputs = json.inputs.map((param) =>
                EventTopicDefinition.fromJSON(param)
              )
              return new EventDefinition(json.identifier, inputs)
            }
          }
          exports.EventDefinition = EventDefinition
          class EventTopicDefinition {
            constructor(options) {
              this.name = options.name
              this.type = options.type
              this.indexed = options.indexed
            }
            static fromJSON(json) {
              const parsedType =
                new typeExpressionParser_1.TypeExpressionParser().parse(
                  json.type
                )
              return new EventTopicDefinition({
                name: json.name || NamePlaceholder,
                type: parsedType,
                indexed: json.indexed,
              })
            }
          }
          exports.EventTopicDefinition = EventTopicDefinition
        },
        { './typeExpressionParser': 143 },
      ],
      130: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.createListOfTokenIdentifiers = exports.createListOfAddresses =
            void 0
          const address_1 = require('./address')
          const generic_1 = require('./generic')
          const tokenIdentifier_1 = require('./tokenIdentifier')
          function createListOfAddresses(addresses) {
            let addressesTyped = addresses.map(
              (address) => new address_1.AddressValue(address)
            )
            let list = generic_1.List.fromItems(addressesTyped)
            return list
          }
          exports.createListOfAddresses = createListOfAddresses
          function createListOfTokenIdentifiers(identifiers) {
            let identifiersTyped = identifiers.map(
              (identifier) =>
                new tokenIdentifier_1.TokenIdentifierValue(identifier)
            )
            let list = generic_1.List.fromItems(identifiersTyped)
            return list
          }
          exports.createListOfTokenIdentifiers = createListOfTokenIdentifiers
        },
        { './address': 120, './generic': 132, './tokenIdentifier': 141 },
      ],
      131: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.Fields = exports.Field = exports.FieldDefinition = void 0
          const errors = __importStar(require('../../errors'))
          const typeExpressionParser_1 = require('./typeExpressionParser')
          class FieldDefinition {
            constructor(name, description, type) {
              this.name = name
              this.description = description
              this.type = type
            }
            static fromJSON(json) {
              let parsedType =
                new typeExpressionParser_1.TypeExpressionParser().parse(
                  json.type
                )
              return new FieldDefinition(
                json.name,
                json.description,
                parsedType
              )
            }
          }
          exports.FieldDefinition = FieldDefinition
          class Field {
            constructor(value, name = '') {
              this.value = value
              this.name = name
            }
            checkTyping(expectedDefinition) {
              const actualType = this.value.getType()
              if (!actualType.equals(expectedDefinition.type)) {
                throw new errors.ErrTypingSystem(
                  `check type of field "${expectedDefinition.name}; expected: ${expectedDefinition.type}, actual: ${actualType}"`
                )
              }
              if (this.name != expectedDefinition.name) {
                throw new errors.ErrTypingSystem(
                  `check name of field "${expectedDefinition.name}"`
                )
              }
            }
            equals(other) {
              return this.name == other.name && this.value.equals(other.value)
            }
          }
          exports.Field = Field
          class Fields {
            static checkTyping(fields, definitions) {
              if (fields.length != definitions.length) {
                throw new errors.ErrTypingSystem(
                  'fields length vs. field definitions length'
                )
              }
              for (let i = 0; i < fields.length; i++) {
                let field = fields[i]
                let definition = definitions[i]
                field.checkTyping(definition)
              }
            }
            static equals(actual, expected) {
              if (actual.length != expected.length) {
                return false
              }
              for (let i = 0; i < actual.length; i++) {
                let selfField = actual[i]
                let otherField = expected[i]
                if (!selfField.equals(otherField)) {
                  return false
                }
              }
              return true
            }
            static getNamesOfTypeDependencies(definitions) {
              const dependencies = []
              for (const definition of definitions) {
                dependencies.push(definition.type.getName())
                dependencies.push(...definition.type.getNamesOfDependencies())
              }
              return [...new Set(dependencies)]
            }
          }
          exports.Fields = Fields
        },
        { '../../errors': 66, './typeExpressionParser': 143 },
      ],
      132: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.List =
            exports.OptionValue =
            exports.ListType =
            exports.OptionType =
              void 0
          const utils_1 = require('../../utils')
          const collections_1 = require('./collections')
          const types_1 = require('./types')
          // TODO: Move to a new file, "genericOption.ts"
          class OptionType extends types_1.Type {
            constructor(typeParameter) {
              super('Option', [typeParameter])
            }
            getClassName() {
              return OptionType.ClassName
            }
            isAssignableFrom(type) {
              if (!type.hasExactClass(OptionType.ClassName)) {
                return false
              }
              let invariantTypeParameters = this.getFirstTypeParameter().equals(
                type.getFirstTypeParameter()
              )
              let fakeCovarianceToNull = type
                .getFirstTypeParameter()
                .hasExactClass(types_1.NullType.ClassName)
              return invariantTypeParameters || fakeCovarianceToNull
            }
          }
          exports.OptionType = OptionType
          OptionType.ClassName = 'OptionType'
          // TODO: Move to a new file, "genericList.ts"
          class ListType extends types_1.Type {
            constructor(typeParameter) {
              super('List', [typeParameter])
            }
            getClassName() {
              return ListType.ClassName
            }
          }
          exports.ListType = ListType
          ListType.ClassName = 'ListType'
          // TODO: Move to a new file, "genericOption.ts"
          class OptionValue extends types_1.TypedValue {
            constructor(type, value = null) {
              super(type)
              // TODO: assert value is of type type.getFirstTypeParameter()
              this.value = value
            }
            getClassName() {
              return OptionValue.ClassName
            }
            /**
             * Creates an OptionValue, as a missing option argument.
             */
            static newMissing() {
              let type = new OptionType(new types_1.NullType())
              return new OptionValue(type)
            }
            static newMissingTyped(type) {
              return new OptionValue(new OptionType(type))
            }
            /**
             * Creates an OptionValue, as a provided option argument.
             */
            static newProvided(typedValue) {
              let type = new OptionType(typedValue.getType())
              return new OptionValue(type, typedValue)
            }
            isSet() {
              return this.value ? true : false
            }
            getTypedValue() {
              utils_1.guardValueIsSet('value', this.value)
              return this.value
            }
            valueOf() {
              return this.value ? this.value.valueOf() : null
            }
            equals(other) {
              var _a
              return (
                ((_a = this.value) === null || _a === void 0
                  ? void 0
                  : _a.equals(other.value)) || false
              )
            }
          }
          exports.OptionValue = OptionValue
          OptionValue.ClassName = 'OptionValue'
          // TODO: Move to a new file, "genericList.ts"
          // TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).
          // Question for review: or not?
          class List extends types_1.TypedValue {
            /**
             *
             * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType
             * @param items the items, having the type type.getFirstTypeParameter()
             */
            constructor(type, items) {
              super(type)
              // TODO: assert items are of type type.getFirstTypeParameter()
              this.backingCollection =
                new collections_1.CollectionOfTypedValues(items)
            }
            getClassName() {
              return List.ClassName
            }
            static fromItems(items) {
              if (items.length == 0) {
                return new List(new types_1.TypePlaceholder(), [])
              }
              let typeParameter = items[0].getType()
              let listType = new ListType(typeParameter)
              return new List(listType, items)
            }
            getLength() {
              return this.backingCollection.getLength()
            }
            getItems() {
              return this.backingCollection.getItems()
            }
            valueOf() {
              return this.backingCollection.valueOf()
            }
            equals(other) {
              return this.backingCollection.equals(other.backingCollection)
            }
          }
          exports.List = List
          List.ClassName = 'List'
        },
        { '../../utils': 158, './collections': 125, './types': 145 },
      ],
      133: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.ArrayVec = exports.ArrayVecType = void 0
          const utils_1 = require('../../utils')
          const collections_1 = require('./collections')
          const types_1 = require('./types')
          // A type for known-length arrays. E.g. "array20", "array32", "array64" etc.
          class ArrayVecType extends types_1.Type {
            constructor(length, typeParameter) {
              super('Array', [typeParameter])
              utils_1.guardTrue(length > 0, 'array length > 0')
              this.length = length
            }
            getClassName() {
              return ArrayVecType.ClassName
            }
          }
          exports.ArrayVecType = ArrayVecType
          ArrayVecType.ClassName = 'ArrayVecType'
          class ArrayVec extends types_1.TypedValue {
            constructor(type, items) {
              super(type)
              utils_1.guardLength(items, type.length)
              this.backingCollection =
                new collections_1.CollectionOfTypedValues(items)
            }
            getClassName() {
              return ArrayVec.ClassName
            }
            getLength() {
              return this.backingCollection.getLength()
            }
            getItems() {
              return this.backingCollection.getItems()
            }
            valueOf() {
              return this.backingCollection.valueOf()
            }
            equals(other) {
              return this.backingCollection.equals(other.backingCollection)
            }
          }
          exports.ArrayVec = ArrayVec
          ArrayVec.ClassName = 'ArrayVec'
        },
        { '../../utils': 158, './collections': 125, './types': 145 },
      ],
      134: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.H256Value = exports.H256Type = void 0
          const types_1 = require('./types')
          class H256Type extends types_1.PrimitiveType {
            constructor() {
              super('H256')
            }
            getClassName() {
              return H256Type.ClassName
            }
          }
          exports.H256Type = H256Type
          H256Type.ClassName = 'H256Type'
          class H256Value extends types_1.PrimitiveValue {
            constructor(value) {
              super(new H256Type())
              this.value = value
            }
            getClassName() {
              return H256Value.ClassName
            }
            /**
             * Returns whether two objects have the same value.
             */
            equals(other) {
              return this.value.equals(other.value)
            }
            valueOf() {
              return this.value
            }
          }
          exports.H256Value = H256Value
          H256Value.ClassName = 'H256Value'
        },
        { './types': 145 },
      ],
      135: [
        function (require, module, exports) {
          'use strict'
          /**
           * @packageDocumentation
           * @module typesystem
           */
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __exportStar =
            (this && this.__exportStar) ||
            function (m, exports) {
              for (var p in m)
                if (
                  p !== 'default' &&
                  !Object.prototype.hasOwnProperty.call(exports, p)
                )
                  __createBinding(exports, m, p)
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          __exportStar(require('./abiRegistry'), exports)
          __exportStar(require('./address'), exports)
          __exportStar(require('./algebraic'), exports)
          __exportStar(require('./boolean'), exports)
          __exportStar(require('./bytes'), exports)
          __exportStar(require('./composite'), exports)
          __exportStar(require('./endpoint'), exports)
          __exportStar(require('./enum'), exports)
          __exportStar(require('./factory'), exports)
          __exportStar(require('./fields'), exports)
          __exportStar(require('./generic'), exports)
          __exportStar(require('./genericArray'), exports)
          __exportStar(require('./h256'), exports)
          __exportStar(require('./matchers'), exports)
          __exportStar(require('./nothing'), exports)
          __exportStar(require('./numerical'), exports)
          __exportStar(require('./string'), exports)
          __exportStar(require('./struct'), exports)
          __exportStar(require('./tokenIdentifier'), exports)
          __exportStar(require('./tuple'), exports)
          __exportStar(require('./typeExpressionParser'), exports)
          __exportStar(require('./typeMapper'), exports)
          __exportStar(require('./types'), exports)
          __exportStar(require('./variadic'), exports)
        },
        {
          './abiRegistry': 119,
          './address': 120,
          './algebraic': 121,
          './boolean': 122,
          './bytes': 123,
          './composite': 126,
          './endpoint': 127,
          './enum': 128,
          './factory': 130,
          './fields': 131,
          './generic': 132,
          './genericArray': 133,
          './h256': 134,
          './matchers': 136,
          './nothing': 137,
          './numerical': 138,
          './string': 139,
          './struct': 140,
          './tokenIdentifier': 141,
          './tuple': 142,
          './typeExpressionParser': 143,
          './typeMapper': 144,
          './types': 145,
          './variadic': 146,
        },
      ],
      136: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.onPrimitiveTypeSelect =
            exports.onPrimitiveValueSelect =
            exports.onTypedValueSelect =
            exports.onTypeSelect =
              void 0
          const errors = __importStar(require('../../errors'))
          const address_1 = require('./address')
          const boolean_1 = require('./boolean')
          const bytes_1 = require('./bytes')
          const enum_1 = require('./enum')
          const generic_1 = require('./generic')
          const h256_1 = require('./h256')
          const numerical_1 = require('./numerical')
          const nothing_1 = require('./nothing')
          const struct_1 = require('./struct')
          const tokenIdentifier_1 = require('./tokenIdentifier')
          const tuple_1 = require('./tuple')
          const types_1 = require('./types')
          const genericArray_1 = require('./genericArray')
          const string_1 = require('./string')
          // TODO: Extend functionality or rename wrt. restricted / reduced functionality (not all types are handled: composite, variadic).
          function onTypeSelect(type, selectors) {
            if (type.hasExactClass(generic_1.OptionType.ClassName)) {
              return selectors.onOption()
            }
            if (type.hasExactClass(generic_1.ListType.ClassName)) {
              return selectors.onList()
            }
            if (type.hasExactClass(genericArray_1.ArrayVecType.ClassName)) {
              return selectors.onArray()
            }
            if (type.hasClassOrSuperclass(types_1.PrimitiveType.ClassName)) {
              return selectors.onPrimitive()
            }
            if (type.hasExactClass(struct_1.StructType.ClassName)) {
              return selectors.onStruct()
            }
            if (type.hasExactClass(tuple_1.TupleType.ClassName)) {
              return selectors.onTuple()
            }
            if (type.hasExactClass(enum_1.EnumType.ClassName)) {
              return selectors.onEnum()
            }
            if (selectors.onOther) {
              return selectors.onOther()
            }
            throw new errors.ErrTypingSystem(`type isn't known: ${type}`)
          }
          exports.onTypeSelect = onTypeSelect
          function onTypedValueSelect(value, selectors) {
            if (value.hasClassOrSuperclass(types_1.PrimitiveValue.ClassName)) {
              return selectors.onPrimitive()
            }
            if (value.hasExactClass(generic_1.OptionValue.ClassName)) {
              return selectors.onOption()
            }
            if (value.hasExactClass(generic_1.List.ClassName)) {
              return selectors.onList()
            }
            if (value.hasExactClass(genericArray_1.ArrayVec.ClassName)) {
              return selectors.onArray()
            }
            if (value.hasExactClass(struct_1.Struct.ClassName)) {
              return selectors.onStruct()
            }
            if (value.hasExactClass(tuple_1.Tuple.ClassName)) {
              return selectors.onTuple()
            }
            if (value.hasExactClass(enum_1.EnumValue.ClassName)) {
              return selectors.onEnum()
            }
            if (selectors.onOther) {
              return selectors.onOther()
            }
            throw new errors.ErrTypingSystem(`value isn't typed: ${value}`)
          }
          exports.onTypedValueSelect = onTypedValueSelect
          function onPrimitiveValueSelect(value, selectors) {
            if (value.hasExactClass(boolean_1.BooleanValue.ClassName)) {
              return selectors.onBoolean()
            }
            if (
              value.hasClassOrSuperclass(numerical_1.NumericalValue.ClassName)
            ) {
              return selectors.onNumerical()
            }
            if (value.hasExactClass(address_1.AddressValue.ClassName)) {
              return selectors.onAddress()
            }
            if (value.hasExactClass(bytes_1.BytesValue.ClassName)) {
              return selectors.onBytes()
            }
            if (value.hasExactClass(string_1.StringValue.ClassName)) {
              return selectors.onString()
            }
            if (value.hasExactClass(h256_1.H256Value.ClassName)) {
              return selectors.onH256()
            }
            if (
              value.hasExactClass(
                tokenIdentifier_1.TokenIdentifierValue.ClassName
              )
            ) {
              return selectors.onTypeIdentifier()
            }
            if (value.hasExactClass(nothing_1.NothingValue.ClassName)) {
              return selectors.onNothing()
            }
            if (selectors.onOther) {
              return selectors.onOther()
            }
            throw new errors.ErrTypingSystem(
              `value isn't a primitive: ${value.getType()}`
            )
          }
          exports.onPrimitiveValueSelect = onPrimitiveValueSelect
          function onPrimitiveTypeSelect(type, selectors) {
            if (type.hasExactClass(boolean_1.BooleanType.ClassName)) {
              return selectors.onBoolean()
            }
            if (
              type.hasClassOrSuperclass(numerical_1.NumericalType.ClassName)
            ) {
              return selectors.onNumerical()
            }
            if (type.hasExactClass(address_1.AddressType.ClassName)) {
              return selectors.onAddress()
            }
            if (type.hasExactClass(bytes_1.BytesType.ClassName)) {
              return selectors.onBytes()
            }
            if (type.hasExactClass(string_1.StringType.ClassName)) {
              return selectors.onString()
            }
            if (type.hasExactClass(h256_1.H256Type.ClassName)) {
              return selectors.onH256()
            }
            if (
              type.hasExactClass(
                tokenIdentifier_1.TokenIdentifierType.ClassName
              )
            ) {
              return selectors.onTokenIndetifier()
            }
            if (type.hasExactClass(nothing_1.NothingType.ClassName)) {
              return selectors.onNothing()
            }
            if (selectors.onOther) {
              return selectors.onOther()
            }
            throw new errors.ErrTypingSystem(
              `type isn't a known primitive: ${type}`
            )
          }
          exports.onPrimitiveTypeSelect = onPrimitiveTypeSelect
        },
        {
          '../../errors': 66,
          './address': 120,
          './boolean': 122,
          './bytes': 123,
          './enum': 128,
          './generic': 132,
          './genericArray': 133,
          './h256': 134,
          './nothing': 137,
          './numerical': 138,
          './string': 139,
          './struct': 140,
          './tokenIdentifier': 141,
          './tuple': 142,
          './types': 145,
        },
      ],
      137: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.NothingValue = exports.NothingType = void 0
          const types_1 = require('./types')
          class NothingType extends types_1.PrimitiveType {
            constructor() {
              super('nothing')
            }
            getClassName() {
              return NothingType.ClassName
            }
          }
          exports.NothingType = NothingType
          NothingType.ClassName = 'NothingType'
          class NothingValue extends types_1.PrimitiveValue {
            constructor() {
              super(new NothingType())
            }
            getClassName() {
              return NothingValue.ClassName
            }
            equals(_other) {
              return false
            }
            valueOf() {
              return {}
            }
          }
          exports.NothingValue = NothingValue
          NothingValue.ClassName = 'NothingValue'
        },
        { './types': 145 },
      ],
      138: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          var __importDefault =
            (this && this.__importDefault) ||
            function (mod) {
              return mod && mod.__esModule ? mod : { default: mod }
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.BigIntValue =
            exports.BigUIntValue =
            exports.I64Value =
            exports.U64Value =
            exports.I32Value =
            exports.U32Value =
            exports.I16Value =
            exports.U16Value =
            exports.I8Value =
            exports.U8Value =
            exports.NumericalValue =
            exports.BigIntType =
            exports.BigUIntType =
            exports.I64Type =
            exports.U64Type =
            exports.I32Type =
            exports.U32Type =
            exports.I16Type =
            exports.U16Type =
            exports.I8Type =
            exports.U8Type =
            exports.NumericalType =
              void 0
          const errors = __importStar(require('../../errors'))
          const types_1 = require('./types')
          const bignumber_js_1 = __importDefault(require('bignumber.js'))
          class NumericalType extends types_1.PrimitiveType {
            constructor(name, sizeInBytes, withSign) {
              super(name)
              this.sizeInBytes = sizeInBytes
              this.withSign = withSign
            }
            getClassName() {
              return NumericalType.ClassName
            }
            hasFixedSize() {
              return this.sizeInBytes ? true : false
            }
            hasArbitrarySize() {
              return !this.hasFixedSize()
            }
          }
          exports.NumericalType = NumericalType
          NumericalType.ClassName = 'NumericalType'
          class U8Type extends NumericalType {
            constructor() {
              super('u8', 1, false)
            }
            getClassName() {
              return U8Type.ClassName
            }
          }
          exports.U8Type = U8Type
          U8Type.ClassName = 'U8Type'
          class I8Type extends NumericalType {
            constructor() {
              super('i8', 1, true)
            }
            getClassName() {
              return I8Type.ClassName
            }
          }
          exports.I8Type = I8Type
          I8Type.ClassName = 'I8Type'
          class U16Type extends NumericalType {
            constructor() {
              super('u16', 2, false)
            }
            getClassName() {
              return U16Type.ClassName
            }
          }
          exports.U16Type = U16Type
          U16Type.ClassName = 'U16Type'
          class I16Type extends NumericalType {
            constructor() {
              super('i16', 2, true)
            }
            getClassName() {
              return I16Type.ClassName
            }
          }
          exports.I16Type = I16Type
          I16Type.ClassName = 'I16Type'
          class U32Type extends NumericalType {
            constructor() {
              super('u32', 4, false)
            }
            getClassName() {
              return U32Type.ClassName
            }
          }
          exports.U32Type = U32Type
          U32Type.ClassName = 'U32Type'
          class I32Type extends NumericalType {
            constructor() {
              super('i32', 4, true)
            }
            getClassName() {
              return I32Type.ClassName
            }
          }
          exports.I32Type = I32Type
          I32Type.ClassName = 'I32Type'
          class U64Type extends NumericalType {
            constructor() {
              super('u64', 8, false)
            }
            getClassName() {
              return U64Type.ClassName
            }
          }
          exports.U64Type = U64Type
          U64Type.ClassName = 'U64Type'
          class I64Type extends NumericalType {
            constructor() {
              super('i64', 8, true)
            }
            getClassName() {
              return I64Type.ClassName
            }
          }
          exports.I64Type = I64Type
          I64Type.ClassName = 'I64Type'
          class BigUIntType extends NumericalType {
            constructor() {
              super('BigUint', 0, false)
            }
            getClassName() {
              return BigUIntType.ClassName
            }
          }
          exports.BigUIntType = BigUIntType
          BigUIntType.ClassName = 'BigUIntType'
          class BigIntType extends NumericalType {
            constructor() {
              super('Bigint', 0, true)
            }
            getClassName() {
              return BigIntType.ClassName
            }
          }
          exports.BigIntType = BigIntType
          BigIntType.ClassName = 'BigIntType'
          /**
           * A numerical value fed to or fetched from a Smart Contract contract, as a strongly-typed, immutable abstraction.
           */
          class NumericalValue extends types_1.PrimitiveValue {
            constructor(type, value) {
              super(type)
              this.value = new bignumber_js_1.default(value)
              this.sizeInBytes = type.sizeInBytes
              this.withSign = type.withSign
              if (this.value.isNaN()) {
                throw new errors.ErrInvalidArgument(`not a number: ${value}`)
              }
              if (!this.withSign && this.value.isNegative()) {
                throw new errors.ErrInvalidArgument(
                  `negative, but type is unsigned: ${value}`
                )
              }
            }
            getClassName() {
              return NumericalValue.ClassName
            }
            /**
             * Returns whether two objects have the same value.
             *
             * @param other another NumericalValue
             */
            equals(other) {
              return this.value.isEqualTo(other.value)
            }
            valueOf() {
              return this.value
            }
            toString() {
              return this.value.toString()
            }
          }
          exports.NumericalValue = NumericalValue
          NumericalValue.ClassName = 'NumericalValue'
          class U8Value extends NumericalValue {
            constructor(value) {
              super(new U8Type(), new bignumber_js_1.default(value))
            }
            getClassName() {
              return U8Value.ClassName
            }
          }
          exports.U8Value = U8Value
          U8Value.ClassName = 'U8Value'
          class I8Value extends NumericalValue {
            constructor(value) {
              super(new I8Type(), new bignumber_js_1.default(value))
            }
            getClassName() {
              return I8Value.ClassName
            }
          }
          exports.I8Value = I8Value
          I8Value.ClassName = 'I8Value'
          class U16Value extends NumericalValue {
            constructor(value) {
              super(new U16Type(), new bignumber_js_1.default(value))
            }
            getClassName() {
              return U16Value.ClassName
            }
          }
          exports.U16Value = U16Value
          U16Value.ClassName = 'U16Value'
          class I16Value extends NumericalValue {
            constructor(value) {
              super(new I16Type(), new bignumber_js_1.default(value))
            }
            getClassName() {
              return I16Value.ClassName
            }
          }
          exports.I16Value = I16Value
          I16Value.ClassName = 'I16Value'
          class U32Value extends NumericalValue {
            constructor(value) {
              super(new U32Type(), new bignumber_js_1.default(value))
            }
            getClassName() {
              return U32Value.ClassName
            }
          }
          exports.U32Value = U32Value
          U32Value.ClassName = 'U32Value'
          class I32Value extends NumericalValue {
            constructor(value) {
              super(new I32Type(), new bignumber_js_1.default(value))
            }
            getClassName() {
              return I32Value.ClassName
            }
          }
          exports.I32Value = I32Value
          I32Value.ClassName = 'I32Value'
          class U64Value extends NumericalValue {
            constructor(value) {
              super(new U64Type(), value)
            }
            getClassName() {
              return U64Value.ClassName
            }
          }
          exports.U64Value = U64Value
          U64Value.ClassName = 'U64Value'
          class I64Value extends NumericalValue {
            constructor(value) {
              super(new I64Type(), value)
            }
            getClassName() {
              return I64Value.ClassName
            }
          }
          exports.I64Value = I64Value
          I64Value.ClassName = 'I64Value'
          class BigUIntValue extends NumericalValue {
            constructor(value) {
              super(new BigUIntType(), value)
            }
            getClassName() {
              return BigUIntValue.ClassName
            }
          }
          exports.BigUIntValue = BigUIntValue
          BigUIntValue.ClassName = 'BigUIntValue'
          class BigIntValue extends NumericalValue {
            constructor(value) {
              super(new BigIntType(), value)
            }
            getClassName() {
              return BigIntValue.ClassName
            }
          }
          exports.BigIntValue = BigIntValue
          BigIntValue.ClassName = 'BigIntValue'
        },
        { '../../errors': 66, './types': 145, 'bignumber.js': 13 },
      ],
      139: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.StringValue = exports.StringType = void 0
              const types_1 = require('./types')
              class StringType extends types_1.PrimitiveType {
                constructor() {
                  super('utf-8 string')
                }
                getClassName() {
                  return StringType.ClassName
                }
              }
              exports.StringType = StringType
              StringType.ClassName = 'StringType'
              class StringValue extends types_1.PrimitiveValue {
                constructor(value) {
                  super(new StringType())
                  this.value = value
                }
                getClassName() {
                  return StringValue.ClassName
                }
                /**
                 * Creates a StringValue from a utf-8 string.
                 */
                static fromUTF8(value) {
                  return new StringValue(value)
                }
                /**
                 * Creates a StringValue from a hex-encoded string.
                 */
                static fromHex(value) {
                  let decodedValue = Buffer.from(value, 'hex').toString()
                  return new StringValue(decodedValue)
                }
                getLength() {
                  return this.value.length
                }
                /**
                 * Returns whether two objects have the same value.
                 */
                equals(other) {
                  return this.value === other.value
                }
                valueOf() {
                  return this.value
                }
              }
              exports.StringValue = StringValue
              StringValue.ClassName = 'StringValue'
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { './types': 145, buffer: 18 },
      ],
      140: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.Struct = exports.StructType = void 0
          const errors_1 = require('../../errors')
          const fields_1 = require('./fields')
          const types_1 = require('./types')
          class StructType extends types_1.CustomType {
            constructor(name, fieldsDefinitions) {
              super(name)
              this.fieldsDefinitions = []
              this.fieldsDefinitions = fieldsDefinitions
            }
            getClassName() {
              return StructType.ClassName
            }
            static fromJSON(json) {
              let definitions = (json.fields || []).map((definition) =>
                fields_1.FieldDefinition.fromJSON(definition)
              )
              return new StructType(json.name, definitions)
            }
            getFieldsDefinitions() {
              return this.fieldsDefinitions
            }
            getFieldDefinition(name) {
              return this.fieldsDefinitions.find((item) => item.name == name)
            }
            getNamesOfDependencies() {
              return fields_1.Fields.getNamesOfTypeDependencies(
                this.fieldsDefinitions
              )
            }
          }
          exports.StructType = StructType
          StructType.ClassName = 'StructType'
          class Struct extends types_1.TypedValue {
            /**
             * One can only set fields at initialization time.
             */
            constructor(type, fields) {
              super(type)
              this.fields = fields
              this.fieldsByName = new Map(
                fields.map((field) => [field.name, field])
              )
              this.checkTyping()
            }
            getClassName() {
              return Struct.ClassName
            }
            checkTyping() {
              let type = this.getType()
              let definitions = type.getFieldsDefinitions()
              fields_1.Fields.checkTyping(this.fields, definitions)
            }
            getFields() {
              return this.fields
            }
            getFieldValue(name) {
              let field = this.fieldsByName.get(name)
              if (field) {
                return field.value.valueOf()
              }
              throw new errors_1.ErrMissingFieldOnStruct(
                name,
                this.getType().getName()
              )
            }
            valueOf() {
              let result = {}
              for (const field of this.fields) {
                result[field.name] = field.value.valueOf()
              }
              return result
            }
            equals(other) {
              if (!this.getType().equals(other.getType())) {
                return false
              }
              let selfFields = this.getFields()
              let otherFields = other.getFields()
              return fields_1.Fields.equals(selfFields, otherFields)
            }
          }
          exports.Struct = Struct
          Struct.ClassName = 'Struct'
        },
        { '../../errors': 66, './fields': 131, './types': 145 },
      ],
      141: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TokenIdentifierValue = exports.TokenIdentifierType = void 0
          const types_1 = require('./types')
          const EGLDTokenIdentifier = 'EGLD'
          class TokenIdentifierType extends types_1.PrimitiveType {
            constructor() {
              super('TokenIdentifier')
            }
            getClassName() {
              return TokenIdentifierType.ClassName
            }
          }
          exports.TokenIdentifierType = TokenIdentifierType
          TokenIdentifierType.ClassName = 'TokenIdentifierType'
          class TokenIdentifierValue extends types_1.PrimitiveValue {
            constructor(value) {
              super(new TokenIdentifierType())
              this.value = value
            }
            static egld() {
              return new TokenIdentifierValue(EGLDTokenIdentifier)
            }
            static esdtTokenIdentifier(identifier) {
              return new TokenIdentifierValue(identifier)
            }
            getClassName() {
              return TokenIdentifierValue.ClassName
            }
            getLength() {
              return this.value.length
            }
            /**
             * Returns whether two objects have the same value.
             */
            equals(other) {
              if (this.getLength() != other.getLength()) {
                return false
              }
              return this.value == other.value
            }
            valueOf() {
              return this.value
            }
            toString() {
              return this.value.toString()
            }
          }
          exports.TokenIdentifierValue = TokenIdentifierValue
          TokenIdentifierValue.ClassName = 'TokenIdentifierValue'
        },
        { './types': 145 },
      ],
      142: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.Tuple = exports.TupleType = void 0
          const errors = __importStar(require('../../errors'))
          const fields_1 = require('./fields')
          const struct_1 = require('./struct')
          class TupleType extends struct_1.StructType {
            constructor(...typeParameters) {
              super(
                TupleType.prepareName(typeParameters),
                TupleType.prepareFieldDefinitions(typeParameters)
              )
            }
            getClassName() {
              return TupleType.ClassName
            }
            static prepareName(typeParameters) {
              let fields = typeParameters
                .map((type) => type.toString())
                .join(', ')
              let result = `tuple<${fields}>`
              return result
            }
            static prepareFieldDefinitions(typeParameters) {
              let result = typeParameters.map(
                (type, i) =>
                  new fields_1.FieldDefinition(
                    prepareFieldName(i),
                    'anonymous tuple field',
                    type
                  )
              )
              return result
            }
          }
          exports.TupleType = TupleType
          TupleType.ClassName = 'TupleType'
          function prepareFieldName(fieldIndex) {
            return `field${fieldIndex}`
          }
          // TODO: Perhaps add a common base class for Struct and Tuple, called FieldsHolder?
          // Or let Tuple be the base class, but have Struct as a specialization of it, "named tuple"?
          // Or leave as it is?
          class Tuple extends struct_1.Struct {
            constructor(type, fields) {
              super(type, fields)
            }
            getClassName() {
              return Tuple.ClassName
            }
            static fromItems(items) {
              if (items.length < 1) {
                // TODO: Define a better error.
                throw new errors.ErrTypingSystem('bad tuple items')
              }
              let fieldsTypes = items.map((item) => item.getType())
              let tupleType = new TupleType(...fieldsTypes)
              let fields = items.map(
                (item, i) => new fields_1.Field(item, prepareFieldName(i))
              )
              return new Tuple(tupleType, fields)
            }
          }
          exports.Tuple = Tuple
          Tuple.ClassName = 'Tuple'
        },
        { '../../errors': 66, './fields': 131, './struct': 140 },
      ],
      143: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TypeExpressionParser = void 0
          const errors = __importStar(require('../../errors'))
          const types_1 = require('./types')
          var jsonHandler = require('json-duplicate-key-handle')
          class TypeExpressionParser {
            parse(expression) {
              let root = this.doParse(expression)
              let rootKeys = Object.keys(root)
              if (rootKeys.length != 1) {
                throw new errors.ErrTypingSystem(
                  `bad type expression: ${expression}`
                )
              }
              let name = rootKeys[0]
              let type = this.nodeToType(name, root[name])
              return type
            }
            doParse(expression) {
              let jsoned = this.getJsonedString(expression)
              try {
                return jsonHandler.parse(jsoned)
              } catch (error) {
                throw new errors.ErrTypingSystem(
                  `cannot parse type expression: ${expression}. internal json: ${jsoned}.`
                )
              }
            }
            /**
             * Converts a raw type expression to a JSON, parsing-friendly format.
             * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).
             *
             * @param expression a string such as:
             *
             * ```
             *  - Option<List<Address>>
             *  - VarArgs<MultiArg2<bytes, Address>>
             *  - MultiResultVec<MultiResult2<Address, u64>
             * ```
             */
            getJsonedString(expression) {
              let jsoned = ''
              for (var i = 0; i < expression.length; i++) {
                let char = expression.charAt(i)
                let previousChar = expression.charAt(i - 1)
                let nextChar = expression.charAt(i + 1)
                if (char == '<') {
                  jsoned += ': {'
                } else if (char == '>') {
                  if (previousChar != '>') {
                    jsoned += ': {} }'
                  } else {
                    jsoned += '}'
                  }
                } else if (char == ',') {
                  if (nextChar == '>') {
                    // Skip superfluous comma
                  } else if (previousChar == '>') {
                    jsoned += ','
                  } else {
                    jsoned += ': {},'
                  }
                } else {
                  jsoned += char
                }
              }
              // Split by the delimiters, but exclude the spaces that are found in the middle of "utf-8 string"
              let symbolsRegex = /(:|\{|\}|,|\s)/
              let tokens = jsoned
                // Hack for Safari compatibility, where we can't use negative lookbehind
                .replace(/utf\-8\sstring/gi, 'utf-8-string')
                .split(symbolsRegex)
                .filter((token) => token)
              jsoned = tokens
                .map((token) =>
                  symbolsRegex.test(token) ? token : `"${token}"`
                )
                .map((token) =>
                  token.replace(/utf\-8\-string/gi, 'utf-8 string')
                )
                .join('')
              if (tokens.length == 1) {
                // Workaround for simple, non-generic types.
                return `{${jsoned}: {}}`
              }
              return `{${jsoned}}`
            }
            nodeToType(name, node) {
              if (name.charAt(name.length - 1) === '1') {
                name = name.slice(0, -1)
              }
              let typeParameters = Object.keys(node).map((key) =>
                this.nodeToType(key, node[key])
              )
              return new types_1.Type(name, typeParameters)
            }
          }
          exports.TypeExpressionParser = TypeExpressionParser
        },
        { '../../errors': 66, './types': 145, 'json-duplicate-key-handle': 22 },
      ],
      144: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TypeMapper = void 0
          const errors = __importStar(require('../../errors'))
          const address_1 = require('./address')
          const algebraic_1 = require('./algebraic')
          const boolean_1 = require('./boolean')
          const bytes_1 = require('./bytes')
          const codeMetadata_1 = require('./codeMetadata')
          const composite_1 = require('./composite')
          const enum_1 = require('./enum')
          const fields_1 = require('./fields')
          const generic_1 = require('./generic')
          const genericArray_1 = require('./genericArray')
          const h256_1 = require('./h256')
          const nothing_1 = require('./nothing')
          const numerical_1 = require('./numerical')
          const string_1 = require('./string')
          const struct_1 = require('./struct')
          const tokenIdentifier_1 = require('./tokenIdentifier')
          const tuple_1 = require('./tuple')
          const variadic_1 = require('./variadic')
          class TypeMapper {
            constructor(learnedTypes = []) {
              this.openTypesFactories = new Map([
                [
                  'Option',
                  (...typeParameters) =>
                    new generic_1.OptionType(typeParameters[0]),
                ],
                [
                  'List',
                  (...typeParameters) =>
                    new generic_1.ListType(typeParameters[0]),
                ],
                // For the following open generics, we use a slightly different typing than the one defined by mx-sdk-rs (temporary workaround).
                [
                  'VarArgs',
                  (...typeParameters) =>
                    new variadic_1.VariadicType(typeParameters[0]),
                ],
                [
                  'MultiResultVec',
                  (...typeParameters) =>
                    new variadic_1.VariadicType(typeParameters[0]),
                ],
                [
                  'variadic',
                  (...typeParameters) =>
                    new variadic_1.VariadicType(typeParameters[0]),
                ],
                [
                  'counted-variadic',
                  (...typeParameters) =>
                    new variadic_1.VariadicType(typeParameters[0], true),
                ],
                [
                  'OptionalArg',
                  (...typeParameters) =>
                    new algebraic_1.OptionalType(typeParameters[0]),
                ],
                [
                  'optional',
                  (...typeParameters) =>
                    new algebraic_1.OptionalType(typeParameters[0]),
                ],
                [
                  'OptionalResult',
                  (...typeParameters) =>
                    new algebraic_1.OptionalType(typeParameters[0]),
                ],
                [
                  'multi',
                  (...typeParameters) =>
                    new composite_1.CompositeType(...typeParameters),
                ],
                [
                  'MultiArg',
                  (...typeParameters) =>
                    new composite_1.CompositeType(...typeParameters),
                ],
                [
                  'MultiResult',
                  (...typeParameters) =>
                    new composite_1.CompositeType(...typeParameters),
                ],
                [
                  'multi',
                  (...typeParameters) =>
                    new composite_1.CompositeType(...typeParameters),
                ],
                // Perhaps we can adjust the ABI generator to only output "tuple", instead of "tupleN"?
                [
                  'tuple',
                  (...typeParameters) =>
                    new tuple_1.TupleType(...typeParameters),
                ],
                [
                  'tuple2',
                  (...typeParameters) =>
                    new tuple_1.TupleType(...typeParameters),
                ],
                [
                  'tuple3',
                  (...typeParameters) =>
                    new tuple_1.TupleType(...typeParameters),
                ],
                [
                  'tuple4',
                  (...typeParameters) =>
                    new tuple_1.TupleType(...typeParameters),
                ],
                [
                  'tuple5',
                  (...typeParameters) =>
                    new tuple_1.TupleType(...typeParameters),
                ],
                [
                  'tuple6',
                  (...typeParameters) =>
                    new tuple_1.TupleType(...typeParameters),
                ],
                [
                  'tuple7',
                  (...typeParameters) =>
                    new tuple_1.TupleType(...typeParameters),
                ],
                [
                  'tuple8',
                  (...typeParameters) =>
                    new tuple_1.TupleType(...typeParameters),
                ],
                // Known-length arrays.
                // TODO: Handle these in typeExpressionParser!
                [
                  'array2',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(2, typeParameters[0]),
                ],
                [
                  'array8',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(8, typeParameters[0]),
                ],
                [
                  'array16',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(16, typeParameters[0]),
                ],
                [
                  'array20',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(20, typeParameters[0]),
                ],
                [
                  'array32',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(32, typeParameters[0]),
                ],
                [
                  'array46',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(46, typeParameters[0]),
                ],
                [
                  'array48',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(48, typeParameters[0]),
                ],
                [
                  'array64',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(64, typeParameters[0]),
                ],
                [
                  'array128',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(128, typeParameters[0]),
                ],
                [
                  'array256',
                  (...typeParameters) =>
                    new genericArray_1.ArrayVecType(256, typeParameters[0]),
                ],
              ])
              // For closed types, we hold actual type instances instead of type constructors / factories (no type parameters needed).
              this.closedTypesMap = new Map([
                ['u8', new numerical_1.U8Type()],
                ['u16', new numerical_1.U16Type()],
                ['u32', new numerical_1.U32Type()],
                ['u64', new numerical_1.U64Type()],
                ['U64', new numerical_1.U64Type()],
                ['BigUint', new numerical_1.BigUIntType()],
                ['i8', new numerical_1.I8Type()],
                ['i16', new numerical_1.I16Type()],
                ['i32', new numerical_1.I32Type()],
                ['i64', new numerical_1.I64Type()],
                ['Bigint', new numerical_1.BigIntType()],
                ['BigInt', new numerical_1.BigIntType()],
                ['bool', new boolean_1.BooleanType()],
                ['bytes', new bytes_1.BytesType()],
                ['Address', new address_1.AddressType()],
                ['H256', new h256_1.H256Type()],
                ['utf-8 string', new string_1.StringType()],
                [
                  'TokenIdentifier',
                  new tokenIdentifier_1.TokenIdentifierType(),
                ],
                [
                  'EgldOrEsdtTokenIdentifier',
                  new tokenIdentifier_1.TokenIdentifierType(),
                ],
                ['CodeMetadata', new codeMetadata_1.CodeMetadataType()],
                ['nothing', new nothing_1.NothingType()],
                ['AsyncCall', new nothing_1.NothingType()],
              ])
              this.learnedTypesMap = new Map()
              // Boostrap from previously learned types, if any.
              for (const type of learnedTypes) {
                this.learnedTypesMap.set(type.getName(), type)
              }
            }
            /**
             * Maps a "raw type" object to a "known (specific) type" object.
             * In the process, it also learns the new type.
             * Can only map types if their dependencies were previously learned (through mapping).
             */
            mapType(type) {
              let mappedType = this.mapTypeRecursively(type)
              if (mappedType) {
                // We do not learn generic types (that also have type parameters),
                // we only learn closed, non-generic types.
                // Reason: in the ABI, generic types are unnamed.
                // E.g.: two occurrences of List<Foobar> aren't recognized as a single type (simplification).
                if (!mappedType.isGenericType()) {
                  this.learnType(mappedType)
                }
                return mappedType
              }
              throw new errors.ErrTypingSystem(
                `Cannot map the type "${type.getName()}" to a known type`
              )
            }
            mapTypeRecursively(type) {
              let isGeneric = type.isGenericType()
              let previouslyLearnedType = this.learnedTypesMap.get(
                type.getName()
              )
              if (previouslyLearnedType) {
                return previouslyLearnedType
              }
              let knownClosedType = this.closedTypesMap.get(type.getName())
              if (knownClosedType) {
                return knownClosedType
              }
              if (type.hasExactClass(enum_1.EnumType.ClassName)) {
                // This will call mapType() recursively, for all the enum variant fields.
                return this.mapEnumType(type)
              }
              if (type.hasExactClass(struct_1.StructType.ClassName)) {
                // This will call mapType() recursively, for all the struct's fields.
                return this.mapStructType(type)
              }
              if (isGeneric) {
                // This will call mapType() recursively, for all the type parameters.
                return this.mapGenericType(type)
              }
              return null
            }
            learnType(type) {
              this.learnedTypesMap.delete(type.getName())
              this.learnedTypesMap.set(type.getName(), type)
            }
            mapStructType(type) {
              let mappedFields = this.mappedFields(type.getFieldsDefinitions())
              let mappedStruct = new struct_1.StructType(
                type.getName(),
                mappedFields
              )
              return mappedStruct
            }
            mapEnumType(type) {
              let variants = type.variants.map(
                (variant) =>
                  new enum_1.EnumVariantDefinition(
                    variant.name,
                    variant.discriminant,
                    this.mappedFields(variant.getFieldsDefinitions())
                  )
              )
              let mappedEnum = new enum_1.EnumType(type.getName(), variants)
              return mappedEnum
            }
            mappedFields(definitions) {
              return definitions.map(
                (definition) =>
                  new fields_1.FieldDefinition(
                    definition.name,
                    definition.description,
                    this.mapType(definition.type)
                  )
              )
            }
            mapGenericType(type) {
              let typeParameters = type.getTypeParameters()
              let mappedTypeParameters = typeParameters.map((item) =>
                this.mapType(item)
              )
              let factory = this.openTypesFactories.get(type.getName())
              if (!factory) {
                throw new errors.ErrTypingSystem(
                  `Cannot map the generic type "${type.getName()}" to a known type`
                )
              }
              return factory(...mappedTypeParameters)
            }
          }
          exports.TypeMapper = TypeMapper
        },
        {
          '../../errors': 66,
          './address': 120,
          './algebraic': 121,
          './boolean': 122,
          './bytes': 123,
          './codeMetadata': 124,
          './composite': 126,
          './enum': 128,
          './fields': 131,
          './generic': 132,
          './genericArray': 133,
          './h256': 134,
          './nothing': 137,
          './numerical': 138,
          './string': 139,
          './struct': 140,
          './tokenIdentifier': 141,
          './tuple': 142,
          './variadic': 146,
        },
      ],
      145: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.NullType =
            exports.TypePlaceholder =
            exports.isTyped =
            exports.PrimitiveValue =
            exports.TypedValue =
            exports.CustomType =
            exports.PrimitiveType =
            exports.TypeCardinality =
            exports.Type =
              void 0
          const reflection_1 = require('../../reflection')
          const utils_1 = require('../../utils')
          /**
           * An abstraction that represents a Type. Handles both generic and non-generic types.
           * Once instantiated as a Type, a generic type is "closed" (as opposed to "open").
           */
          class Type {
            constructor(
              name,
              typeParameters = [],
              cardinality = TypeCardinality.fixed(1)
            ) {
              utils_1.guardValueIsSet('name', name)
              this.name = name
              this.typeParameters = typeParameters
              this.cardinality = cardinality
            }
            getName() {
              return this.name
            }
            getClassName() {
              return Type.ClassName
            }
            getClassHierarchy() {
              let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(
                this,
                (prototype) => prototype.belongsToTypesystem
              )
              let classNames = prototypes
                .map((prototype) => prototype.getClassName())
                .reverse()
              return classNames
            }
            /**
             * Gets the fully qualified name of the type, to allow for better (efficient and non-ambiguous) type comparison within the custom typesystem.
             */
            getFullyQualifiedName() {
              let joinedTypeParameters = this.getTypeParameters()
                .map((type) => type.getFullyQualifiedName())
                .join(', ')
              return this.isGenericType()
                ? `multiversx:types:${this.getName()}<${joinedTypeParameters}>`
                : `multiversx:types:${this.getName()}`
            }
            hasExactClass(className) {
              return this.getClassName() == className
            }
            hasClassOrSuperclass(className) {
              let hierarchy = this.getClassHierarchy()
              return hierarchy.includes(className)
            }
            getTypeParameters() {
              return this.typeParameters
            }
            isGenericType() {
              return this.typeParameters.length > 0
            }
            getFirstTypeParameter() {
              utils_1.guardTrue(
                this.typeParameters.length > 0,
                'type parameters length > 0'
              )
              return this.typeParameters[0]
            }
            /**
             * Generates type expressions similar to mx-sdk-rs.
             */
            toString() {
              let typeParameters = this.getTypeParameters()
                .map((type) => type.toString())
                .join(', ')
              let typeParametersExpression = typeParameters
                ? `<${typeParameters}>`
                : ''
              return `${this.name}${typeParametersExpression}`
            }
            equals(other) {
              return Type.equals(this, other)
            }
            static equals(a, b) {
              return a.getFullyQualifiedName() == b.getFullyQualifiedName()
            }
            static equalsMany(a, b) {
              return a.every((type, i) => type.equals(b[i]))
            }
            static isAssignableFromMany(a, b) {
              return a.every((type, i) => type.isAssignableFrom(b[i]))
            }
            differs(other) {
              return !this.equals(other)
            }
            valueOf() {
              return this.name
            }
            /**
             * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom
             * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).
             *
             * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.
             * For example, Option<u32> is assignable from Option<?>.
             * For more details, see the implementation of {@link OptionType} and @{@link OptionalType}.
             *
             * Also see:
             *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
             *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance
             */
            isAssignableFrom(other) {
              let invariantTypeParameters = Type.equalsMany(
                this.getTypeParameters(),
                other.getTypeParameters()
              )
              if (!invariantTypeParameters) {
                return false
              }
              let fullyQualifiedNameOfThis = this.getFullyQualifiedName()
              let fullyQualifiedNamesInHierarchyOfOther =
                Type.getFullyQualifiedNamesInHierarchy(other)
              if (
                fullyQualifiedNamesInHierarchyOfOther.includes(
                  fullyQualifiedNameOfThis
                )
              ) {
                return true
              }
              return other.hasClassOrSuperclass(this.getClassName())
            }
            static getFullyQualifiedNamesInHierarchy(type) {
              let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(
                type,
                (prototype) => prototype.belongsToTypesystem
              )
              let fullyQualifiedNames = prototypes.map((prototype) =>
                prototype.getFullyQualifiedName.call(type)
              )
              return fullyQualifiedNames
            }
            getNamesOfDependencies() {
              const dependencies = []
              for (const type of this.typeParameters) {
                dependencies.push(type.getName())
                dependencies.push(...type.getNamesOfDependencies())
              }
              return [...new Set(dependencies)]
            }
            /**
             * Converts the account to a pretty, plain JavaScript object.
             */
            toJSON() {
              return {
                name: this.name,
                typeParameters: this.typeParameters.map((item) =>
                  item.toJSON()
                ),
              }
            }
            getCardinality() {
              return this.cardinality
            }
            /**
             * A special marker for types within the custom typesystem.
             */
            belongsToTypesystem() {}
          }
          exports.Type = Type
          Type.ClassName = 'Type'
          /**
           * TODO: Simplify this class, keep only what is needed.
           *
           * An abstraction for defining and operating with the cardinality of a (composite or simple) type.
           *
           * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].
           * Composite types (not directly encodable) do not follow this constraint. For example:
           *  - VarArgs: [lower = 0, upper = *]
           *  - OptionalResult: [lower = 0, upper = 1]
           */
          class TypeCardinality {
            constructor(lowerBound, upperBound) {
              this.lowerBound = lowerBound
              this.upperBound = upperBound
            }
            static fixed(value) {
              return new TypeCardinality(value, value)
            }
            static variable(value) {
              return new TypeCardinality(0, value)
            }
            isSingular() {
              return this.lowerBound == 1 && this.upperBound == 1
            }
            isSingularOrNone() {
              return this.lowerBound == 0 && this.upperBound == 1
            }
            isComposite() {
              return this.upperBound != 1
            }
            isFixed() {
              return this.lowerBound == this.upperBound
            }
            getLowerBound() {
              return this.lowerBound
            }
            getUpperBound() {
              return this.upperBound || TypeCardinality.MaxCardinality
            }
          }
          exports.TypeCardinality = TypeCardinality
          /**
           * An arbitrarily chosen, reasonably large number.
           */
          TypeCardinality.MaxCardinality = 4096
          class PrimitiveType extends Type {
            constructor(name) {
              super(name)
            }
            getClassName() {
              return PrimitiveType.ClassName
            }
          }
          exports.PrimitiveType = PrimitiveType
          PrimitiveType.ClassName = 'PrimitiveType'
          class CustomType extends Type {
            getClassName() {
              return CustomType.ClassName
            }
          }
          exports.CustomType = CustomType
          CustomType.ClassName = 'CustomType'
          class TypedValue {
            constructor(type) {
              this.type = type
            }
            getClassName() {
              return TypedValue.ClassName
            }
            getClassHierarchy() {
              let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(
                this,
                (prototype) => prototype.belongsToTypesystem
              )
              let classNames = prototypes
                .map((prototype) => prototype.getClassName())
                .reverse()
              return classNames
            }
            getType() {
              return this.type
            }
            hasExactClass(className) {
              return this.getClassName() == className
            }
            hasClassOrSuperclass(className) {
              let hierarchy = this.getClassHierarchy()
              return hierarchy.includes(className)
            }
            /**
             * A special marker for values within the custom typesystem.
             */
            belongsToTypesystem() {}
          }
          exports.TypedValue = TypedValue
          TypedValue.ClassName = 'TypedValue'
          class PrimitiveValue extends TypedValue {
            constructor(type) {
              super(type)
            }
            getClassName() {
              return PrimitiveValue.ClassName
            }
          }
          exports.PrimitiveValue = PrimitiveValue
          PrimitiveValue.ClassName = 'PrimitiveValue'
          function isTyped(value) {
            return value.belongsToTypesystem !== undefined
          }
          exports.isTyped = isTyped
          class TypePlaceholder extends Type {
            constructor() {
              super('...')
            }
            getClassName() {
              return TypePlaceholder.ClassName
            }
          }
          exports.TypePlaceholder = TypePlaceholder
          TypePlaceholder.ClassName = 'TypePlaceholder'
          class NullType extends Type {
            constructor() {
              super('?')
            }
            getClassName() {
              return NullType.ClassName
            }
          }
          exports.NullType = NullType
          NullType.ClassName = 'NullType'
        },
        { '../../reflection': 78, '../../utils': 158 },
      ],
      146: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.VariadicValue =
            exports.CountedVariadicType =
            exports.VariadicType =
              void 0
          const types_1 = require('./types')
          class VariadicType extends types_1.Type {
            constructor(typeParameter, isCounted = false) {
              super(
                'Variadic',
                [typeParameter],
                types_1.TypeCardinality.variable()
              )
              this.isCounted = isCounted
            }
            getClassName() {
              return VariadicType.ClassName
            }
          }
          exports.VariadicType = VariadicType
          VariadicType.ClassName = 'VariadicType'
          class CountedVariadicType extends types_1.Type {
            constructor(typeParameter) {
              super(
                'Variadic',
                [typeParameter],
                types_1.TypeCardinality.variable()
              )
            }
            getClassName() {
              return VariadicType.ClassName
            }
          }
          exports.CountedVariadicType = CountedVariadicType
          CountedVariadicType.ClassName = 'VariadicType'
          /**
           * An abstraction that represents a sequence of values held under the umbrella of a variadic input / output parameter.
           *
           * Since at the time of constructing input parameters or decoding output parameters, the length is known,
           * this TypedValue behaves similar to a List.
           */
          class VariadicValue extends types_1.TypedValue {
            /**
             *
             * @param type the type of this TypedValue (an instance of VariadicType), not the type parameter of the VariadicType
             * @param items the items, having the type type.getFirstTypeParameter()
             */
            constructor(type, items) {
              super(type)
              // TODO: assert items are of type type.getFirstTypeParameter()
              this.items = items
            }
            getClassName() {
              return VariadicValue.ClassName
            }
            static fromItems(...items) {
              return this.createFromItems(items, false)
            }
            static fromItemsCounted(...items) {
              return this.createFromItems(items, true)
            }
            static createFromItems(items, isCounted) {
              if (items.length == 0) {
                return new VariadicValue(
                  new VariadicType(new types_1.TypePlaceholder(), isCounted),
                  []
                )
              }
              const typeParameter = items[0].getType()
              return new VariadicValue(
                new VariadicType(typeParameter, isCounted),
                items
              )
            }
            getItems() {
              return this.items
            }
            valueOf() {
              return this.items.map((item) => item.valueOf())
            }
            equals(other) {
              if (this.getType().differs(other.getType())) {
                return false
              }
              for (let i = 0; i < this.items.length; i++) {
                let selfItem = this.items[i]
                let otherItem = other.items[i]
                if (!selfItem.equals(otherItem)) {
                  return false
                }
              }
              return true
            }
          }
          exports.VariadicValue = VariadicValue
          VariadicValue.ClassName = 'VariadicValue'
        },
        { './types': 145 },
      ],
      147: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      Object.defineProperty(o, k2, {
                        enumerable: true,
                        get: function () {
                          return m[k]
                        },
                      })
                    }
                  : function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      o[k2] = m[k]
                    })
              var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function (o, v) {
                      Object.defineProperty(o, 'default', {
                        enumerable: true,
                        value: v,
                      })
                    }
                  : function (o, v) {
                      o['default'] = v
                    })
              var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                  if (mod && mod.__esModule) return mod
                  var result = {}
                  if (mod != null)
                    for (var k in mod)
                      if (
                        k !== 'default' &&
                        Object.prototype.hasOwnProperty.call(mod, k)
                      )
                        __createBinding(result, mod, k)
                  __setModuleDefault(result, mod)
                  return result
                }
              var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule ? mod : { default: mod }
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.addressToHex =
                exports.bufferToHex =
                exports.utf8ToHex =
                exports.bigIntToHex =
                exports.bigIntToBuffer =
                exports.bufferToBigInt =
                exports.stringToBuffer =
                  void 0
              const bignumber_js_1 = __importDefault(require('bignumber.js'))
              const address_1 = require('../address')
              const contractsCodecUtils = __importStar(
                require('../smartcontracts/codec/utils')
              )
              const codecUtils = __importStar(require('../utils.codec'))
              function stringToBuffer(value) {
                return Buffer.from(value)
              }
              exports.stringToBuffer = stringToBuffer
              function bufferToBigInt(buffer) {
                if (buffer.length == 0) {
                  return new bignumber_js_1.default(0)
                }
                return contractsCodecUtils.bufferToBigInt(buffer)
              }
              exports.bufferToBigInt = bufferToBigInt
              function bigIntToBuffer(value) {
                if (value == 0) {
                  return Buffer.from([])
                }
                return contractsCodecUtils.bigIntToBuffer(value)
              }
              exports.bigIntToBuffer = bigIntToBuffer
              function bigIntToHex(value) {
                if (value == 0) {
                  return ''
                }
                return contractsCodecUtils.getHexMagnitudeOfBigInt(value)
              }
              exports.bigIntToHex = bigIntToHex
              function utf8ToHex(value) {
                const hex = Buffer.from(value).toString('hex')
                return codecUtils.zeroPadStringIfOddLength(hex)
              }
              exports.utf8ToHex = utf8ToHex
              function bufferToHex(value) {
                const hex = value.toString('hex')
                return codecUtils.zeroPadStringIfOddLength(hex)
              }
              exports.bufferToHex = bufferToHex
              function addressToHex(address) {
                const buffer = address_1.Address.fromBech32(
                  address.toString()
                ).pubkey()
                return buffer.toString('hex')
              }
              exports.addressToHex = addressToHex
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          '../address': 62,
          '../smartcontracts/codec/utils': 107,
          '../utils.codec': 157,
          'bignumber.js': 13,
          buffer: 18,
        },
      ],
      148: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __exportStar =
            (this && this.__exportStar) ||
            function (m, exports) {
              for (var p in m)
                if (
                  p !== 'default' &&
                  !Object.prototype.hasOwnProperty.call(exports, p)
                )
                  __createBinding(exports, m, p)
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          __exportStar(require('./tokenOperationsFactory'), exports)
          __exportStar(require('./tokenOperationsFactoryConfig'), exports)
          __exportStar(require('./tokenOperationsOutcomeParser'), exports)
        },
        {
          './tokenOperationsFactory': 149,
          './tokenOperationsFactoryConfig': 150,
          './tokenOperationsOutcomeParser': 151,
        },
      ],
      149: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TokenOperationsFactory = void 0
          const constants_1 = require('../constants')
          const logger_1 = require('../logger')
          const networkParams_1 = require('../networkParams')
          const transaction_1 = require('../transaction')
          const transactionPayload_1 = require('../transactionPayload')
          const codec_1 = require('./codec')
          class TokenOperationsFactory {
            constructor(config) {
              this.config = config
              this.trueAsHex = codec_1.utf8ToHex('true')
              this.falseAsHex = codec_1.utf8ToHex('false')
            }
            issueFungible(args) {
              this.notifyAboutUnsettingBurnRoleGlobally()
              const parts = [
                'issue',
                codec_1.utf8ToHex(args.tokenName),
                codec_1.utf8ToHex(args.tokenTicker),
                codec_1.bigIntToHex(args.initialSupply),
                codec_1.bigIntToHex(args.numDecimals),
                codec_1.utf8ToHex('canFreeze'),
                args.canFreeze ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canWipe'),
                args.canWipe ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canPause'),
                args.canPause ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canChangeOwner'),
                args.canChangeOwner ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canUpgrade'),
                args.canUpgrade ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canAddSpecialRoles'),
                args.canAddSpecialRoles ? this.trueAsHex : this.falseAsHex,
              ]
              return this.createTransaction({
                sender: args.issuer,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                value: this.config.issueCost,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitIssue,
                dataParts: parts,
              })
            }
            notifyAboutUnsettingBurnRoleGlobally() {
              logger_1.Logger.info(`
==========
IMPORTANT!
==========
You are about to issue (register) a new token. This will set the role "ESDTRoleBurnForAll" (globally).
Once the token is registered, you can unset this role by calling "unsetBurnRoleGlobally" (in a separate transaction).`)
            }
            issueSemiFungible(args) {
              this.notifyAboutUnsettingBurnRoleGlobally()
              const parts = [
                'issueSemiFungible',
                codec_1.utf8ToHex(args.tokenName),
                codec_1.utf8ToHex(args.tokenTicker),
                codec_1.utf8ToHex('canFreeze'),
                args.canFreeze ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canWipe'),
                args.canWipe ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canPause'),
                args.canPause ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canTransferNFTCreateRole'),
                args.canTransferNFTCreateRole
                  ? this.trueAsHex
                  : this.falseAsHex,
                codec_1.utf8ToHex('canChangeOwner'),
                args.canChangeOwner ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canUpgrade'),
                args.canUpgrade ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canAddSpecialRoles'),
                args.canAddSpecialRoles ? this.trueAsHex : this.falseAsHex,
              ]
              return this.createTransaction({
                sender: args.issuer,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                value: this.config.issueCost,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitIssue,
                dataParts: parts,
              })
            }
            issueNonFungible(args) {
              this.notifyAboutUnsettingBurnRoleGlobally()
              const parts = [
                'issueNonFungible',
                codec_1.utf8ToHex(args.tokenName),
                codec_1.utf8ToHex(args.tokenTicker),
                codec_1.utf8ToHex('canFreeze'),
                args.canFreeze ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canWipe'),
                args.canWipe ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canPause'),
                args.canPause ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canTransferNFTCreateRole'),
                args.canTransferNFTCreateRole
                  ? this.trueAsHex
                  : this.falseAsHex,
                codec_1.utf8ToHex('canChangeOwner'),
                args.canChangeOwner ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canUpgrade'),
                args.canUpgrade ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canAddSpecialRoles'),
                args.canAddSpecialRoles ? this.trueAsHex : this.falseAsHex,
              ]
              return this.createTransaction({
                sender: args.issuer,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                value: this.config.issueCost,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitIssue,
                dataParts: parts,
              })
            }
            registerMetaESDT(args) {
              this.notifyAboutUnsettingBurnRoleGlobally()
              const parts = [
                'registerMetaESDT',
                codec_1.utf8ToHex(args.tokenName),
                codec_1.utf8ToHex(args.tokenTicker),
                codec_1.bigIntToHex(args.numDecimals),
                codec_1.utf8ToHex('canFreeze'),
                args.canFreeze ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canWipe'),
                args.canWipe ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canPause'),
                args.canPause ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canTransferNFTCreateRole'),
                args.canTransferNFTCreateRole
                  ? this.trueAsHex
                  : this.falseAsHex,
                codec_1.utf8ToHex('canChangeOwner'),
                args.canChangeOwner ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canUpgrade'),
                args.canUpgrade ? this.trueAsHex : this.falseAsHex,
                codec_1.utf8ToHex('canAddSpecialRoles'),
                args.canAddSpecialRoles ? this.trueAsHex : this.falseAsHex,
              ]
              return this.createTransaction({
                sender: args.issuer,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                value: this.config.issueCost,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitIssue,
                dataParts: parts,
              })
            }
            registerAndSetAllRoles(args) {
              this.notifyAboutUnsettingBurnRoleGlobally()
              const parts = [
                'registerAndSetAllRoles',
                codec_1.utf8ToHex(args.tokenName),
                codec_1.utf8ToHex(args.tokenTicker),
                codec_1.utf8ToHex(args.tokenType),
                codec_1.bigIntToHex(args.numDecimals),
              ]
              return this.createTransaction({
                sender: args.issuer,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                value: this.config.issueCost,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitIssue,
                dataParts: parts,
              })
            }
            setBurnRoleGlobally(args) {
              const parts = [
                'setBurnRoleGlobally',
                codec_1.utf8ToHex(args.tokenIdentifier),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitToggleBurnRoleGlobally,
                dataParts: parts,
              })
            }
            unsetBurnRoleGlobally(args) {
              const parts = [
                'unsetBurnRoleGlobally',
                codec_1.utf8ToHex(args.tokenIdentifier),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitToggleBurnRoleGlobally,
                dataParts: parts,
              })
            }
            setSpecialRoleOnFungible(args) {
              const parts = [
                'setSpecialRole',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.addressToHex(args.user),
                ...(args.addRoleLocalMint
                  ? [codec_1.utf8ToHex('ESDTRoleLocalMint')]
                  : []),
                ...(args.addRoleLocalBurn
                  ? [codec_1.utf8ToHex('ESDTRoleLocalBurn')]
                  : []),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitSetSpecialRole,
                dataParts: parts,
              })
            }
            setSpecialRoleOnSemiFungible(args) {
              const parts = [
                'setSpecialRole',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.addressToHex(args.user),
                ...(args.addRoleNFTCreate
                  ? [codec_1.utf8ToHex('ESDTRoleNFTCreate')]
                  : []),
                ...(args.addRoleNFTBurn
                  ? [codec_1.utf8ToHex('ESDTRoleNFTBurn')]
                  : []),
                ...(args.addRoleNFTAddQuantity
                  ? [codec_1.utf8ToHex('ESDTRoleNFTAddQuantity')]
                  : []),
                ...(args.addRoleESDTTransferRole
                  ? [codec_1.utf8ToHex('ESDTTransferRole')]
                  : []),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitSetSpecialRole,
                dataParts: parts,
              })
            }
            setSpecialRoleOnMetaESDT(args) {
              return this.setSpecialRoleOnSemiFungible(args)
            }
            setSpecialRoleOnNonFungible(args) {
              const parts = [
                'setSpecialRole',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.addressToHex(args.user),
                ...(args.addRoleNFTCreate
                  ? [codec_1.utf8ToHex('ESDTRoleNFTCreate')]
                  : []),
                ...(args.addRoleNFTBurn
                  ? [codec_1.utf8ToHex('ESDTRoleNFTBurn')]
                  : []),
                ...(args.addRoleNFTUpdateAttributes
                  ? [codec_1.utf8ToHex('ESDTRoleNFTUpdateAttributes')]
                  : []),
                ...(args.addRoleNFTAddURI
                  ? [codec_1.utf8ToHex('ESDTRoleNFTAddURI')]
                  : []),
                ...(args.addRoleESDTTransferRole
                  ? [codec_1.utf8ToHex('ESDTTransferRole')]
                  : []),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitSetSpecialRole,
                dataParts: parts,
              })
            }
            nftCreate(args) {
              const parts = [
                'ESDTNFTCreate',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.bigIntToHex(args.initialQuantity),
                codec_1.utf8ToHex(args.name),
                codec_1.bigIntToHex(args.royalties),
                codec_1.utf8ToHex(args.hash),
                codec_1.bufferToHex(args.attributes),
                ...args.uris.map(codec_1.utf8ToHex),
              ]
              // Note that the following is an approximation (a reasonable one):
              const nftData =
                args.name + args.hash + args.attributes + args.uris.join('')
              const storageGasLimit =
                nftData.length * this.config.gasLimitStorePerByte.valueOf()
              return this.createTransaction({
                sender: args.creator,
                receiver: args.creator,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit:
                  this.config.gasLimitESDTNFTCreate.valueOf() +
                  storageGasLimit.valueOf(),
                dataParts: parts,
              })
            }
            pause(args) {
              const parts = ['pause', codec_1.utf8ToHex(args.tokenIdentifier)]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitPausing,
                dataParts: parts,
              })
            }
            unpause(args) {
              const parts = ['unPause', codec_1.utf8ToHex(args.tokenIdentifier)]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitPausing,
                dataParts: parts,
              })
            }
            freeze(args) {
              const parts = [
                'freeze',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.addressToHex(args.user),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitFreezing,
                dataParts: parts,
              })
            }
            unfreeze(args) {
              const parts = [
                'unFreeze',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.addressToHex(args.user),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitFreezing,
                dataParts: parts,
              })
            }
            wipe(args) {
              const parts = [
                'wipe',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.addressToHex(args.user),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: this.config.esdtContractAddress,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitWiping,
                dataParts: parts,
              })
            }
            localMint(args) {
              const parts = [
                'ESDTLocalMint',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.bigIntToHex(args.supplyToMint),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: args.manager,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitESDTLocalMint,
                dataParts: parts,
              })
            }
            localBurn(args) {
              const parts = [
                'ESDTLocalBurn',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.bigIntToHex(args.supplyToBurn),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: args.manager,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitESDTLocalBurn,
                dataParts: parts,
              })
            }
            updateAttributes(args) {
              const parts = [
                'ESDTNFTUpdateAttributes',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.bigIntToHex(args.tokenNonce),
                codec_1.bufferToHex(args.attributes),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: args.manager,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitESDTNFTUpdateAttributes,
                dataParts: parts,
              })
            }
            addQuantity(args) {
              const parts = [
                'ESDTNFTAddQuantity',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.bigIntToHex(args.tokenNonce),
                codec_1.bigIntToHex(args.quantityToAdd),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: args.manager,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitESDTNFTAddQuantity,
                dataParts: parts,
              })
            }
            burnQuantity(args) {
              const parts = [
                'ESDTNFTBurn',
                codec_1.utf8ToHex(args.tokenIdentifier),
                codec_1.bigIntToHex(args.tokenNonce),
                codec_1.bigIntToHex(args.quantityToBurn),
              ]
              return this.createTransaction({
                sender: args.manager,
                receiver: args.manager,
                nonce: args.transactionNonce,
                gasPrice: args.gasPrice,
                gasLimitHint: args.gasLimit,
                executionGasLimit: this.config.gasLimitESDTNFTBurn,
                dataParts: parts,
              })
            }
            createTransaction({
              sender,
              receiver,
              nonce,
              value,
              gasPrice,
              gasLimitHint,
              executionGasLimit,
              dataParts,
            }) {
              const payload = this.buildTransactionPayload(dataParts)
              const gasLimit =
                gasLimitHint || this.computeGasLimit(payload, executionGasLimit)
              const version = new networkParams_1.TransactionVersion(
                constants_1.TRANSACTION_VERSION_DEFAULT
              )
              const options = new networkParams_1.TransactionOptions(
                constants_1.TRANSACTION_OPTIONS_DEFAULT
              )
              return new transaction_1.Transaction({
                chainID: this.config.chainID,
                sender: sender,
                receiver: receiver,
                gasLimit: gasLimit,
                gasPrice: gasPrice,
                nonce: nonce || 0,
                value: value || 0,
                data: payload,
                version: version,
                options: options,
              })
            }
            buildTransactionPayload(parts) {
              const data = parts.join(constants_1.ARGUMENTS_SEPARATOR)
              return new transactionPayload_1.TransactionPayload(data)
            }
            computeGasLimit(payload, executionGas) {
              const dataMovementGas =
                this.config.minGasLimit.valueOf() +
                this.config.gasLimitPerByte.valueOf() * payload.length()
              return dataMovementGas + executionGas.valueOf()
            }
          }
          exports.TokenOperationsFactory = TokenOperationsFactory
        },
        {
          '../constants': 65,
          '../logger': 73,
          '../networkParams': 74,
          '../transaction': 153,
          '../transactionPayload': 154,
          './codec': 147,
        },
      ],
      150: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TokenOperationsFactoryConfig = void 0
          const address_1 = require('../address')
          class TokenOperationsFactoryConfig {
            constructor(chainID) {
              this.minGasPrice = 1000000000
              this.minGasLimit = 50000
              this.gasLimitPerByte = 1500
              this.gasLimitIssue = 60000000
              this.gasLimitToggleBurnRoleGlobally = 60000000
              this.gasLimitESDTLocalMint = 300000
              this.gasLimitESDTLocalBurn = 300000
              this.gasLimitSetSpecialRole = 60000000
              this.gasLimitPausing = 60000000
              this.gasLimitFreezing = 60000000
              this.gasLimitWiping = 60000000
              this.gasLimitESDTNFTCreate = 3000000
              this.gasLimitESDTNFTUpdateAttributes = 1000000
              this.gasLimitESDTNFTAddQuantity = 1000000
              this.gasLimitESDTNFTBurn = 1000000
              this.gasLimitStorePerByte = 50000
              this.issueCost = '50000000000000000'
              this.esdtContractAddress = address_1.Address.fromBech32(
                'erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u'
              )
              this.chainID = chainID
            }
          }
          exports.TokenOperationsFactoryConfig = TokenOperationsFactoryConfig
        },
        { '../address': 62 },
      ],
      151: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.TokenOperationsOutcomeParser = void 0
              const address_1 = require('../address')
              const errors_1 = require('../errors')
              const codec_1 = require('./codec')
              class TokenOperationsOutcomeParser {
                parseIssueFungible(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'issue'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  return { tokenIdentifier: tokenIdentifier }
                }
                parseIssueNonFungible(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'issueNonFungible'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  return { tokenIdentifier: tokenIdentifier }
                }
                parseIssueSemiFungible(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'issueSemiFungible'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  return { tokenIdentifier: tokenIdentifier }
                }
                parseRegisterMetaESDT(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'registerMetaESDT'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  return { tokenIdentifier: tokenIdentifier }
                }
                parseRegisterAndSetAllRoles(transaction) {
                  this.ensureNoError(transaction)
                  const eventRegister = this.findSingleEventByIdentifier(
                    transaction,
                    'registerAndSetAllRoles'
                  )
                  const tokenIdentifier =
                    this.extractTokenIdentifier(eventRegister)
                  const eventSetRole = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTSetRole'
                  )
                  const roles = eventSetRole.topics
                    .slice(3)
                    .map((topic) => topic.valueOf().toString())
                  return { tokenIdentifier, roles }
                }
                parseSetBurnRoleGlobally(transaction) {
                  this.ensureNoError(transaction)
                  return {}
                }
                parseUnsetBurnRoleGlobally(transaction) {
                  this.ensureNoError(transaction)
                  return {}
                }
                parseSetSpecialRole(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTSetRole'
                  )
                  const userAddress = event.address.toString()
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const roles = event.topics
                    .slice(3)
                    .map((topic) => topic.valueOf().toString())
                  return { userAddress, tokenIdentifier, roles }
                }
                parseNFTCreate(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTNFTCreate'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const initialQuantity = this.extractAmount(event)
                  return { tokenIdentifier, nonce, initialQuantity }
                }
                parseLocalMint(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTLocalMint'
                  )
                  const userAddress = event.address.toString()
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const mintedSupply = this.extractAmount(event)
                  return { userAddress, tokenIdentifier, nonce, mintedSupply }
                }
                parseLocalBurn(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTLocalBurn'
                  )
                  const userAddress = event.address.toString()
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const burntSupply = this.extractAmount(event)
                  return { userAddress, tokenIdentifier, nonce, burntSupply }
                }
                parsePause(transaction) {
                  this.ensureNoError(transaction)
                  const _ = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTPause'
                  )
                  return {}
                }
                parseUnpause(transaction) {
                  this.ensureNoError(transaction)
                  const _ = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTUnPause'
                  )
                  return {}
                }
                parseFreeze(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTFreeze'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const balance = this.extractAmount(event)
                  const userAddress = this.extractAddress(event)
                  return { userAddress, tokenIdentifier, nonce, balance }
                }
                parseUnfreeze(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTUnFreeze'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const balance = this.extractAmount(event)
                  const userAddress = this.extractAddress(event)
                  return { userAddress, tokenIdentifier, nonce, balance }
                }
                parseWipe(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTWipe'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const balance = this.extractAmount(event)
                  const userAddress = this.extractAddress(event)
                  return { userAddress, tokenIdentifier, nonce, balance }
                }
                parseUpdateAttributes(transaction) {
                  var _a
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTNFTUpdateAttributes'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const attributes =
                    (_a = event.topics[3]) === null || _a === void 0
                      ? void 0
                      : _a.valueOf()
                  return { tokenIdentifier, nonce, attributes }
                }
                parseAddQuantity(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTNFTAddQuantity'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const addedQuantity = this.extractAmount(event)
                  return { tokenIdentifier, nonce, addedQuantity }
                }
                parseBurnQuantity(transaction) {
                  this.ensureNoError(transaction)
                  const event = this.findSingleEventByIdentifier(
                    transaction,
                    'ESDTNFTBurn'
                  )
                  const tokenIdentifier = this.extractTokenIdentifier(event)
                  const nonce = this.extractNonce(event)
                  const burntQuantity = this.extractAmount(event)
                  return { tokenIdentifier, nonce, burntQuantity }
                }
                ensureNoError(transaction) {
                  var _a
                  for (const event of transaction.logs.events) {
                    if (event.identifier == 'signalError') {
                      const data = Buffer.from(
                        event.data.substring(1),
                        'hex'
                      ).toString()
                      const message =
                        (_a = event.topics[1]) === null || _a === void 0
                          ? void 0
                          : _a.valueOf().toString()
                      throw new errors_1.ErrCannotParseTransactionOutcome(
                        transaction.hash,
                        `encountered signalError: ${message} (${data})`
                      )
                    }
                  }
                }
                findSingleEventByIdentifier(transaction, identifier) {
                  const events = this.gatherAllEvents(transaction).filter(
                    (event) => event.identifier == identifier
                  )
                  if (events.length == 0) {
                    throw new errors_1.ErrCannotParseTransactionOutcome(
                      transaction.hash,
                      `cannot find event of type ${identifier}`
                    )
                  }
                  if (events.length > 1) {
                    throw new errors_1.ErrCannotParseTransactionOutcome(
                      transaction.hash,
                      `more than one event of type ${identifier}`
                    )
                  }
                  return events[0]
                }
                gatherAllEvents(transaction) {
                  const allEvents = []
                  allEvents.push(...transaction.logs.events)
                  for (const item of transaction.contractResults.items) {
                    allEvents.push(...item.logs.events)
                  }
                  return allEvents
                }
                extractTokenIdentifier(event) {
                  var _a
                  return (_a = event.topics[0]) === null || _a === void 0
                    ? void 0
                    : _a.valueOf().toString()
                }
                extractNonce(event) {
                  var _a
                  return codec_1
                    .bufferToBigInt(
                      (_a = event.topics[1]) === null || _a === void 0
                        ? void 0
                        : _a.valueOf()
                    )
                    .toFixed(0)
                }
                extractAmount(event) {
                  var _a
                  return codec_1
                    .bufferToBigInt(
                      (_a = event.topics[2]) === null || _a === void 0
                        ? void 0
                        : _a.valueOf()
                    )
                    .toFixed(0)
                }
                extractAddress(event) {
                  var _a
                  return address_1.Address.fromBuffer(
                    (_a = event.topics[3]) === null || _a === void 0
                      ? void 0
                      : _a.valueOf()
                  ).toString()
                }
              }
              exports.TokenOperationsOutcomeParser =
                TokenOperationsOutcomeParser
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { '../address': 62, '../errors': 66, './codec': 147, buffer: 18 },
      ],
      152: [
        function (require, module, exports) {
          'use strict'
          var __importDefault =
            (this && this.__importDefault) ||
            function (mod) {
              return mod && mod.__esModule ? mod : { default: mod }
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TokenPayment = exports.TokenTransfer = void 0
          const bignumber_js_1 = __importDefault(require('bignumber.js'))
          const errors_1 = require('./errors')
          const EGLDTokenIdentifier = 'EGLD'
          const EGLDNumDecimals = 18
          // Note: this will actually set the default rounding mode for all BigNumber objects in the environment (in the application / dApp).
          bignumber_js_1.default.set({ ROUNDING_MODE: 1 })
          class TokenTransfer {
            constructor(options) {
              const amount = new bignumber_js_1.default(
                options.amountAsBigInteger
              )
              if (!amount.isInteger() || amount.isNegative()) {
                throw new errors_1.ErrInvalidArgument(
                  `bad amountAsBigInteger: ${options.amountAsBigInteger}`
                )
              }
              this.tokenIdentifier = options.tokenIdentifier
              this.nonce = options.nonce
              this.amountAsBigInteger = amount
              this.numDecimals = options.numDecimals || 0
            }
            static egldFromAmount(amount) {
              const amountAsBigInteger = new bignumber_js_1.default(amount)
                .shiftedBy(EGLDNumDecimals)
                .decimalPlaces(0)
              return this.egldFromBigInteger(amountAsBigInteger)
            }
            static egldFromBigInteger(amountAsBigInteger) {
              return new TokenTransfer({
                tokenIdentifier: EGLDTokenIdentifier,
                nonce: 0,
                amountAsBigInteger,
                numDecimals: EGLDNumDecimals,
              })
            }
            static fungibleFromAmount(tokenIdentifier, amount, numDecimals) {
              const amountAsBigInteger = new bignumber_js_1.default(amount)
                .shiftedBy(numDecimals)
                .decimalPlaces(0)
              return this.fungibleFromBigInteger(
                tokenIdentifier,
                amountAsBigInteger,
                numDecimals
              )
            }
            static fungibleFromBigInteger(
              tokenIdentifier,
              amountAsBigInteger,
              numDecimals = 0
            ) {
              return new TokenTransfer({
                tokenIdentifier,
                nonce: 0,
                amountAsBigInteger,
                numDecimals,
              })
            }
            static nonFungible(tokenIdentifier, nonce) {
              return new TokenTransfer({
                tokenIdentifier,
                nonce,
                amountAsBigInteger: 1,
                numDecimals: 0,
              })
            }
            static semiFungible(tokenIdentifier, nonce, quantity) {
              return new TokenTransfer({
                tokenIdentifier,
                nonce,
                amountAsBigInteger: quantity,
                numDecimals: 0,
              })
            }
            static metaEsdtFromAmount(
              tokenIdentifier,
              nonce,
              amount,
              numDecimals
            ) {
              const amountAsBigInteger = new bignumber_js_1.default(amount)
                .shiftedBy(numDecimals)
                .decimalPlaces(0)
              return this.metaEsdtFromBigInteger(
                tokenIdentifier,
                nonce,
                amountAsBigInteger,
                numDecimals
              )
            }
            static metaEsdtFromBigInteger(
              tokenIdentifier,
              nonce,
              amountAsBigInteger,
              numDecimals = 0
            ) {
              return new TokenTransfer({
                tokenIdentifier,
                nonce,
                amountAsBigInteger,
                numDecimals,
              })
            }
            toString() {
              return this.amountAsBigInteger.toFixed(0)
            }
            valueOf() {
              return this.amountAsBigInteger
            }
            toPrettyString() {
              return `${this.toAmount()} ${this.tokenIdentifier}`
            }
            toAmount() {
              return this.amountAsBigInteger
                .shiftedBy(-this.numDecimals)
                .toFixed(this.numDecimals)
            }
            isEgld() {
              return this.tokenIdentifier == EGLDTokenIdentifier
            }
            isFungible() {
              return this.nonce == 0
            }
          }
          exports.TokenTransfer = TokenTransfer
          /**
           * @deprecated use {@link TokenTransfer} instead.
           */
          class TokenPayment extends TokenTransfer {
            constructor(
              tokenIdentifier,
              nonce,
              amountAsBigInteger,
              numDecimals
            ) {
              super({
                tokenIdentifier,
                nonce,
                amountAsBigInteger,
                numDecimals,
              })
            }
          }
          exports.TokenPayment = TokenPayment
        },
        { './errors': 66, 'bignumber.js': 13 },
      ],
      153: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      Object.defineProperty(o, k2, {
                        enumerable: true,
                        get: function () {
                          return m[k]
                        },
                      })
                    }
                  : function (o, m, k, k2) {
                      if (k2 === undefined) k2 = k
                      o[k2] = m[k]
                    })
              var __setModuleDefault =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function (o, v) {
                      Object.defineProperty(o, 'default', {
                        enumerable: true,
                        value: v,
                      })
                    }
                  : function (o, v) {
                      o['default'] = v
                    })
              var __importStar =
                (this && this.__importStar) ||
                function (mod) {
                  if (mod && mod.__esModule) return mod
                  var result = {}
                  if (mod != null)
                    for (var k in mod)
                      if (
                        k !== 'default' &&
                        Object.prototype.hasOwnProperty.call(mod, k)
                      )
                        __createBinding(result, mod, k)
                  __setModuleDefault(result, mod)
                  return result
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.TransactionHash = exports.Transaction = void 0
              const bignumber_js_1 = require('bignumber.js')
              const address_1 = require('./address')
              const compatibility_1 = require('./compatibility')
              const constants_1 = require('./constants')
              const errors = __importStar(require('./errors'))
              const hash_1 = require('./hash')
              const networkParams_1 = require('./networkParams')
              const proto_1 = require('./proto')
              const signature_1 = require('./signature')
              const transactionPayload_1 = require('./transactionPayload')
              const utils_1 = require('./utils')
              const createTransactionHasher = require('blake2b')
              const TRANSACTION_HASH_LENGTH = 32
              /**
               * An abstraction for creating, signing and broadcasting transactions.
               */
              class Transaction {
                /**
                 * Creates a new Transaction object.
                 */
                constructor({
                  nonce,
                  value,
                  sender,
                  receiver,
                  senderUsername,
                  receiverUsername,
                  gasPrice,
                  gasLimit,
                  data,
                  chainID,
                  version,
                  options,
                  guardian,
                }) {
                  this.nonce = nonce || 0
                  this.value = value
                    ? new bignumber_js_1.BigNumber(value.toString()).toFixed(0)
                    : 0
                  this.sender = sender
                  this.receiver = receiver
                  this.senderUsername = senderUsername || ''
                  this.receiverUsername = receiverUsername || ''
                  this.gasPrice =
                    gasPrice || constants_1.TRANSACTION_MIN_GAS_PRICE
                  this.gasLimit = gasLimit
                  this.data =
                    data || new transactionPayload_1.TransactionPayload()
                  this.chainID = chainID
                  this.version = version
                    ? new networkParams_1.TransactionVersion(version.valueOf())
                    : networkParams_1.TransactionVersion.withDefaultVersion()
                  this.options = options
                    ? new networkParams_1.TransactionOptions(options.valueOf())
                    : networkParams_1.TransactionOptions.withDefaultOptions()
                  this.guardian = guardian || address_1.Address.empty()
                  this.signature = Buffer.from([])
                  this.guardianSignature = Buffer.from([])
                  this.hash = TransactionHash.empty()
                }
                getNonce() {
                  return this.nonce
                }
                /**
                 * Sets the account sequence number of the sender. Must be done prior signing.
                 */
                setNonce(nonce) {
                  this.nonce = nonce
                }
                getValue() {
                  return this.value
                }
                setValue(value) {
                  this.value = value
                }
                getSender() {
                  return this.sender
                }
                setSender(sender) {
                  this.sender = sender
                }
                getReceiver() {
                  return this.receiver
                }
                getSenderUsername() {
                  return this.senderUsername
                }
                setSenderUsername(senderUsername) {
                  this.senderUsername = senderUsername
                }
                getReceiverUsername() {
                  return this.receiverUsername
                }
                setReceiverUsername(receiverUsername) {
                  this.receiverUsername = receiverUsername
                }
                getGuardian() {
                  return this.guardian
                }
                getGasPrice() {
                  return this.gasPrice
                }
                setGasPrice(gasPrice) {
                  this.gasPrice = gasPrice
                }
                getGasLimit() {
                  return this.gasLimit
                }
                setGasLimit(gasLimit) {
                  this.gasLimit = gasLimit
                }
                getData() {
                  return this.data
                }
                getChainID() {
                  return this.chainID
                }
                setChainID(chainID) {
                  this.chainID = chainID
                }
                getVersion() {
                  return this.version
                }
                setVersion(version) {
                  this.version = new networkParams_1.TransactionVersion(
                    version.valueOf()
                  )
                }
                getOptions() {
                  // Make sure that "sdk-core v12" is compatible (for a while) with (older) libraries that were previously setting the (soon to be private) "options" field directly,
                  // instead of using the "setOptions()" method.
                  const options = new networkParams_1.TransactionOptions(
                    this.options.valueOf()
                  )
                  return options
                }
                setOptions(options) {
                  this.options = new networkParams_1.TransactionOptions(
                    options.valueOf()
                  )
                }
                getSignature() {
                  return this.signature
                }
                getGuardianSignature() {
                  return this.guardianSignature
                }
                setGuardian(guardian) {
                  this.guardian = guardian
                }
                getHash() {
                  utils_1.guardNotEmpty(this.hash, 'hash')
                  return this.hash
                }
                /**
                 * Serializes a transaction to a sequence of bytes, ready to be signed.
                 * This function is called internally by signers.
                 */
                serializeForSigning() {
                  // TODO: for appropriate tx.version, interpret tx.options accordingly and sign using the content / data hash
                  let plain = this.toPlainObject()
                  // Make sure we never sign the transaction with another signature set up (useful when using the same method for verification)
                  if (plain.signature) {
                    delete plain.signature
                  }
                  if (plain.guardianSignature) {
                    delete plain.guardianSignature
                  }
                  if (!plain.guardian) {
                    delete plain.guardian
                  }
                  let serialized = JSON.stringify(plain)
                  return Buffer.from(serialized)
                }
                /**
                 * Checks the integrity of the guarded transaction
                 */
                isGuardedTransaction() {
                  const hasGuardian = this.guardian.bech32().length > 0
                  const hasGuardianSignature = this.guardianSignature.length > 0
                  return (
                    this.getOptions().isWithGuardian() &&
                    hasGuardian &&
                    hasGuardianSignature
                  )
                }
                /**
                 * Converts the transaction object into a ready-to-serialize, plain JavaScript object.
                 * This function is called internally within the signing procedure.
                 */
                toPlainObject() {
                  var _a
                  const plainObject = {
                    nonce: this.nonce.valueOf(),
                    value: this.value.toString(),
                    receiver: this.receiver.bech32(),
                    sender: this.sender.bech32(),
                    senderUsername: this.senderUsername
                      ? Buffer.from(this.senderUsername).toString('base64')
                      : undefined,
                    receiverUsername: this.receiverUsername
                      ? Buffer.from(this.receiverUsername).toString('base64')
                      : undefined,
                    gasPrice: this.gasPrice.valueOf(),
                    gasLimit: this.gasLimit.valueOf(),
                    data:
                      this.data.length() == 0 ? undefined : this.data.encoded(),
                    chainID: this.chainID.valueOf(),
                    version: this.getVersion().valueOf(),
                    options:
                      this.getOptions().valueOf() == 0
                        ? undefined
                        : this.getOptions().valueOf(),
                    guardian: (
                      (_a = this.guardian) === null || _a === void 0
                        ? void 0
                        : _a.bech32()
                    )
                      ? this.guardian.bech32() == ''
                        ? undefined
                        : this.guardian.bech32()
                      : undefined,
                    signature: this.signature.toString('hex')
                      ? this.signature.toString('hex')
                      : undefined,
                    guardianSignature: this.guardianSignature.toString('hex')
                      ? this.guardianSignature.toString('hex')
                      : undefined,
                  }
                  compatibility_1.Compatibility.guardAddressIsSetAndNonZero(
                    new address_1.Address(plainObject.sender),
                    "'sender' of transaction",
                    'pass the actual sender to the Transaction constructor'
                  )
                  return plainObject
                }
                /**
                 * Converts a plain object transaction into a Transaction Object.
                 *
                 * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()
                 */
                static fromPlainObject(plainObjectTransaction) {
                  const tx = new Transaction({
                    nonce: Number(plainObjectTransaction.nonce),
                    value: new bignumber_js_1.BigNumber(
                      plainObjectTransaction.value
                    ).toFixed(0),
                    receiver: address_1.Address.fromString(
                      plainObjectTransaction.receiver
                    ),
                    receiverUsername: plainObjectTransaction.receiverUsername
                      ? Buffer.from(
                          plainObjectTransaction.receiverUsername,
                          'base64'
                        ).toString()
                      : undefined,
                    sender: address_1.Address.fromString(
                      plainObjectTransaction.sender
                    ),
                    senderUsername: plainObjectTransaction.senderUsername
                      ? Buffer.from(
                          plainObjectTransaction.senderUsername,
                          'base64'
                        ).toString()
                      : undefined,
                    guardian: plainObjectTransaction.guardian
                      ? address_1.Address.fromString(
                          plainObjectTransaction.guardian
                        )
                      : undefined,
                    gasPrice: Number(plainObjectTransaction.gasPrice),
                    gasLimit: Number(plainObjectTransaction.gasLimit),
                    data: new transactionPayload_1.TransactionPayload(
                      Buffer.from(plainObjectTransaction.data || '', 'base64')
                    ),
                    chainID: String(plainObjectTransaction.chainID),
                    version: new networkParams_1.TransactionVersion(
                      plainObjectTransaction.version
                    ),
                    options:
                      plainObjectTransaction.options != null
                        ? new networkParams_1.TransactionOptions(
                            plainObjectTransaction.options
                          )
                        : undefined,
                  })
                  if (plainObjectTransaction.signature) {
                    tx.applySignature(
                      new signature_1.Signature(
                        plainObjectTransaction.signature
                      )
                    )
                  }
                  if (plainObjectTransaction.guardianSignature) {
                    tx.applyGuardianSignature(
                      new signature_1.Signature(
                        plainObjectTransaction.guardianSignature
                      )
                    )
                  }
                  return tx
                }
                /**
                 * Applies the signature on the transaction.
                 *
                 * @param signature The signature, as computed by a signer.
                 */
                applySignature(signature) {
                  this.signature =
                    signature_1.interpretSignatureAsBuffer(signature)
                  this.hash = TransactionHash.compute(this)
                }
                /**
                 * Applies the guardian signature on the transaction.
                 *
                 * @param guardianSignature The signature, as computed by a signer.
                 */
                applyGuardianSignature(guardianSignature) {
                  this.guardianSignature =
                    signature_1.interpretSignatureAsBuffer(guardianSignature)
                  this.hash = TransactionHash.compute(this)
                }
                /**
                 * Converts a transaction to a ready-to-broadcast object.
                 * Called internally by the network provider.
                 */
                toSendable() {
                  return this.toPlainObject()
                }
                /**
                 * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties
                 * @param networkConfig {@link NetworkConfig}
                 */
                computeFee(networkConfig) {
                  let moveBalanceGas =
                    networkConfig.MinGasLimit.valueOf() +
                    this.data.length() * networkConfig.GasPerDataByte.valueOf()
                  if (moveBalanceGas > this.gasLimit.valueOf()) {
                    throw new errors.ErrNotEnoughGas(this.gasLimit.valueOf())
                  }
                  let gasPrice = new bignumber_js_1.BigNumber(
                    this.gasPrice.valueOf()
                  )
                  let feeForMove = new bignumber_js_1.BigNumber(
                    moveBalanceGas
                  ).multipliedBy(gasPrice)
                  if (moveBalanceGas === this.gasLimit.valueOf()) {
                    return feeForMove
                  }
                  let diff = new bignumber_js_1.BigNumber(
                    this.gasLimit.valueOf() - moveBalanceGas
                  )
                  let modifiedGasPrice = gasPrice.multipliedBy(
                    new bignumber_js_1.BigNumber(
                      networkConfig.GasPriceModifier.valueOf()
                    )
                  )
                  let processingFee = diff.multipliedBy(modifiedGasPrice)
                  return feeForMove.plus(processingFee)
                }
              }
              exports.Transaction = Transaction
              /**
               * An abstraction for handling and computing transaction hashes.
               */
              class TransactionHash extends hash_1.Hash {
                constructor(hash) {
                  super(hash)
                }
                /**
                 * Computes the hash of a transaction.
                 */
                static compute(transaction) {
                  let serializer = new proto_1.ProtoSerializer()
                  let buffer = serializer.serializeTransaction(transaction)
                  let hash = createTransactionHasher(TRANSACTION_HASH_LENGTH)
                    .update(buffer)
                    .digest('hex')
                  return new TransactionHash(hash)
                }
              }
              exports.TransactionHash = TransactionHash
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        {
          './address': 62,
          './compatibility': 64,
          './constants': 65,
          './errors': 66,
          './hash': 69,
          './networkParams': 74,
          './proto': 76,
          './signature': 82,
          './transactionPayload': 154,
          './utils': 158,
          'bignumber.js': 13,
          blake2b: 16,
          buffer: 18,
        },
      ],
      154: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.TransactionPayload = void 0
              /**
               * The "data" field of a Transaction, as an immutable object.
               */
              class TransactionPayload {
                /**
                 * Creates a TransactionPayload from a utf-8 string or from a buffer.
                 */
                constructor(data) {
                  this.data = Buffer.from(data || [])
                }
                /**
                 * Creates a TransactionPayload from a base-64 encoded string.
                 */
                static fromEncoded(encoded) {
                  if (!encoded) {
                    return new TransactionPayload('')
                  }
                  let decoded = Buffer.from(encoded, 'base64').toString()
                  return new TransactionPayload(decoded)
                }
                /**
                 * Returns whether the "data" is void.
                 */
                isEmpty() {
                  return this.data.length == 0
                }
                /**
                 * Returns the base-64 representation of the data.
                 */
                encoded() {
                  return this.data.toString('base64')
                }
                /**
                 * Returns the data as a buffer.
                 */
                valueOf() {
                  return this.data
                }
                toString() {
                  return this.data.toString()
                }
                getEncodedArguments() {
                  return this.toString().split('@')
                }
                getRawArguments() {
                  return this.getEncodedArguments().map((argument) =>
                    Buffer.from(argument, 'hex')
                  )
                }
                /**
                 * Returns the length of the data.
                 */
                length() {
                  return Buffer.from(this.data).length
                }
              }
              exports.TransactionPayload = TransactionPayload
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { buffer: 18 },
      ],
      155: [
        function (require, module, exports) {
          'use strict'
          var __awaiter =
            (this && this.__awaiter) ||
            function (thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P
                  ? value
                  : new P(function (resolve) {
                      resolve(value)
                    })
              }
              return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value))
                  } catch (e) {
                    reject(e)
                  }
                }
                function rejected(value) {
                  try {
                    step(generator['throw'](value))
                  } catch (e) {
                    reject(e)
                  }
                }
                function step(result) {
                  result.done
                    ? resolve(result.value)
                    : adopt(result.value).then(fulfilled, rejected)
                }
                step(
                  (generator = generator.apply(
                    thisArg,
                    _arguments || []
                  )).next()
                )
              })
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TransactionWatcher = void 0
          const asyncTimer_1 = require('./asyncTimer')
          const errors_1 = require('./errors')
          const logger_1 = require('./logger')
          /**
           * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.
           */
          class TransactionWatcher {
            /**
             * A transaction watcher (awaiter).
             *
             * @param fetcher The transaction fetcher
             * @param options The options
             * @param options.pollingIntervalMilliseconds The polling interval, in milliseconds
             * @param options.timeoutMilliseconds The timeout, in milliseconds
             * @param options.patienceMilliseconds The patience: an extra time (in milliseconds) to wait, after the transaction has reached its desired status. Currently there's a delay between the moment a transaction is marked as "completed" and the moment its outcome (contract results, events and logs) is available.
             */
            constructor(fetcher, options = {}) {
              this.fetcher = new TransactionFetcherWithTracing(fetcher)
              this.pollingIntervalMilliseconds =
                options.pollingIntervalMilliseconds ||
                TransactionWatcher.DefaultPollingInterval
              this.timeoutMilliseconds =
                options.timeoutMilliseconds || TransactionWatcher.DefaultTimeout
              this.patienceMilliseconds =
                options.patienceMilliseconds ||
                TransactionWatcher.DefaultPatience
            }
            /**
             * Waits until the transaction reaches the "pending" status.
             */
            awaitPending(transaction) {
              return __awaiter(this, void 0, void 0, function* () {
                const isPending = (transaction) =>
                  transaction.status.isPending()
                const doFetch = () =>
                  __awaiter(this, void 0, void 0, function* () {
                    return yield this.fetcher.getTransaction(
                      transaction.getHash().hex()
                    )
                  })
                const errorProvider = () =>
                  new errors_1.ErrExpectedTransactionStatusNotReached()
                return this.awaitConditionally(
                  isPending,
                  doFetch,
                  errorProvider
                )
              })
            }
            /**
             * Waits until the transaction is completely processed.
             */
            awaitCompleted(transaction) {
              return __awaiter(this, void 0, void 0, function* () {
                const isCompleted = (transactionOnNetwork) => {
                  if (transactionOnNetwork.isCompleted === undefined) {
                    throw new errors_1.ErrIsCompletedFieldIsMissingOnTransaction()
                  }
                  return transactionOnNetwork.isCompleted
                }
                const doFetch = () =>
                  __awaiter(this, void 0, void 0, function* () {
                    return yield this.fetcher.getTransaction(
                      transaction.getHash().hex()
                    )
                  })
                const errorProvider = () =>
                  new errors_1.ErrExpectedTransactionStatusNotReached()
                return this.awaitConditionally(
                  isCompleted,
                  doFetch,
                  errorProvider
                )
              })
            }
            awaitAllEvents(transaction, events) {
              return __awaiter(this, void 0, void 0, function* () {
                const foundAllEvents = (transactionOnNetwork) => {
                  const allEventIdentifiers = this.getAllTransactionEvents(
                    transactionOnNetwork
                  ).map((event) => event.identifier)
                  const allAreFound = events.every((event) =>
                    allEventIdentifiers.includes(event)
                  )
                  return allAreFound
                }
                const doFetch = () =>
                  __awaiter(this, void 0, void 0, function* () {
                    return yield this.fetcher.getTransaction(
                      transaction.getHash().hex()
                    )
                  })
                const errorProvider = () =>
                  new errors_1.ErrExpectedTransactionEventsNotFound()
                return this.awaitConditionally(
                  foundAllEvents,
                  doFetch,
                  errorProvider
                )
              })
            }
            awaitAnyEvent(transaction, events) {
              return __awaiter(this, void 0, void 0, function* () {
                const foundAnyEvent = (transactionOnNetwork) => {
                  const allEventIdentifiers = this.getAllTransactionEvents(
                    transactionOnNetwork
                  ).map((event) => event.identifier)
                  const anyIsFound =
                    events.find((event) =>
                      allEventIdentifiers.includes(event)
                    ) != undefined
                  return anyIsFound
                }
                const doFetch = () =>
                  __awaiter(this, void 0, void 0, function* () {
                    return yield this.fetcher.getTransaction(
                      transaction.getHash().hex()
                    )
                  })
                const errorProvider = () =>
                  new errors_1.ErrExpectedTransactionEventsNotFound()
                return this.awaitConditionally(
                  foundAnyEvent,
                  doFetch,
                  errorProvider
                )
              })
            }
            awaitOnCondition(transaction, condition) {
              return __awaiter(this, void 0, void 0, function* () {
                const doFetch = () =>
                  __awaiter(this, void 0, void 0, function* () {
                    return yield this.fetcher.getTransaction(
                      transaction.getHash().hex()
                    )
                  })
                const errorProvider = () =>
                  new errors_1.ErrExpectedTransactionStatusNotReached()
                return this.awaitConditionally(
                  condition,
                  doFetch,
                  errorProvider
                )
              })
            }
            awaitConditionally(isSatisfied, doFetch, createError) {
              return __awaiter(this, void 0, void 0, function* () {
                const periodicTimer = new asyncTimer_1.AsyncTimer(
                  'watcher:periodic'
                )
                const patienceTimer = new asyncTimer_1.AsyncTimer(
                  'watcher:patience'
                )
                const timeoutTimer = new asyncTimer_1.AsyncTimer(
                  'watcher:timeout'
                )
                let stop = false
                let fetchedData = undefined
                let satisfied = false
                timeoutTimer.start(this.timeoutMilliseconds).finally(() => {
                  timeoutTimer.stop()
                  stop = true
                })
                while (!stop) {
                  yield periodicTimer.start(this.pollingIntervalMilliseconds)
                  try {
                    fetchedData = yield doFetch()
                    satisfied = isSatisfied(fetchedData)
                    if (satisfied || stop) {
                      break
                    }
                  } catch (error) {
                    logger_1.Logger.debug(
                      'TransactionWatcher.awaitConditionally(): cannot (yet) fetch data.'
                    )
                    if (
                      error instanceof
                      errors_1.ErrIsCompletedFieldIsMissingOnTransaction
                    ) {
                      throw error
                    }
                    if (!(error instanceof errors_1.Err)) {
                      throw error
                    }
                  }
                }
                // The patience timer isn't subject to the timeout constraints.
                if (satisfied) {
                  yield patienceTimer.start(this.patienceMilliseconds)
                }
                if (!timeoutTimer.isStopped()) {
                  timeoutTimer.stop()
                }
                if (!fetchedData || !satisfied) {
                  throw createError()
                }
                return fetchedData
              })
            }
            getAllTransactionEvents(transaction) {
              const result = [...transaction.logs.events]
              for (const resultItem of transaction.contractResults.items) {
                result.push(...resultItem.logs.events)
              }
              return result
            }
          }
          exports.TransactionWatcher = TransactionWatcher
          TransactionWatcher.DefaultPollingInterval = 6000
          TransactionWatcher.DefaultTimeout =
            TransactionWatcher.DefaultPollingInterval * 15
          TransactionWatcher.DefaultPatience = 0
          TransactionWatcher.NoopOnStatusReceived = (_) => {}
          class TransactionFetcherWithTracing {
            constructor(fetcher) {
              this.fetcher = fetcher
            }
            getTransaction(txHash) {
              return __awaiter(this, void 0, void 0, function* () {
                logger_1.Logger.debug(
                  `transactionWatcher, getTransaction(${txHash})`
                )
                return yield this.fetcher.getTransaction(txHash)
              })
            }
          }
        },
        { './asyncTimer': 63, './errors': 66, './logger': 73 },
      ],
      156: [
        function (require, module, exports) {
          'use strict'
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.TransferTransactionsFactory = void 0
          const argSerializer_1 = require('./smartcontracts/argSerializer')
          const typesystem_1 = require('./smartcontracts/typesystem')
          const transaction_1 = require('./transaction')
          const transactionPayload_1 = require('./transactionPayload')
          class TransferTransactionsFactory {
            constructor(gasEstimator) {
              this.gasEstimator = gasEstimator
            }
            createEGLDTransfer(args) {
              var _a
              const dataLength =
                ((_a = args.data) === null || _a === void 0
                  ? void 0
                  : _a.length()) || 0
              const estimatedGasLimit =
                this.gasEstimator.forEGLDTransfer(dataLength)
              return new transaction_1.Transaction({
                nonce: args.nonce,
                value: args.value,
                receiver: args.receiver,
                sender: args.sender,
                gasPrice: args.gasPrice,
                gasLimit: args.gasLimit || estimatedGasLimit,
                data: args.data,
                chainID: args.chainID,
              })
            }
            createESDTTransfer(args) {
              const { argumentsString } =
                new argSerializer_1.ArgSerializer().valuesToString([
                  // The token identifier
                  typesystem_1.BytesValue.fromUTF8(
                    args.tokenTransfer.tokenIdentifier
                  ),
                  // The transfered amount
                  new typesystem_1.BigUIntValue(args.tokenTransfer.valueOf()),
                ])
              const data = `ESDTTransfer@${argumentsString}`
              const transactionPayload =
                new transactionPayload_1.TransactionPayload(data)
              const dataLength = transactionPayload.length() || 0
              const estimatedGasLimit =
                this.gasEstimator.forESDTTransfer(dataLength)
              return new transaction_1.Transaction({
                nonce: args.nonce,
                receiver: args.receiver,
                sender: args.sender,
                gasPrice: args.gasPrice,
                gasLimit: args.gasLimit || estimatedGasLimit,
                data: transactionPayload,
                chainID: args.chainID,
              })
            }
            createESDTNFTTransfer(args) {
              const { argumentsString } =
                new argSerializer_1.ArgSerializer().valuesToString([
                  // The token identifier
                  typesystem_1.BytesValue.fromUTF8(
                    args.tokenTransfer.tokenIdentifier
                  ),
                  // The nonce of the token
                  new typesystem_1.U64Value(args.tokenTransfer.nonce),
                  // The transferred quantity
                  new typesystem_1.BigUIntValue(args.tokenTransfer.valueOf()),
                  // The destination address
                  new typesystem_1.AddressValue(args.destination),
                ])
              const data = `ESDTNFTTransfer@${argumentsString}`
              const transactionPayload =
                new transactionPayload_1.TransactionPayload(data)
              const dataLength = transactionPayload.length() || 0
              const estimatedGasLimit =
                this.gasEstimator.forESDTNFTTransfer(dataLength)
              return new transaction_1.Transaction({
                nonce: args.nonce,
                receiver: args.sender,
                sender: args.sender,
                gasPrice: args.gasPrice,
                gasLimit: args.gasLimit || estimatedGasLimit,
                data: transactionPayload,
                chainID: args.chainID,
              })
            }
            createMultiESDTNFTTransfer(args) {
              const parts = [
                // The destination address
                new typesystem_1.AddressValue(args.destination),
                // Number of tokens
                new typesystem_1.U16Value(args.tokenTransfers.length),
              ]
              for (const payment of args.tokenTransfers) {
                parts.push(
                  ...[
                    // The token identifier
                    typesystem_1.BytesValue.fromUTF8(payment.tokenIdentifier),
                    // The nonce of the token
                    new typesystem_1.U64Value(payment.nonce),
                    // The transfered quantity
                    new typesystem_1.BigUIntValue(payment.valueOf()),
                  ]
                )
              }
              const { argumentsString } =
                new argSerializer_1.ArgSerializer().valuesToString(parts)
              const data = `MultiESDTNFTTransfer@${argumentsString}`
              const transactionPayload =
                new transactionPayload_1.TransactionPayload(data)
              const dataLength = transactionPayload.length() || 0
              const estimatedGasLimit =
                this.gasEstimator.forMultiESDTNFTTransfer(
                  dataLength,
                  args.tokenTransfers.length
                )
              return new transaction_1.Transaction({
                nonce: args.nonce,
                receiver: args.sender,
                sender: args.sender,
                gasPrice: args.gasPrice,
                gasLimit: args.gasLimit || estimatedGasLimit,
                data: transactionPayload,
                chainID: args.chainID,
              })
            }
          }
          exports.TransferTransactionsFactory = TransferTransactionsFactory
        },
        {
          './smartcontracts/argSerializer': 83,
          './smartcontracts/typesystem': 135,
          './transaction': 153,
          './transactionPayload': 154,
        },
      ],
      157: [
        function (require, module, exports) {
          ;(function (Buffer) {
            ;(function () {
              'use strict'
              var __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule ? mod : { default: mod }
                }
              Object.defineProperty(exports, '__esModule', { value: true })
              exports.zeroPadStringIfOddLength =
                exports.isPaddedHex =
                exports.numberToPaddedHex =
                  void 0
              const bignumber_js_1 = __importDefault(require('bignumber.js'))
              function numberToPaddedHex(value) {
                let hex = new bignumber_js_1.default(value).toString(16)
                return zeroPadStringIfOddLength(hex)
              }
              exports.numberToPaddedHex = numberToPaddedHex
              function isPaddedHex(input) {
                input = input || ''
                let decodedThenEncoded = Buffer.from(input, 'hex').toString(
                  'hex'
                )
                return input.toUpperCase() == decodedThenEncoded.toUpperCase()
              }
              exports.isPaddedHex = isPaddedHex
              function zeroPadStringIfOddLength(input) {
                input = input || ''
                if (input.length % 2 == 1) {
                  return '0' + input
                }
                return input
              }
              exports.zeroPadStringIfOddLength = zeroPadStringIfOddLength
            }.call(this))
          }.call(this, require('buffer').Buffer))
        },
        { 'bignumber.js': 13, buffer: 18 },
      ],
      158: [
        function (require, module, exports) {
          'use strict'
          var __createBinding =
            (this && this.__createBinding) ||
            (Object.create
              ? function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  Object.defineProperty(o, k2, {
                    enumerable: true,
                    get: function () {
                      return m[k]
                    },
                  })
                }
              : function (o, m, k, k2) {
                  if (k2 === undefined) k2 = k
                  o[k2] = m[k]
                })
          var __setModuleDefault =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (o, v) {
                  Object.defineProperty(o, 'default', {
                    enumerable: true,
                    value: v,
                  })
                }
              : function (o, v) {
                  o['default'] = v
                })
          var __importStar =
            (this && this.__importStar) ||
            function (mod) {
              if (mod && mod.__esModule) return mod
              var result = {}
              if (mod != null)
                for (var k in mod)
                  if (
                    k !== 'default' &&
                    Object.prototype.hasOwnProperty.call(mod, k)
                  )
                    __createBinding(result, mod, k)
              __setModuleDefault(result, mod)
              return result
            }
          Object.defineProperty(exports, '__esModule', { value: true })
          exports.isEmpty =
            exports.guardEmpty =
            exports.guardNotEmpty =
            exports.guardLength =
            exports.guardSameLength =
            exports.guardValueIsSetWithMessage =
            exports.guardValueIsSet =
            exports.guardTrue =
              void 0
          const errors = __importStar(require('./errors'))
          // TODO: Create a class called "Guard". Add the following as member functions.
          function guardTrue(value, what) {
            if (!value) {
              throw new errors.ErrInvariantFailed(`[<${what}>] isn't true`)
            }
          }
          exports.guardTrue = guardTrue
          // TODO: merge with guardValueIsSetWithMessage
          function guardValueIsSet(name, value) {
            guardValueIsSetWithMessage(
              `${name} isn't set (null or undefined)`,
              value
            )
          }
          exports.guardValueIsSet = guardValueIsSet
          // TODO: merge with guardValueIsSet
          function guardValueIsSetWithMessage(message, value) {
            if (value == null || value === undefined) {
              throw new errors.ErrInvariantFailed(message)
            }
          }
          exports.guardValueIsSetWithMessage = guardValueIsSetWithMessage
          function guardSameLength(a, b) {
            a = a || []
            b = b || []
            if (a.length != b.length) {
              throw new errors.ErrInvariantFailed(
                'arrays do not have the same length'
              )
            }
          }
          exports.guardSameLength = guardSameLength
          function guardLength(withLength, expectedLength) {
            let actualLength = withLength.length || 0
            if (actualLength != expectedLength) {
              throw new errors.ErrInvariantFailed(
                `wrong length, expected: ${expectedLength}, actual: ${actualLength}`
              )
            }
          }
          exports.guardLength = guardLength
          function guardNotEmpty(value, what) {
            if (isEmpty(value)) {
              throw new errors.ErrInvariantFailed(`${what} is empty`)
            }
          }
          exports.guardNotEmpty = guardNotEmpty
          function guardEmpty(value, what) {
            if (!isEmpty(value)) {
              throw new errors.ErrInvariantFailed(`${what} is not empty`)
            }
          }
          exports.guardEmpty = guardEmpty
          function isEmpty(value) {
            if (value.isEmpty) {
              return value.isEmpty()
            }
            return value.length === 0
          }
          exports.isEmpty = isEmpty
        },
        { './errors': 66 },
      ],
    },
    {},
    [70]
  )(70)
})
